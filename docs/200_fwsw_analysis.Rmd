---
title: "FWSW with smallest dataset"
author: "Sarah P. Flanagan"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document: default
  pdf_document:
    fig_caption: yes
graphics: yes
editor_options:
  chunk_output_type: console
description: Re-running the freshwater-saltwater analysis using only the dataset from
  pairwise population comparisons
---

In my initial analysis of the freshwater-saltwater dataset, I had three vcf files: 
1. one generated from all pairwise comparisons of populations, containing SNPs only found in all 16 populations, in 75% of individuals, and with a minor allele frequency of at least 5%. ("separate")
2. one generated from all pairwise comparisons of populations, containing SNPs found in 4 populations, in 75% of individuals, and with a minor allele frequency of at least 5%. ("P4")
3. one generated from comparing lumped 'freshwater' and 'saltwater' populations, containing SNPs found in 50% of individuals and with a minor allele frequency of at least 5%. ("lumped")

I did the majority of the analyses using set #3, but would like to explore what changes if I use dataset #2. I think #1 is too restrictive. Dataset #2 is in the "subset" dataset, and is what I ran the structure analyses on. This is the dataset I'm going to move forward with for the paper.

Note that in most of these cases the actual analysis will be set to `eval=FALSE` once I've run it once, because then I save the output and only have to read it in, saving compilation time.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,out.extra='',fig.pos="H")
knitr::opts_knit$set(root.dir='./fwsw_results/')
```
```{r source}
source("../../gwscaR/R/gwscaR.R")
source("../../gwscaR/R/gwscaR_plot.R")
source("../../gwscaR/R/gwscaR_utility.R")
source("../../gwscaR/R/gwscaR_fsts.R")
source("../../gwscaR/R/gwscaR_popgen.R")
source("../../gwscaR/R/vcf2dadi.R")
source("../R/203_treemix_plotting_funcs.R")#I've modified these functions
library(knitr)
```

```{r access_analysis, echo=FALSE}
knitr::read_chunk("../R/200_fwsw_analysis.R")
```

```{r LoadFWSWpackages, include=FALSE}
```
```{r FWSWsetup}
```

```{r pwiseFstsFiles,eval=FALSE}
```

```{r P4plink,cache=TRUE}
```

This P4/subset dataset has `r nrow(map.sub)` SNPs from `r length(unique(gsub("(\\d+)_\\d+","\\1",map.sub$V2)))` RAD loci, from `r nrow(ped.sub)` indivudals in 16 populations.

## Generate a new vcf file

The first thing to do is to create a vcf file using the subset parameters. I've already got a whitelist of loci in the subsetted dataset, so I need to run `populations -b 2 -W fwsw_results/subset.whitelist.txt -P fwsw_results/stacks -M fwsw_pops_map.txt --vcf`, which I did on 2017-12-18 on silivren-lond. I then re-named it to p4.vcf (and the other output files).


```{r read_vcf,cache=TRUE}
vcf<-parse.vcf("p4.upd.vcf") #this is the smaller dataset
```
```{r vcfSetup, echo=TRUE}
```

The vcf file contains `r nrow(vcf)` SNPs from `r length(unique(vcf$ID))` RAD loci.

Choose a subset of the SNPs to re-use. [Do I need to do this?]

```{r choose_subset, eval=FALSE} 
chosen.snps<-choose.one.snp(vcf)$SNP
write.table(chosen.snps,"chosen.all.snps.txt",quote=F)
```

```{r read_subset}
chosen.snps<-unlist(read.table("chosen.all.snps.txt"))
```

There are `r length(chosen.snps)` SNPs that I'll use from the vcf file, from `r nrow(vcf)` RAD loci.

Create a dadi SNPs file from the vcf

```{r create_dadi}
dadi<-vcf2dadiSNPs(vcf,pop.list = pop.list,filename = "dadi_analysis/fwsw.dadi.snps")
projections<-unlist(lapply(pop.list,function(pop){ n<-length(grep(pop,colnames(vcf)))}))*2
```

## Figure 1

The first figure in the paper is a map of the collection sites.

```{r map, eval=FALSE}
```
![Figure 1. Map of collection sites](fwsw_results/all_sites_map.jpg)

## Figure 2

The second figure in the paper is showing population structure, using STRUCTURE, adegenet, and PCAdapt. These analyses were run as exactly written in `002_fwsw_analysis.R`, so I won't reproduce that code here. 

```{r Adegenet, eval=FALSE, echo=FALSE}
```
```{r pcadapt, eval=FALSE, echo=FALSE}
```
```{r readStructure, eval=FALSE, echo=FALSE}
```
```{r AnalyzeStructure, eval=FALSE, echo=FALSE}
```
```{r PopStructurePlot, eval=FALSE, echo=FALSE}
```


<!-- ![Figure 2. Population Structure](fwsw_results/pop_structure_comb.jpeg) -->

Now for a combined figure:

```{r dapcData,eval=FALSE}
```
```{r rereadFiles, echo=FALSE,eval=FALSE}
pa<-readRDS("pcadapt.RDS")
pap<-read.delim("pap_pcadapt.txt",header=TRUE)
structure.k2<-read.table(
  "structure//fwsw//admix//Results//admix_run_2_f_clusters.txt",
  sep='\t', header=F)
structure.k2$V1<-sub('sample_([A-Z]{4})','\\1', structure.k2$V1)
tapply(structure.k2$V2,structure.k2$V1,max) #V2 has TX group

structure.k6<-read.table(
  "structure//fwsw//admix//Results//admix_run_6_f_clusters.txt",
  sep='\t', header=F)
structure.k6$V1<-sub('sample_([A-Z]{4})','\\1', structure.k6$V1)
structure.k6[structure.k6[,1]=="FLLG",1]<-"FLFW"
structure.k6<-data.frame(structure.k6$V1,structure.k6$V3,structure.k6$V4,structure.k6$V2,
                 structure.k6$V5,structure.k6$V7,structure.k6$V6,stringsAsFactors = F)


```
```{r combinedFig2,eval=FALSE}
npop<-length(pop.list)
pseq<-1:npop
m<-matrix(c(1:32,rep(33,7),rep(34,7),rep(0,2),
            rep(35,7),rep(36,7),rep(0,2)),
          nrow=4,ncol=npop,byrow = T)
jpeg("combinedStructure.jpeg",res=300,height=8,width=8,units="in")
layout(mat=m,heights=c(1,1,6,6))
#STRUCTURE
par(oma=c(1.5,3.5,1,1),mar=c(1,0,0,0))
plotting.structure(structure.k2,2,pop.list, make.file=FALSE, xlabcol = all.colors,plot.new=F,
                   colors=grp.colors[c(1,6)],xlabel=F,
                   ylabel=expression(atop(italic(K)==2,358.9)))
plotting.structure(structure.k6,2,pop.labs, make.file=FALSE,
                   plot.new=F,colors=grp.colors,xlabel=T,
                   xlabcol = all.colors,
                   ylabel=expression(atop(italic(K)==6,326.1)))
#PCADAPT
par(mar=c(2,2,2,2))
plot(pa$scores[,1],pa$scores[,2],col=alpha(pap$cols,0.5),bg=alpha(pap$cols,0.75),
     pch=as.numeric(pap$pch),	cex=2,bty="L",xlab="",ylab="",cex.axis=1.5)
#points(pa$scores[grp=="freshwater",1],pa$scores[grp=="freshwater",2],
#       col=alpha(pap$cols[pap$grp=="freshwater"],0.5),
#       bg=alpha(pap$cols[pap$grp=="freshwater"],0.75),pch=as.numeric(pap$pch[pap$grp=="freshwater"]),
#       cex=2) #to highlight the fw pops
mtext(paste("PC1 (",pa.props[1],"%)",sep=""),1,line = 2.5,cex=1)
mtext(paste("PC2 (",pa.props[2],"%)",sep=""),2,line = 2.5,cex=1)

plot(pa$scores[,3],pa$scores[,4],col=alpha(pap$cols,0.5),bg=alpha(pap$cols,0.75),pch=as.numeric(pap$pch),
     cex=2,	bty="L",xlab="",ylab="",cex.axis=1.5)
#points(pa$scores[grp=="freshwater",3],pa$scores[grp=="freshwater",4],
#     col=alpha(pap$cols[pap$grp=="freshwater"],0.5),
#     bg=alpha(pap$cols[pap$grp=="freshwater"],0.75),pch=as.numeric(pap$pch[pap$grp=="freshwater"]),
#     cex=2)
mtext(paste("PC3 (",pa.props[3],"%)",sep=""),1,line = 2.5,cex=1)
mtext(paste("PC4 (",pa.props[4],"%)",sep=""),2,line = 2.5,cex=1)

# plot(pa$scores[,5],pa$scores[,6],col=alpha(pap$cols,0.5),bg=alpha(pap$cols,0.75),pch=as.numeric(pap$pch),
#      cex=1.5,bty="L",xlab="",ylab="")
# points(pa$scores[grp=="freshwater",5],pa$scores[grp=="freshwater",6],
#        col=alpha(pap$cols[pap$grp=="freshwater"],0.5),
#        bg=alpha(pap$cols[pap$grp=="freshwater"],0.75),pch=as.numeric(pap$pch[pap$grp=="freshwater"]),
#        cex=1.5)
# mtext(paste("PC5 (",pa.props[5],"%)",sep=""),1,line = 2,cex=0.75)
# mtext(paste("PC6 (",pa.props[6],"%)",sep=""),2,line = 2,cex=0.75)

# ADEGENET
par(mar=c(2,2,2,2))
plot(da$LD1,da$LD2,col=alpha(da$colors,0.5),pch=as.numeric(da$pch),cex=2,lwd=1.3,
     bg=alpha(da$colors,0.75),xlab="",ylab="",xlim=c(-10,25),ylim=c(-10,15),bty="n",cex.axis=1.5)
par(lwd=3,bty='n')
s.class(dapc1$ind.coord,fac=factor(da$Group), clabel=0,cstar=0,cellipse=2.5,
        addaxes = F,pch="",grid=F,axesel=F,add.plot = T,col=grp.colors[c(1,5,6,3,2,4)],xlim=c(-10,25),ylim=c(-10,15))
mtext(paste("DAPC 1 (", round(dapc1$eig[1]/sum(dapc1$eig)*100, 2), "%)", sep=""),
      1, line = 2.5,cex=1)
mtext(paste("DAPC 2 (", round(dapc1$eig[2]/sum(dapc1$eig)*100, 2), "%)", sep=""),
      2, line = 2.1,cex=1)


plot(da$LD3,da$LD4,col=alpha(da$colors,0.5),pch=as.numeric(da$pch),cex=2,lwd=1.3,
     bg=alpha(da$colors,0.75),xlab="",ylab="",xlim=c(-10,10),ylim=c(-10,5),cex.axis=1.5,bty="n")
par(lwd=3,bty='n')
s.class(dapc1$ind.coord[,3:4],fac=factor(da$Group), clabel=0,cstar=0,cellipse=2.5,
        addaxes = F,pch="",grid=F,axesel=F,add.plot = T,col=grp.colors[c(1,5,6,3,2,4)],xlim=c(-10,10),ylim=c(-10,5))
mtext(paste("DAPC 3 (", round(dapc1$eig[3]/sum(dapc1$eig)*100, 2), "%)", sep=""),
      1, line = 2.5,cex=1)
mtext(paste("DAPC 4 (", round(dapc1$eig[4]/sum(dapc1$eig)*100, 2), "%)", sep=""),
      2, line = 2.1,cex=1)

# plot(da$LD4,da$LD5,col=alpha(da$colors,0.5),pch=as.numeric(da$pch),cex=2,lwd=1.3,
#      bg=alpha(colors,0.25),xlab="",ylab="",xlim=c(-5,15),ylim=c(-10,5))
# par(lwd=3,bty='n')
# s.class(dapc1$ind.coord[,4:5],fac=factor(da$Group), clabel=0,cstar=0,cellipse=2.5,
#         addaxes = F,pch="",grid=F,axesel=F,add.plot = T,col=grp.colors[c(3,5,6,4,2,1)],xlim=c(-5,15),ylim=c(-10,5))
# mtext(paste("DAPC 4 (", round(dapc1$eig[4]/sum(dapc1$eig)*100, 2), "%)", sep=""),
#       1, line = 2,cex=0.75)
# mtext(paste("DAPC 5 (", round(dapc1$eig[5]/sum(dapc1$eig)*100, 2), "%)", sep=""),
#       2, line = 2,cex=0.75)

par(fig = c(0, 1, 0, 1), oma=c(2,1,0,1), mar = c(0, 0, 0, 0), new = TRUE,
    cex=1,lwd=1.3)
plot(0, 0, type = "n", bty = "n", xaxt = "n", yaxt = "n")
legend(x=0.75,y=0.5, legend=ppi$Pop, pch=as.numeric(ppi$pch), pt.cex=1.5,cex=1,
       col=alpha(ppi$cols, 0.5),pt.bg=alpha(ppi$cols,0.75), ncol=1,bty='n')
#add delta K
text(x=-1.02,y=0.7,srt=90,labels = expression(Delta~italic(K)==""))
dev.off()
```

![Figure 2. Population Structure](fwsw_results/combinedStructure.jpeg)

## Figure 3

I don't need to re-calculate pairwise Jost's D, and Fsts using the P4 (or "subset") dataset, so I can just read in those files. But I do need to run Treemix and PopTree2.

### Treemix

To run treemix, I follow the following steps:

1. Fit tree without migration
2. Add migration edges using `-m`.
3. Use f3 and f4 ancestry estimation to approximate the amount of admixture and compare to treemix.
4. Use f4 statistics to understand poor fits.

All of these require setting a root, which is FLPB based on previous trees.

First, I need to create a file in the correct format, which uses the vcf file: 

```{r nameTreemix}
treemix.name<-"treemix/p4_treemix"
treemix.prefix<-"treemix/p4_"
poporder.file<-"treemix/poporder"
fst.tree.name<-as.character("ALLfst_cov_heatmap.png")
```
```{r generateTreemix, eval=TRUE}
```

Then, in unix, I need to run `gzip -c treemix/p4_treemix > treemix/p4_treemix.gz`. Now I can run `scripts/run_treemix.sh`, which implements steps 1 and 2, and which I need to run in Ubuntu. *Note that there are a lot of "no counts" warnings from treemix. Also, that it runs very quickly*

After that, I can evaluate the different outcomes.

```{r TreemixSetup,eval=TRUE}
```
```{r FLPBoutgroup, results="hide",fig.keep="high",eval=TRUE}
```

Population pairs that are 'too far apart' on the tree (have high error estimates) are ones that are likely candidates for gene flow - and these are the squares with dark greens, blues, and black. These are LAFW-TXFW and ALFW-TXFW in almost all of the SE graphs

```{r FLPBmigration, results="hide",fig.keep="high",eval=TRUE}
```

Look at the p-values: do migration events always improve the fit of the data?

```{r FLPBpvals,eval=TRUE}
```

All of the added migration edges improve the fit. Evaluating both the residual and migration edge plots, we can see that four migration edges reduces the error between LAFW & TXFW and ALFW & TXFW. The largest SE is between FLFW (FLLG) and itself, and secondarily between LAFW and itself. This means that those branches are surprisingly long, which I am comfortable accepting. The strongest migration edge, between the branch from the Atlantic Florida to Gulf Florida populations -> FLAB, is unsurprising because that is an intermediate location between the Atlantic and Gulf coasts. In some of the structure analyses it clusters with the Gulf coast and in others it is its own admixed group - supporting the tree structure here.

The other migration events are somewhat more surprising. We will evaluate those using the three and four population analyses.

#### Evaluating migration edges

First, let's read in the three and four population analysis results. These tested all possible three- and four-population tree groups to see whether they pass a test of 'treeness'. If not, their p-value will be small, and they don't form a nice tree.

```{r f3f4,eval=TRUE}
f3.name<-"treemix/p4_threepop.txt"
f4.name<-"treemix/p4_fourpop.txt"

#extract the relevant lines
extract.fs<-function(filename,pat="^[A-Z]{4};"){
  f<-readLines(filename)
  fmatch<-f[grep(pat,f)]
  f<-read.table(text=fmatch)
  colnames(f)<-c("pops","f","SE","Z")
  return(f)
}
f3<-extract.fs(f3.name)
f4<-extract.fs(f4.name,pat="^[A-Z]{4},")

#add p-values
f3$p<-pnorm(f3$Z)
f4$p<-pnorm(f4$Z)

```

Now we can investigate the migration edges added to the trees. 

##### Atlantic/Gulf->FLAB

This least surprising migration edge would be expected to show a signature of admixture. I'll check the treeness of FLHB;FLSI,FLAB and FLHB,FLCC;FLSI,FLAB. For comparison, I can look at FLHB;FLSI,FLFD and FLHB,FLCC;FLSI,FLFD

```{r FL,eval=TRUE}
checks3<-c("FLHB;FLSI,FLAB","FLHB;FLFD,FLSI")
f3[f3$pops %in% checks3,]
checks4<-c("FLSI,FLAB;FLHB,FLCC","FLFD,FLSI;FLHB,FLCC")
f4[f4$pops %in% checks4,]
```
They pass the three-population tests but not the four-population tests. 

##### TXFW->TXCB

To investigate this migration edge, I need to evaluate whether a [TXFW[TXCB,TXCC]] or [TXFW[TXCB,TXSP]] topology is an appropriate tree. 

```{r TX_f3,eval=TRUE}
checks<-c("TXFW;TXCC,TXCB",
          "TXFW;TXSP,TXCB")
f3[f3$pops %in% checks,]
```

Neither of these fail the treeness test, so TXFW is essentially functioning as an effective outgroup/more ancestral population. Let's check if a four population tree also makes sense.

```{r TX_f4,eval=TRUE}
f4[f4$pops %in% "TXSP,TXCC;TXFW,TXCB",]
```

This also passes the treeness test - so this isn't an actual admixture event, more of demonstrating shared ancestry.

##### TXFW->LAFW/ALFW

This migration edge would suggest a three-population structure of [TXFW[ALFW,LAFW]] or a four-population structure of [TXFW,TXCB[LAFW,ALFW]] or [TXFW,ALST[LAFW,ALFW]]
```{r TXFW_ALLAFW,eval=TRUE}

checks<-c("TXFW,TXCB;LAFW,ALFW",
          "TXFW,ALST;LAFW,ALFW")#to get the correct order of populations I had to
                                #use grep and manually try a few different ones
f4[f4$pops %in% checks,]
f3[f3$pops == "TXFW;LAFW,ALFW",]

```

The three-population test does not fail the treeness test but the four-population tests do fail the treeness tests. This suggests that TXFW functions as an outgroup to the LAFW and ALFW - they are perhaps derived from the TXFW population rather than experiencing current admixture.

##### FLFW->TX/AL

FLLG is actually FLFW, and there's a migration edge from it to the Alabama/Louisiana clade and the Texas clade. So, we can test FLLG;ALST,TXFW, FLLG;ALFW,TXCB, FLLG;ALFW,TXFW or FLLG;ALST,TXCC - see if the migration is specifically to freshwater populations or not.

```{r FLFW_f3,eval=TRUE}
checks<-c("FLLG;TXFW,ALST","FLLG;TXCB,ALFW","FLLG;TXCB,LAFW",#mix of freshwater
          "FLLG;TXFW,ALFW","FLLG;TXFW,LAFW",                 #all freshwater
          "FLLG;TXCC,ALST")                                  #no freshwater
f3[f3$pops %in% checks,]
```
These all pass the treeness test.

#### Plot the chosen tree

```{r treemix_define,eval=TRUE}
treemix.file<-as.character("treemix/p4_k100bFLPBr.cov.gz")
tm.vertices<-"treemix/p4_k100bFLPBrm4.vertices.gz"
tm.plot<-"treemix/p4_treemix_m4_FLPB.png"
tm.tree<-"treemix/p4_k100bFLPBrm4"
```
```{r TreemixFavorite, echo=FALSE,results="hide",fig.keep="high",eval=TRUE}
```

### PopTree2

For the PopTree2 analysis, I need to convert the vcf file to genepop format. I did this using PGDSpider2. Then I ran PopTree2 on Windows10, using Da to calculate neighbor-joining trees and using 1000 bootstrap replicates.

Or, if that doesn't work,
```{r RemoveMissingData,results="hide"}
```
```{r poptree_names,results="hide"}
gpop.name<-"poptree/p4.genepop"
sub.prefix<-"poptree/p4_"
vcf<-remove.missing.data(vcf, pop.list)
```
```{r CreatePoptreeSubsets, eval=FALSE}
```


And then run poptree. Poptree ran on the full dataset as well as the subsets of 1000 SNPs. Did they all provide similar results? What does the consensus tree look like?

```{r poptree_prefix, eval=TRUE}
poptree.dir<-"poptree/"
poptree.prefix<-"p4"
poptree.png<-"p4.poptree.png"
```
```{r AnalyzePoptree, eval=TRUE}
```
![All Trees](fwsw_results/poptree/p4.png)

Based on this, I'm going to move forward just with the full dataset (which includes bootstrap values).
```{r GetPtsubtree}
```
```{r poptree_prelimplot,eval=TRUE,echo=FALSE}
#do this to test which branches are which using the colors below
plot.phylo(pt.subtree)
```
```{r poptree_definecols,eval=TRUE}
clcolr <- rep("black", dim(pt.subtree$edge)[1])
clcolr[c(6,19,20,21,22)]<-all.colors[3]
```
```{r PlotFullPoptreeSubset, eval=TRUE}
```

![PopTree](fwsw_results/p4.poptree.png)

### Make Fig 3.

To get the Poptree distance matrix, I copied and pasted the distance matrix in the `p4.out` file into a new file and saved it as `p4.distance.out`. I had to first save each part of the matrix as text files, open them in Excel to standardize the spacings, merge them, and then save them.

```{r fig3_setup,eval=TRUE}
pt.dist<-as.matrix(read.table("poptree/p4.distance.out",header=T,row.names=1,sep='\t'))
jostpw<-as.matrix(read.table("Subset.JostsD.tsv",header=T,sep='\t'))
pwise.fst.raw<-read.table("stacks/fwsw_fst_summary_subset.txt",header=T,row.names=1,sep='\t')#p4_fst_summary.txt
pwise.fst<-matrix(nrow=length(pop.list),ncol=length(pop.list))
dimnames(pwise.fst)[[1]]<-dimnames(pwise.fst)[[2]]<-pop.list
for(pop1 in 1:length(pop.list)){
  for(pop2 in 1:length(pop.list)){
    if(pop1 != pop2){
      raws<-c(pwise.fst.raw[pop.list[pop1],pop.list[pop2]],pwise.fst.raw[pop.list[pop2],pop.list[pop1]])
      pwise.fst[pop.list[pop1],pop.list[pop2]]<-raws[!is.na(raws)]
    }
  }
}
dimnames(pwise.fst)[[1]]<-dimnames(pwise.fst)[[2]]<-pop.labs
pwise.fst[lower.tri(pwise.fst)]<-NA
heatmaps.name<-"p4.heatmap.png"
```
```{r HeatmapCols,eval=TRUE}
```
```{r treemix,eval=FALSE}
```
```{r Fig3Setup,eval=TRUE}
```
```{r PlotHeatmaps,eval=FALSE}
```
![Figure 3. Heatmap](fwsw_results/p4.heatmap.png)

## Figure 4

Figure 4 is the Poptree2 and Treemix trees next to each other

```{r tree_files,eval=TRUE}
plotName<-"p4.trees.png"
tm.tree<-"treemix/p4_k100bFLPBrm4"
pt.subtree<-read.tree("poptree/p4.nwk")
rect.start<-0.1
clcolr <- rep("grey27", dim(pt.subtree$edge)[1])
clcolr[c(6,19,20,21,22)]<-all.colors[3]
```
```{r plotTreemixPoptree,eval=TRUE}
```
![Figure 4. Trees](fwsw_results/p4.trees.png)

## Figure 5

I need to re-run `populations` because I don't seem to have the correct fst files. I can use the whitelist and hopefully include bootstrapping and kernel smoothing: 

`populations -b 2 -W fwsw_results/subset.whitelist.txt -P fwsw_results/stacks -M fwsw_pops_map.txt --fstats --vcf_haplotypes --genomic --bootstrap -k `

And then I will identify the shared outliers among them. But first, let's define some names.

```{r reset_vcf}
vcf<-parse.vcf("p4.upd.vcf")
```
```{r vcfSetup, echo=TRUE}
```

```{r define_fig5_names}
dd.plot.name<-as.character("separate_delta-divergence.png")
dd.name<-as.character("sep.deltadivergence.txt")
sdd.name<-as.character("sep.smoothedDD.out.txt")
afs.plot.name<-as.character("p4.All_AFS.png")
stacks.sig.out<-"p4.stacks.sig.snps.txt"
annotations.name<-"p4.StacksFWSWOutliers_annotatedByGenome.csv"
bf.file<-"bayenv/p4.bf.txt"
fwsw.tx<-read.delim("stacks/p4.fst_TXCC-TXFW.txt")
fwsw.la<-read.delim("stacks/p4.fst_ALST-LAFW.txt")
fwsw.al<-read.delim("stacks/p4.fst_ALFW-ALST.txt")
fwsw.fl<-read.delim("stacks/p4.fst_FLCC-FLLG.txt")

```
```{r StacksFsts,eval=FALSE}
```
```{r read_stacksig,echo=FALSE}
stacks.sig<-read.delim(stacks.sig.out,header=T)
```
```{r compare2ScovelliGenome,eval=FALSE}
```
```{r read_compare}
fw.sig.reg<-read.csv(annotations.name)
```

There are `r nrow(stacks.sig)` shared SNPs using the Fisher's P as a cutoff.

The bayes factors and Fsts are all in the following chunk.

```{r Fig5Files}
```

Figure 5 includes Fst data, Bayes Factors data, colors from Structure, and reciprocal monophyly data, plus smoothed Fst values (which I think I will leave out this round).


#### Plot Fig. 5


Now I'm ready to plot Figure 5.

```{r}
fig5.name<-"p4_stacks_fsts_fwsw_bf.png"
addLines<-FALSE
addSmooth<-TRUE
```
```{r plottingFunctions,echo=FALSE}
```
```{r Fig5dataSetup}
```
```{r FstBayenvPlot}
```

![Figure 5. Fsts](fwsw_results/p4_stacks_fsts_fwsw_bf.png)

There seems to be an overabundance of shared outliers on LG4. I can test this using the multinomial distribution. 
```{r overrep_chrom}
if(!("stacks.sig" %in% ls())){
  stacks.sig<-read.delim("p4.stacks.sig.snps.txt")
} 
if(is.null(stacks.sig$SNP)){ #make sure the SNP column is there.
  stacks.sig$SNP<-paste(stacks.sig$Chr,as.numeric(stacks.sig$BP)+1,sep=".")
}
sig.chrom<-stacks.sig[stacks.sig$Chr %in% lgs,]
sig.chrom$Chr<-factor(sig.chrom$Chr)
nloci<-nrow(sig.chrom)
nchrom<-length(lgs)
exp.perchrom<-rep(nloci/length(lgs),length(lgs))
names(exp.perchrom)<-lgs
exp.perchrom
obs.perchrom<-tapply(sig.chrom$Locus.ID,sig.chrom$Chr,length)[lgs]
names(obs.perchrom)<-lgs
obs.perchrom[is.na(obs.perchrom)]<-0
obs.perchrom
dmultinom(x = obs.perchrom,prob = exp.perchrom)
```


I can also look for overlapping loci in pairwise saltwater-saltwater comparisons.

```{r swsw_name}
swsw.name<-"p4_stacks_swsw.png"
swsw.tx<-read.delim("stacks/p4.fst_TXCB-TXCC.txt")
swsw.al<-read.delim("stacks/p4.fst_ALST-FLSG.txt")
swsw.fl<-read.delim("stacks/p4.fst_FLCC-FLHB.txt")
```
```{r SWSWneighbors}
```
![SWSW Fsts](fwsw_results/p4_stacks_swsw.png)

## Diversity statistics

In Figure 6, we show different measures of diversity: nucleotide diversity ($\pi$), heterozygosity (*H*), Jost's D, and $\delta$-divergence. Additionally, we include the shared Fst outliers and putative loci, and highlight regions with high $\pi$ and *H*.

### Allele Frequency Spectrum
```{r calcAFS,eval=FALSE,results="hide"}
```
```{r plotAFS, echo=FALSE,eval=FALSE}
```

![Figure S1. Fsts](fwsw_results/p4.All_AFS.png)

### Pi
```{r pi_setup}
pi.file.name<-"p4.pi.txt"
avgpi.file.name<-"p4.avgpi.txt"
```
```{r calc_pi,eval=FALSE}
all.pi<-data.frame(Chrom=vcf$`#CHROM`,Pos=vcf$POS,Pi=unlist(apply(vcf,1,calc.pi)))
all.pi$SNP<-paste(all.pi$Chrom,as.numeric(as.character(all.pi$Pos)),sep=".")
write.table(all.pi,pi.file.name,col.names = TRUE,row.names=FALSE, quote=FALSE,sep='\t')

```
```{r pi_readin}
all.pi<-read.table(pi.file.name,header=T)
avg.pi.adj<-read.table(avgpi.file.name,header=T)
```

### Heterozygosity
```{r het_names}
all.het.name<-"p4.avg.het.txt"
avg.het.adj.name<-"p4.avg.het.adj.txt"
```
```{r het,eval=FALSE}
all.het<-data.frame(Chrom=vcf$`#CHROM`,Pos=vcf$POS,Het=unlist(apply(vcf,1,calc.het)))
all.het$SNP<-paste(all.het$Chrom,as.numeric(as.character(all.het$Pos)),sep=".")
write.table(all.het,all.het.name,sep='\t',col.names=TRUE)
```
```{r read_het}
avg.het.adj<-read.delim(avg.het.adj.name,header=TRUE)
all.het<-read.delim(all.het.name,header=TRUE)
```



### delta-divergence
```{r setupDeltaD,eval=FALSE}
```
```{r readDeltaD, echo=FALSE}
dd.plot.name<-as.character("separate_delta-divergence.png")
dd.name<-as.character("sep.deltadivergence.txt")
sdd.name<-as.character("sep.smoothedDD.out.txt")
deltad<-read.delim(dd.name, header=TRUE)
```
```{r PlotDeltaD,results="hide",eval=FALSE,echo=FALSE}
```
```{r read_deltad,echo=FALSE}
dd<-read.delim(dd.name)
sdd.out<-read.delim(sdd.name)
```

This plotting function also generates the smoothed $\delta$-divergence values (which are not saved) and identifies the outliers (in 99% and 1% quantiles, and which are saved in `sdd.out`).

### Jost's D

First, I must calculate Jost's D on each locus in the p4 dataset
```{r JostD, eval=FALSE}
sub.genind<-read.structure("stacks/subset.structure.stru",n.ind=698,
                           n.loc=9638,col.lab=1,col.pop=2,sep='\t',
                           row.marknames = 2,onerowperind=FALSE,ask=FALSE)
sub.genind@pop<-factor(gsub("sample_(\\w{4}).*","\\1",rownames(sub.genind@tab)))
jostd<-D_Jost(sub.genind) 
write.table(jostd$per.locus,"p4.jostd.perlocus.txt",sep='\t',col.names=FALSE,row.names = TRUE,quote=F)
```
Now this is done, so I don't need to evaluate it again -- I'll just need to read it in from a file when I want to use it.
```{r getJostsD, echo=FALSE}
jostd.name<-"p4.jostd.perlocus.txt"
```
```{r readJostD}
```

### Smooth the statistics


```{r smooth_name}
smoothed.name<-"p4_deltad_pi_het.png"
#assign the plotting positions relative to all loci
stacks.sig<-assign.plotpos(stacks.sig,plot.scaffs = plot.scaffs,bounds=bounds,df.chrom="Chr",df.bp="BP")
dd<-assign.plotpos(deltad,plot.scaffs = plot.scaffs,bounds=bounds,df.chrom="Chrom",df.bp="Pos") 
pi<-assign.plotpos(all.pi,plot.scaffs = plot.scaffs,bounds=bounds,df.chrom="Chrom",df.bp="Pos") 
ht<-assign.plotpos(all.het,plot.scaffs = plot.scaffs,bounds=bounds,df.chrom="Chrom",df.bp="Pos") 
jd<-assign.plotpos(jostd,plot.scaffs = plot.scaffs,bounds=bounds,df.chrom="Chr",df.bp="POS") 
colnames(jd)<-c("locid","D","SNP","Pos","Chrom","ID","plot.pos") #standardize the names

smooth.per.chrom<-function(df,lgs,df.chrom,df.bp,df.stat,out.name,...){#span=0.1,degree=2
  smooth.all<-data.frame(stringsAsFactors = FALSE) #all smoothed values
  smooth.low<-data.frame(stringsAsFactors = FALSE) #lower outliers
  smooth.upp<-data.frame(stringsAsFactors = FALSE) #upper outliers
  for(i in 1:length(lgs)){
    this.chrom<-df[df[,df.chrom] %in% lgs[i],]
    this.smooth<-loess.smooth(this.chrom[,df.bp],this.chrom[,df.stat],...) 
    this.smooth<-data.frame(chr=cbind(rep(as.character(lgs[i]),length(this.smooth$x)),
                                  pos=as.numeric(this.smooth$x),
                                  smoothed.stats=as.numeric(this.smooth$y)),stringsAsFactors = FALSE)
    this.upp<-this.chrom[this.chrom[df.stat]>=quantile(this.chrom[,df.stat],0.99),]#choosing the upper outliers
    this.low<-this.chrom[this.chrom[,df.stat]<=quantile(this.chrom[,df.stat],0.01),]#choosing the lower outliers
                   
    # save the data
    smooth.all<-data.frame(rbind(smooth.all,this.smooth))
    smooth.low<-rbind(smooth.low,this.low)
    smooth.upp<-rbind(smooth.upp,this.upp)
  }
   
  smooth.upp$direction<-"upper" 
  smooth.low$direction<-"lower"
  smooth.out<-rbind(smooth.low,smooth.upp) # put the outliers in one df
  colnames(smooth.all)<-c("chr","pos","smoothed.stats")
  smooth.all$pos<-as.numeric(as.character(smooth.all$pos))
  smooth.all$smoothed.stats<-as.numeric(as.character(smooth.all$smoothed.stats))
  # save to files
  write.table(smooth.out,paste(out.name,"outliers.txt",sep=""),col.names=T,row.names=F,quote=F,sep='\t')
  write.table(smooth.all,paste(out.name,"smoothed.txt",sep=""),col.names=T,row.names=F,quote=F,sep='\t')
  smoothed<-list(smooth.out,smooth.all)
}

#smooth the statistics
dd.bp.smooth<-smooth.per.chrom(dd,lgs,df.chrom="Chrom",df.bp="Pos",df.stat="deltad",out.name="dd.bp",span=.1,degree=2) 
pi.bp.smooth<-smooth.per.chrom(pi,lgs,df.chrom="Chrom",df.bp="Pos",df.stat="Pi",out.name="pi.bp",span=0.1,degree=2) 
ht.bp.smooth<-smooth.per.chrom(ht,lgs,df.chrom="Chrom",df.bp="Pos",df.stat="Het",out.name="ht.bp",span=0.1,degree=2)
jd.bp.smooth<-smooth.per.chrom(jd,lgs,df.chrom="Chrom",df.bp="Pos",df.stat="D",out.name="jd.bp",span=0.1,degree=2)
#smooth the statistics
dd.pp.smooth<-smooth.per.chrom(dd,lgs,df.chrom="Chrom",df.bp="plot.pos",df.stat="deltad",out.name="dd",span=0.1,degree=2)
pi.pp.smooth<-smooth.per.chrom(pi,lgs,df.chrom="Chrom",df.bp="plot.pos",df.stat="Pi",out.name="pi",span=0.1,degree=2) 
ht.pp.smooth<-smooth.per.chrom(ht,lgs,df.chrom="Chrom",df.bp="plot.pos",df.stat="Het",out.name="ht",span=0.1,degree=2) 
jd.pp.smooth<-smooth.per.chrom(jd,lgs,df.chrom="Chrom",df.bp="plot.pos",df.stat="D",out.name="jd",span=0.1,degree=2) 

```
```{r plot_smoothStats,eval=FALSE}
comp.col<-c(Het="#80cdc1",pi="#018571",Fst="black",D="#a6611a",deltad="#dfc27d")
plot.smooth.stats<-function(df,smooth,stat.name,color,ylabel,...){
  dd<-fst.plot(fst.dat = df,...)
  mtext(ylabel,2,line=1.5,cex=0.75)
  points(x=as.numeric(as.character(smooth[[2]]$pos)),
         y=as.numeric(as.character(smooth[[2]]$smoothed.stats)),col=color,type="l",lwd=2)
  points(x=as.numeric(smooth[[2]]$pos),y=as.numeric(smooth[[2]]$smoothed.stats),col=color,type="l",lwd=2)
  points(smooth[[1]]$plot.pos[smooth[[1]]$direction=="upper"],smooth[[1]][smooth[[1]]$direction=="upper",stat.name],
         pch=24,bg=color,col=color,cex=0.5) #add  outliers
  points(smooth[[1]]$plot.pos[smooth[[1]]$direction=="lower"],smooth[[1]][smooth[[1]]$direction=="lower",stat.name],
         pch=25,bg=color,col=color,cex=0.5)
}
xlab.lgs<-function(df,lgs,lgn,chr,bp,...){
  last<-0
  for(i in 1:length(lgs)){
    text(x=median(df[df[,chr] ==lgs[i],bp]),labels=lgn[i],...)
    last<-max(df[df[,chr]  ==lgs[i],bp])
  }
}
png(smoothed.name,height=7,width=5,units="in",res=300)
par(mfrow=c(4,1),mar=c(1,1,1,1),oma=c(1,2,1,1),cex=0.75)
t<-plot.smooth.stats(df=dd,smooth=dd.pp.smooth,stat.name="deltad",
                     color=comp.col["deltad"],fst.name="deltad",bp.name="Pos",
                  ylabel=expression(paste(delta,"-divergence")),y.lim=c(-0.5,1),
                  axis=0.75,scaffold.widths=scaff.starts,pch=19,scaffs.to.plot = scaffs)
xlab.lgs(dd,lgs,lgn,"Chrom","plot.pos",adj=1, xpd=TRUE,y=-0.5,cex=0.75)
#plot Jost's D
d<-plot.smooth.stats(df=jd,smooth=jd.pp.smooth,stat.name="D",
                     color=comp.col["D"],fst.name="D",chrom.name = "Chrom",bp.name="Pos",
                  ylabel=expression("Jost's"~italic(D)),
                  axis=0.75,scaffold.widths=scaff.starts,pch=19,scaffs.to.plot = scaffs)
xlab.lgs(jd,lgs,lgn,"Chrom","plot.pos",adj=1, xpd=TRUE,y=-0.075,cex=0.75)
#plot pi
p<-plot.smooth.stats(df=pi,smooth=pi.pp.smooth,stat.name="Pi",
                     color=comp.col["pi"],fst.name="Pi",chrom.name = "Chrom",bp.name="Pos",
                  ylabel=expression(pi),y.lim=c(0,0.5),
                  axis=0.75,scaffold.widths=scaff.starts,pch=19,scaffs.to.plot = scaffs)
xlab.lgs(pi,lgs,lgn,"Chrom","plot.pos",adj=1, xpd=TRUE,y=-0.05,cex=0.75)
#abline(v=stacks.sig$plot.pos,col="grey10") #stacks
#plot heterozygosity
h<-plot.smooth.stats(df=ht,smooth=ht.pp.smooth,stat.name="Het",
                     color=comp.col["Het"],fst.name="Het",chrom.name = "Chrom",bp.name="Pos",
                  ylabel=expression(italic(H)),
                  axis=0.75,scaffold.widths=scaff.starts,pch=19,scaffs.to.plot = scaffs)
xlab.lgs(ht,lgs,lgn,"Chrom","plot.pos",adj=1, xpd=TRUE,y=-0.05,cex=0.75)



dev.off()
```
![Figure x. Smoothed variables](fwsw_results/p4_deltad_pi_het.png)

```{r list_of_outliers}
bf$SNP<-paste(bf$scaffold,as.numeric(as.character(bf$BP))+1,sep=".")
bf.co<-apply(bf[,5:7],2,quantile,0.99) #focus on Bayes Factors, because of Lotterhos & Whitlock (2015)
sal.bf.sig<-bf[bf$Salinity_BF>bf.co["Salinity_BF"],c(1,2,4,8,6,9)]
all.out<-data.frame(rbind(cbind(paste(fw.sig.reg$Chr,fw.sig.reg$BP,sep="."),"fst"),
                          cbind(dd.bp.smooth[[1]]$SNP,"deltad"),
                          cbind(ht.bp.smooth[[1]]$SNP,"het"),
                          cbind(jd.bp.smooth[[1]]$SNP,"jostd"),
                          cbind(pi.bp.smooth[[1]]$SNP,"pi"),
                          cbind(sal.bf.sig$SNP,"bayenv_salinity")),stringsAsFactors = FALSE)
colnames(all.out)<-c("SNP","test")
write.table(all.out,"all_outliers.txt",sep='\t',quote=FALSE,col.names=TRUE,row.names=FALSE)

```

## Use putative genes

Here, I compare the Fst outliers and $\delta$-divergence outliers to putative genes identified from other studies of teleosts adapting to freshwater environments.
```{r ld_putgenes}
#putative genes
put.genes<-read.delim("putative_genes.txt",header=TRUE,sep='\t')
#ld info
ld<-read.delim("p4.ld_info_fwsw.txt")

gff.name<-"ssc_2016_12_20_chromlevel.gff.gz"
```
```{r gff,eval=FALSE}
#genome annotations
if(length(grep("gz",gff.name))>0){
  gff<-read.delim(gzfile(paste("../../scovelli_genome/",gff.name,sep="")),header=F)
} else{
  gff<-read.delim(paste("../../scovelli_genome/",gff.name,sep=""),header=F)
}
colnames(gff)<-c("seqname","source","feature","start","end","score","strand","frame","attribute")
genome.blast<-read.csv("../../scovelli_genome/ssc_2016_12_20_cds_nr_blast_results.csv",skip=1,header=T)#I saved it as a csv
```

### Define some functions

These are updated from **fwsw_analysis.R** and are specific to *these* analyses, and are not generalizable!
```{r functions}
ssc.fwsw.fstsig<-function(tx, la, al, fl, cutoff)
{
  tx.sig<-tx[tx$Fisher.s.P<cutoff,"Locus.ID"]
  la.sig<-la[la$Fisher.s.P<cutoff,"Locus.ID"]
  al.sig<-al[al$Fisher.s.P<cutoff,"Locus.ID"]
  fl.sig<-fl[fl$Fisher.s.P<cutoff,"Locus.ID"]
  length(tx.sig[(tx.sig %in% c(la.sig,al.sig,fl.sig))])
  length(la.sig[(la.sig %in% c(tx.sig,al.sig,fl.sig))])
  length(al.sig[(al.sig %in% c(la.sig,tx.sig,fl.sig))])
  all.shared<-fl.sig[fl.sig %in% la.sig & fl.sig %in% al.sig & fl.sig %in% tx.sig]
  fw.shared.chr<-fwsw.tx[fwsw.tx$Locus.ID %in% all.shared,c("Locus.ID","Chr","BP","Column","Overall.Pi")]
  tapply(fw.shared.chr$Locus.ID,factor(fw.shared.chr$Chr),function(x){ length(unique(x)) })
  #are they using the same SNPs or different SNPs?
  stacks.sig<-data.frame(nrow=nrow(fw.shared.chr),ncol=4)
  for(i in 1:nrow(fw.shared.chr)){
    tx.bp<-fwsw.tx[tx$Fisher.s.P<cutoff & tx$Locus.ID == fw.shared.chr[i,"Locus.ID"],"BP"]
    la.bp<-fwsw.la[la$Fisher.s.P<cutoff & la$Locus.ID == fw.shared.chr[i,"Locus.ID"],"BP"]
    al.bp<-fwsw.al[al$Fisher.s.P<cutoff & al$Locus.ID == fw.shared.chr[i,"Locus.ID"],"BP"]
    fl.bp<-fwsw.fl[fl$Fisher.s.P<cutoff & fl$Locus.ID == fw.shared.chr[i,"Locus.ID"],"BP"]
    stacks.sig[i,1]<-paste(tx.bp,sep=",",collapse = ",")
    stacks.sig[i,2]<-paste(la.bp,sep=",",collapse = ",")
    stacks.sig[i,3]<-paste(al.bp,sep=",",collapse = ",")
    stacks.sig[i,4]<-paste(fl.bp,sep=",",collapse = ",")
  }
  colnames(stacks.sig)<-c("TX","LA","AL","FL")
  stacks.sig<-data.frame(cbind(fw.shared.chr,stacks.sig))
  stacks.sig$SNP<-paste(stacks.sig$Chr,stacks.sig$BP,sep=".")
  return(stacks.sig)
}

#' extract the significant regions from the gff file
sig.region.ann<-function(fw.shared.chr,gff,genome.blast)
{
  fw.sig.reg<-do.call(rbind,apply(fw.shared.chr,1,function(sig){
    this.gff<-gff[as.character(gff$seqname) %in% as.character(unlist(sig["Chr"])),]
    this.reg<-this.gff[this.gff$start <= as.numeric(sig["BP"]) & this.gff$end >= as.numeric(sig["BP"]),]
    if(nrow(this.reg) == 0){
      if(as.numeric(sig["BP"])>max(as.numeric(this.gff$end))){
        new<-data.frame(Locus=sig["Locus.ID"],Chr=sig["Chr"],BP=sig["BP"],SNPCol=sig["Column"],
                        region="beyond.last.contig", description=NA,SSCID=NA)
      }else{
        new<-data.frame(Locus=sig["Locus.ID"],Chr=sig["Chr"],BP=sig["BP"],SNPCol=sig["Column"],
                        region=NA,description=NA,SSCID=NA)
      }
    }else{
      if(length(grep("SSCG\\d+",this.reg$attribute))>0){
        geneID<-unique(gsub(".*(SSCG\\d+).*","\\1",this.reg$attribute[grep("SSCG\\d+",this.reg$attribute)]))
        gene<-genome.blast[genome.blast$sscv4_gene_ID %in% geneID,"blastp_hit_description"]
      }else{
        geneID<-NA
        gene<-NA
      }
      new<-data.frame(Locus=sig["Locus.ID"],Chr=sig["Chr"],BP=sig["BP"],SNPCol=sig["Column"],
                      region=paste(this.reg$feature,sep=",",collapse = ","),description=gene,SSCID=geneID)
    }
    return(as.data.frame(new))
  }))
}
```

### Combine putative genes and genomic info

```{r putative_regions, eval=FALSE}
#' extract the significant regions from the gff file
put.reg<-do.call(rbind,apply(put.genes,1,function(gene){
  ssc.gene<-as.character(gene[[6]])
  #there might be multiple matches
  ssc.genes<-unlist(strsplit(ssc.gene,","))
  #for each gene, match to gff
  gene.info<-do.call(rbind,lapply(ssc.genes,function(genename){
    this.gff<-gff[grep(genename,gff$attribute),]
    chrom<-unique(as.character(this.gff$seqname))
    start<-min(this.gff$start)
    stop<-max(this.gff$end)
    return(c(chrom,start,stop))
  }))
  if(as.character(gene[[3]]) == "") { gene[[3]]<-NA }
  new<-data.frame(Gene=rep(gene[[1]],length(gene.info[,1])),
                  Function=rep(gene[[2]],length(gene.info[,1])),
                  Chromsome=rep(gene[[3]],length(gene.info[,1])),
                  Species=rep(gene[[4]],length(gene.info[,1])),
                  Citation=rep(gene[[5]],length(gene.info[,1])),
                  Scovelli_geneID=rep(gene[[6]],length(gene.info[,1])),
                  Notes=rep(gene[[7]],length(gene.info[,1])),
                  Chrom=gene.info[,1],StartBP=gene.info[,2],StopBP=gene.info[,3],
                  stringsAsFactors = FALSE)
  return(as.data.frame(new))
}))
write.table(put.reg,"putative.gene.regions.tsv",col.names=T,sep='\t')

```
```{r read_putative,echo=FALSE}
put.reg<-read.delim("putative.gene.regions.tsv",header=T)
```
Note that some genes will have multiple rows as they match multiple locations in the genome.

### Do the putative genes contain RAD loci?
```{r rad_putative}
put.reg$rad.loci<-apply(put.reg,1,function(gene){
  rad<-vcf[vcf$`#CHROM` %in% gene[["Chrom"]] & 
           vcf$POS >= as.numeric(as.character(gene[["StartBP"]])) & 
           vcf$POS <= as.numeric(as.character(gene[["StopBP"]])),]  
  if(nrow(rad)>0){ rad.snps<-paste(rad$SNP,sep=",",collapse=",") }
  else { rad.snps<-NA }
  return(rad.snps)
})
```
```{r, echo=FALSE}
#and how many of the genes have RAD loci?
counts<-tapply(put.reg$rad.loci,put.reg$Gene,function(gene){
  cnt<-length(gene[!is.na(gene)])
})
```

About `r length(counts[counts>0])/length(counts)*100`% of the putative genes have RAD loci within them - but only about `r nrow(put.reg[!is.na(put.reg$rad.loci),])/nrow(put.reg)*100`% of all of the annotations have RAD loci.



### Compare the Stacks outliers with putative genes

#### What is the maximum distance of loci in LD?

$D'$ was calculated using a custom C++ program (found at https://github.com/spflanagan/SCA/tree/master/programs/pairwise_ld_vcf) using the formula:

$$D' = \sum_{i=1}^m\sum_{j=1}^n \frac{p_iq_j|D_{ij}|}{D_{max}},$$
where $m$ is the number of alleles at locus and $n$ is the number of alleles at locus B. $D_{ij}$ was calculated as $f_{ij}-p_iq_j$, where $f_{ij}$ is the frequency of the $A_iB_j$ haplotype, $p_i$ is the frequency of allele $i$, and $q_j$ is the frequency of allele $j$. $D_{max}$ is the lesser of $p_iq_j$ or $(1-p_i)(1-q_j)$ when $D_{ij}$ < 0 and is the minimum of (1 - $p_{i}$)$q_{i}$ or $p_i(1-q_i)$ when $D_{ij}$ > 0.

In the data.frame `ld`, the locus IDs (`LocIDA` and `LocIDB`) are the positions on the chromosome.

```{r ld}
ld$pos.diff<-abs(ld$LocIDA - ld$LocIDB)
chrom.ld<-tapply(ld[ld$D.>0.5,"pos.diff"],ld[ld$D. >0.5,"Chrom"],mean)
```

#### Functions for comparison

```{r comp_functions}
#' Find outliers in a putative gene region
outlier.in.region<-function(outlier.df, region.df, oChrom="Chrom", oBP="BP",
                            rChrom="Chrom",rBPStart="StartBP",rBPStop="StopBP"){
  out.in<-apply(region.df,1,function(put.gene){
    oin<-outlier.df[outlier.df[[oChrom]] %in% put.gene[[rChrom]] 
      & outlier.df[[oBP]] >= as.numeric(as.character(put.gene[[rBPStart]]))
      & outlier.df[[oBP]] <= as.numeric(as.character(put.gene[[rBPStop]])),"SNP"]
    if(length(oin)==0){ oin<-NA }
    return(paste(oin,sep=",",collapse=","))
  })
  return(out.in)
}
outlier.nearby<-function(outlier.df,region.df,ld.df,
                         oChrom="Chrom", oBP="BP",
                         rChrom="Chrom",rBPStart="StartBP",rBPStop="StopBP"){
  out.nearby<-apply(region.df,1,function(put.gene){
    nearby<-outlier.df[outlier.df[[oChrom]] %in% put.gene[[rChrom]] 
      & outlier.df[[oBP]] >= (as.numeric(as.character(put.gene[[rBPStart]])) - (ld.df[put.gene[[rChrom]] ]))
      & outlier.df[[oBP]] <= (as.numeric(as.character(put.gene[[rBPStop]])) + (ld.df[put.gene[[rChrom]] ])),"SNP"]
    if(length(nearby)==0){ nearby<-NA }
    return(paste(nearby,sep=",",collapse=","))
  })
}



```

#### Prep regions for plotting

```{r fst_plot_prep}

#' Get the plotting positions for the putative genes
all.chr<-data.frame(Chr=vcf$`#CHROM`,BP=vcf$POS,stringsAsFactors = F)
bounds<-data.frame(levels(as.factor(all.chr$Chr)),tapply(as.numeric(as.character(all.chr$BP)),all.chr$Chr,max))
colnames(bounds)<-c("Chrom","End")
plot.scaffs<-scaffs[scaffs %in% bounds$Chrom]

#convert put.reg to the plotting BP
new.dat<-data.frame(stringsAsFactors = F)
last.max<-0
for(i in 1:length(plot.scaffs)){
  #pull out the data for this scaffold
  if(nrow(bounds[bounds$Chrom %in% plot.scaffs[i],])>0){ #sanity check
    chrom.dat<-put.reg[put.reg$Chrom %in% plot.scaffs[i],]
    if(nrow(chrom.dat)>0){
      chrom.dat$plot.min<-as.numeric(as.character(chrom.dat$StartBP))+last.max
      chrom.dat$plot.max<-as.numeric(as.character(chrom.dat$StopBP))+last.max
      new.dat<-rbind(new.dat,chrom.dat)
      #last.max<-max(chrom.dat$plot.pos)+
      #               as.numeric(scaffold.widths[scaffold.widths[,1] %in% scaffs.to.plot[i],2])
    }
    last.max<-last.max+
      as.numeric(bounds[bounds$Chrom %in% plot.scaffs[i],2])
  }else{
    print(paste(plot.scaffs[i], "has no designated width."))
  }
}
#make sure everything is the correct class
new.dat$plot.min<-as.numeric(as.character(new.dat$plot.min))
new.dat$plot.max<-as.numeric(as.character(new.dat$plot.max))
```

#### Plot the Fsts 

```{r fst_plot, echo=FALSE,results='hide', message=F,fig.cap="Outlined points are Stacks shared outliers. Black bars are putative genes",fig.keep='none'}
tx.sig<-fwsw.tx[fwsw.tx$Fisher.s.P<0.01,"Locus.ID"]
la.sig<-fwsw.la[fwsw.la$Fisher.s.P<0.01,"Locus.ID"]
al.sig<-fwsw.al[fwsw.al$Fisher.s.P<0.01,"Locus.ID"]
fl.sig<-fwsw.fl[fwsw.fl$Fisher.s.P<0.01,"Locus.ID"]
length(tx.sig[(tx.sig %in% c(la.sig,al.sig,fl.sig))])
length(la.sig[(la.sig %in% c(tx.sig,al.sig,fl.sig))])
length(al.sig[(al.sig %in% c(la.sig,tx.sig,fl.sig))])
all.shared<-fl.sig[fl.sig %in% la.sig & fl.sig %in% al.sig & fl.sig %in% tx.sig]

par(mfrow=c(4,1),mar=c(0.85,2,0,0.5),oma=c(1,1,1,0.5))
fwswt.fst<-fst.plot(fwsw.tx,fst.name = "Corrected.AMOVA.Fst", bp.name = "BP",chrom.name = "Chr", 
                    scaffs.to.plot=plot.scaffs, scaffold.widths = bounds,pch=19,y.lim = c(0,1),
                    pt.cols = c(grp.colors[1],grp.colors[2]),pt.cex=1,axis.size = 1)
apply(new.dat,1,function(dat){
  arrows(x0=as.numeric(dat[["plot.min"]]),x1=as.numeric(dat[["plot.max"]]),y0=0.9,y1=0.9,length=0,lwd=10)
})
points(fwswt.fst$plot.pos[fwswt.fst$Locus.ID %in% all.shared],fwswt.fst$Corrected.AMOVA.Fst[fwswt.fst$Locus.ID %in% all.shared],
       pch=1,col="black",cex=1.3)
mtext("TXFW vs. TXCC",3,cex=0.75,line=-1)
fwswl.fst<-fst.plot(fwsw.la,fst.name = "Corrected.AMOVA.Fst", bp.name = "BP",chrom.name = "Chr", 
                    scaffs.to.plot=plot.scaffs, scaffold.widths = bounds,pch=19,y.lim = c(0,1),
                    pt.cols=c(grp.colors[2],grp.colors[3]),pt.cex=1,axis.size=1)
apply(new.dat,1,function(dat){
  arrows(x0=as.numeric(dat[["plot.min"]]),x1=as.numeric(dat[["plot.max"]]),y0=0.9,y1=0.9,length=0,lwd=10)
})
points(fwswl.fst$plot.pos[fwswl.fst$Locus.ID %in% all.shared],fwswl.fst$Corrected.AMOVA.Fst[fwswl.fst$Locus.ID %in% all.shared],
       pch=1,col="black",cex=1.3)
mtext("LAFW vs. ALST",3,cex=0.75,line=-1)
fwswa.fst<-fst.plot(fwsw.al,fst.name = "Corrected.AMOVA.Fst", bp.name = "BP",chrom.name = "Chr", 
                    scaffs.to.plot=plot.scaffs, scaffold.widths = bounds,pch=19,y.lim = c(0,1),
                    pt.cols=c(grp.colors[3],grp.colors[2]),pt.cex=1,axis.size = 1)
apply(new.dat,1,function(dat){
  arrows(x0=as.numeric(dat[["plot.min"]]),x1=as.numeric(dat[["plot.max"]]),y0=0.9,y1=0.9,length=0,lwd=10)
})
points(fwswa.fst$plot.pos[fwswa.fst$Locus.ID %in% all.shared],fwswa.fst$Corrected.AMOVA.Fst[fwswa.fst$Locus.ID %in% all.shared],
       pch=1,col="black",cex=1.3)
mtext("ALFW vs. ALST",3,cex=0.75,line=-1)
fwswf.fst<-fst.plot(fwsw.fl,fst.name = "Corrected.AMOVA.Fst", bp.name = "BP",chrom.name = "Chr", 
                    scaffs.to.plot=plot.scaffs, scaffold.widths =  bounds,pch=19,y.lim = c(0,1),
                    pt.cols=c(grp.colors[6],grp.colors[5]),pt.cex=1,axis.size=1)
apply(new.dat,1,function(dat){
  arrows(x0=as.numeric(dat[["plot.min"]]),x1=as.numeric(dat[["plot.max"]]),y0=0.9,y1=0.9,length=0,lwd=10)
})
points(fwswf.fst$plot.pos[fwswf.fst$Locus.ID %in% all.shared],fwswf.fst$Corrected.AMOVA.Fst[fwswf.fst$Locus.ID %in% all.shared],
       pch=1,col="black",cex=1.3)
mtext("FLFW vs. FLCC",3,cex=0.75,line=-1)
mtext(expression(italic(F)[ST]),2,outer=T,line=-0.8,cex=0.75)
last<-0
for(i in 1:length(lgs)){
  text(x=mean(fwswf.fst[fwswf.fst$Chr ==lgs[i],"plot.pos"]),y=-0.05,
       labels=lgn[i], adj=1, xpd=TRUE)
  last<-max(fwswf.fst[fwswf.fst$Chr ==lgs[i],"plot.pos"])
}
```

### FST outliers in putative gene regions

```{r fst_compare}
fw.sig.reg<-read.csv("p4.StacksFWSWOutliers_annotatedByGenome.csv")
all.put.ssc<-as.character(put.reg$Scovelli_geneID)
all.put.ssc<-unlist(lapply(all.put.ssc,strsplit,","))
sig.put.match<-all.put.ssc[all.put.ssc %in% fw.sig.reg$SSCID]

#or use the functions
fw.sig.reg$SNP<-paste(fw.sig.reg$Chr,as.character(fw.sig.reg$BP),sep=".")
stacks.in<-outlier.in.region(fw.sig.reg,put.reg,oChrom="Chr")
put.reg$fst.in<-as.character(stacks.in)
```

Of the `r nrow(fw.sig.reg)` shared outlier SNPs, `r nrow(fw.sig.reg[!is.na(fw.sig.reg$SSCID),])` are in coding regions of the genome. However, `r length(stacks.in[stacks.in!="NA"])` shared outliers are in putative gene regions, namely `r put.reg[put.reg$fst.in !="NA","Gene"]`

No, they don't overlap. Maybe they're in the same LD region?

```{r fst_nearby}

put.nearby.rad<-outlier.nearby(fw.sig.reg,put.reg,chrom.ld,oChrom = "Chr")

#add the nearby significant rad loci to the put.reg data.frame
put.reg$nearby.rad<-put.nearby.rad
head(put.reg[put.reg$nearby.rad!="NA",])

```
So of the `r nrow(put.reg)` gene annotations `r length(put.nearby.rad[put.nearby.rad!="NA"])` are within the mean LD range of an outlier, which represent `r length(unique(put.reg[put.reg$nearby.rad!="NA","Gene"]))` putative freshwater genes. Those genes are: `r unique(put.reg[put.reg$nearby.rad!="NA","Gene"])[order(unique(put.reg[put.reg$nearby.rad!="NA","Gene"]))]`

### Compare $\delta$ -divergence to putative regions

Now for $\delta$ -divergence

```{r dd_compare}
#in the gene
sdd.in<-outlier.in.region(dd.bp.smooth[[1]],put.reg,oBP = "Pos")
put.reg$sdd.in<-sdd.in
```

The genes `r unique(put.reg[put.reg$sdd.in!="NA","Gene"])` contain $\delta$-divergence outlier regions.

```{r dd_nearby}
#in the gene
sdd.nb<-outlier.nearby(dd.bp.smooth[[1]],put.reg,chrom.ld,oBP = "Pos")
put.reg$sdd.nb<-sdd.nb
```

And of the `r nrow(dd.bp.smooth[[1]])` $\delta$-divergence outliers, `r length(sdd.nb[sdd.nb!="NA"])/nrow(put.reg)*100`% are in the LD region around putative freshwater genes.


### Compare Bayenv outliers to putative regions

```{r bayenv}
#taken directly from fwsw_analysis.R
bf<-read.delim("bayenv/p4.bf.txt",header=T)
bf$SNP<-paste(bf$scaffold,as.numeric(as.character(bf$BP))+1,sep=".")
bf.co<-apply(bf[,5:7],2,quantile,0.99) #focus on Bayes Factors, because of Lotterhos & Whitlock (2015)
temp.bf.sig<-bf[bf$Temp_BF>bf.co["Temp_BF"],c(1,2,4,8,5,9)]
sal.bf.sig<-bf[bf$Salinity_BF>bf.co["Salinity_BF"],c(1,2,4,8,6,9)]
grass.bf.sig<-bf[bf$seagrass_BF>bf.co["seagrass_BF"],c(1,2,4,8,7,9)]
#get the log transformed Bayes Factors
bf$logSal<-log(bf$Salinity_BF)
bf$logTemp<-log(bf$Temp_BF)
bf$logSeagrass<-log(bf$seagrass_BF)

```

There are `r nrow(temp.bf.sig[temp.bf.sig$locus %in% sal.bf.sig$locus & temp.bf.sig$locus %in% grass.bf.sig,])` overlapping outliers between temperature-, salinity-, and seagrass-associated loci.

But if we only care about salinity ones, there are `r nrow(temp.bf.sig)` outliers.

**Are any of the Bayenv salinity outliers near the putative freshwater genes?**

```{r bayenv_sal}

bfs.in<-outlier.in.region(sal.bf.sig,put.reg,"scaffold")
bfs.nb<-outlier.nearby(sal.bf.sig,put.reg,chrom.ld,"scaffold")
```
Of the `r nrow(bf)` RAD loci analyzed by *Bayenv2* for associations with temperature, `r length(bfs.in[bfs.in!="NA"])/nrow(put.reg)*100`% are in putative freshwater genes and `r length(bfs.nb[bfs.nb!="NA"])/nrow(put.reg)*100`% are within the LD neighborhood.


**Are any of the Bayenv temperature outliers near putative freshwater genes?**

```{r bayenv_temp}

bft.in<-outlier.in.region(temp.bf.sig,put.reg,"scaffold")
bft.nb<-outlier.nearby(temp.bf.sig,put.reg,chrom.ld,"scaffold")
```

Of the `r nrow(bf)` RAD loci analyzed by *Bayenv2* for associations with temperature, `r length(bft.in[bft.in!="NA"])/nrow(put.reg)*100`% are in putative freshwater genes and `r length(bft.nb[bft.nb!="NA"])/nrow(put.reg)*100`% are within the LD neighborhood.

**Are any of the loci associated with seagrass density in or near putative freshwater genes?**

```{r bayenv_grass}

bfg.in<-outlier.in.region(grass.bf.sig,put.reg,"scaffold")
bfg.nb<-outlier.nearby(grass.bf.sig,put.reg,chrom.ld,"scaffold")
```

Of the `r nrow(bf)` RAD loci analyzed by *Bayenv2* for associations with temperature, `r length(bfg.in[bfg.in!="NA"])/nrow(put.reg)*100`% are in putative freshwater genes and `r length(bfg.nb[bfg.nb!="NA"])/nrow(put.reg)*100`% are within the LD neighborhood.

#### Which putative genes contain each of those?

```{r bayenv_genes}
put.reg$bfs.in<-bfs.in
put.reg$bft.in<-bft.in
put.reg$bfg.in<-bfg.in

unique(put.reg[put.reg$bfs.in !="NA","Gene"])
unique(put.reg[put.reg$bft.in !="NA","Gene"])
unique(put.reg[put.reg$bfg.in !="NA","Gene"])
```


All three BayEnv tests identified outliers in the genes `r unique(put.reg[put.reg$bfs.in !="NA","Gene"])[unique(put.reg[put.reg$bfs.in !="NA","Gene"]) %in% unique(put.reg[put.reg$bft.in !="NA","Gene"]) & unique(put.reg[put.reg$bfs.in !="NA","Gene"]) %in% unique(put.reg[put.reg$bfg.in !="NA","Gene"])]`. The temperature and grass also share `r unique(put.reg[put.reg$bft.in !="NA","Gene"])[unique(put.reg[put.reg$bft.in !="NA","Gene"]) %in% unique(put.reg[put.reg$bfg.in !="NA","Gene"])][1]`, and temperature and salinity share `r unique(put.reg[put.reg$bfs.in !="NA","Gene"])[unique(put.reg[put.reg$bfs.in !="NA","Gene"]) %in% unique(put.reg[put.reg$bft.in !="NA","Gene"])][1]`. 


### Jost's D

Jost's D measures the fraction of allelic differentiation between populations. According to Molecular Ecologist, ["if allelic differentiation at a particular locus is the value of interest, it appears that D is the best measure"](http://www.molecularecologist.com/2011/03/should-i-use-fst-gst-or-d-2/), so it might be useful to look at Jost's D in the putatively freshwater genes. 

```{r josts_d}
jost.in<-outlier.in.region(jd.bp.smooth[[1]],put.reg,oChrom="Chrom",oBP="Pos")
jost.nb<-outlier.nearby(jd.bp.smooth[[1]],put.reg,chrom.ld,oChrom = "Chrom",oBP="pos")
put.reg$jostd.nb<-jost.nb
put.reg$jostd.in<-jost.in
```

So $`r length(jost.in[jost.in!="NA"])`$ loci are located within putative freshwater genes, but $`r length(jost.nb[jost.nb!="NA"])`$ are within the LD region of the putative genes, representing $`r length(jost.nb[jost.nb!="NA"])/nrow(put.reg)*100`$ of the putative gene annotations and $`r length(unique(put.reg[put.reg$jostd.nb != "NA", "Gene"]))`$ genes.

### Combining all of those analyses

```{r summary_tables}
 kable(unique(put.reg[put.reg$fst.in != "NA",c("Gene","Chrom")]),caption = "Putative genes containing Fst outliers",row.names = FALSE)
 kable(unique(put.reg[put.reg$sdd.in != "NA",c("Gene","Chrom")]),
       caption="Putative genes containing delta divergence outliers",row.names = FALSE)
 kable(unique(put.reg[put.reg$jostd.in !="NA",c("Gene","Chrom")]),
       caption="Putative genes containing Jost's D outliers",row.names = FALSE)
 kable(unique(put.reg[put.reg$bfs.in != "NA",c("Gene","Chrom")]),
       caption="Putative genes containing salinity-associated SNPs",row.names = FALSE)
 kable(unique(put.reg[put.reg$fst.in != "NA",c("Gene","Chrom")])[
                            unique(put.reg[put.reg$fst.in != "NA","Gene"]) %in% unique(put.reg[put.reg$sdd.in != "NA","Gene"])&
                              unique(put.reg[put.reg$fst.in != "NA","Gene"]) %in% unique(put.reg[put.reg$bfs.in != "NA","Gene"])],
       caption="Putative genes containing all of those outliers",row.names=FALSE)
 kable(unique(put.reg[put.reg$fst.in != "NA",c("Gene","Chrom")])[
                            unique(put.reg[put.reg$fst.in != "NA","Gene"]) %in% unique(put.reg[put.reg$sdd.in != "NA","Gene"])&
                              unique(put.reg[put.reg$fst.in != "NA","Gene"]) %in% unique(put.reg[put.reg$jostd.in != "NA","Gene"])],
       caption="Putative genes containing divergence outliers (Fst, deltad, D)",row.names = FALSE)
 kable(unique(put.reg[put.reg$nearby.rad != "NA","Gene"])[
                            unique(put.reg[put.reg$nearby.rad != "NA","Gene"]) %in% unique(put.reg[put.reg$sdd.nb != "NA","Gene"])&
                              unique(put.reg[put.reg$nearby.rad != "NA","Gene"]) %in% unique(put.reg[put.reg$jostd.in!= "NA","Gene"])],
       caption="Putative genes near divergence outliers (Fst, deltad, D)",row.names=FALSE)

```


*But looking at `put.reg[put.reg$Gene =="RHOGTP8","rad.loci"]`, it's obvious that Rho GTPase-activating proteins are distributed throughout the genome (on chromosomes `r unique(put.reg[put.reg$Gene=="RHOGTP8","Chrom"])`).*


## Figure 6

Find genomic regions with high $\pi$ and low $\delta$-divergence

```{r shared_upp}

#Do high pi and het have low deltad?
#do it per chrom
balancing.sel<-function(pi.out,pi,ht.out,ht,
                        dd.out,dd,jd.out,jd){
  pi.upp<-pi.out[pi.out$direction=="upper",]
  ht.upp<-ht.out[ht.out$direction=="upper",]
  dd.low<-dd.out[dd.out$direction=="lower",]
  jd.low<-jd.out[jd.out$direction=="lower",]
  shared.div<-pi.upp[pi.upp[,pi] %in% ht.upp[,ht],] 
  shared.dif<-dd.low[dd.low[,dd] %in% jd.low[,jd],] 
  bal<-shared.div[shared.div[,pi] %in% shared.dif[,dd]]
  return(list(div=shared.div,dif=shared.dif,bal=bal))
}

bal<-balancing.sel(pi.pp.smooth[[1]],"plot.pos",ht.pp.smooth[[1]],"plot.pos",
                   dd.pp.smooth[[1]],"plot.pos",jd.pp.smooth[[1]],"plot.pos")


shared.upp<-bal$div
```

There are loci with high $\pi$ and low $\delta$-divergence on `r length(unique(shared.upp$Chr))` chromosomes. 

Instead of the lumped marine-freshwater $F_{ST}$ values that I used originally, I'm going to plot the average of pairwise $F_{ST}$ values.

```{r avg_fsts}
fst.means<-fwsw.al
for(i in 1:nrow(fst.means)){
  if(fst.means$Locus.ID[i] %in% fwsw.fl$Locus.ID &
     fst.means$Locus.ID[i] %in% fwsw.la$Locus.ID &
     fst.means$Locus.ID[i] %in% fwsw.tx$Locus.ID){
      mu<-mean(fwsw.fl$Corrected.AMOVA.Fst[fwsw.fl$Locus.ID==fst.means$Locus.ID[i]],
               fwsw.la$Corrected.AMOVA.Fst[fwsw.la$Locus.ID==fst.means$Locus.ID[i]],
               fwsw.al$Corrected.AMOVA.Fst[fwsw.al$Locus.ID==fst.means$Locus.ID[i]],
               fwsw.tx$Corrected.AMOVA.Fst[fwsw.tx$Locus.ID==fst.means$Locus.ID[i]])
      fst.means$Corrected.AMOVA.Fst[i]<-mu
  }
  else{
    fst.means$Corrected.AMOVA.Fst[i]<-NA
  }
}
fst.means<-fst.means[!is.na(fst.means$Corrected.AMOVA.Fst),]
fwsw<-fst.means
```



```{r hPi_setup}
fst.points<-FALSE
#and putative genes
put.genes<-read.delim("putative_genes.txt",header=TRUE,sep='\t')
#genome annotations
#put.reg<-read.delim("putative.gene.regions.tsv",header=T)
chrom.ld<-tapply(ld[ld$D.>0.5,"pos.diff"],ld[ld$D. >0.5,"Chrom"],mean)
#select genes of interest
#fav.genes<-c("AQP3","TNS1","CAMKK1","mucin","CAII","NAKATPase","ARHGEF3")
#fav.genes<-c("TNS1","CAII","TRIM14","VATPase")
fav.genes<-c("ARHGEF3", "mucin", "NHE", "TAAR")
genes2plot<-put.reg[put.reg$Gene %in% fav.genes,]
genes2plot$Gene<-as.character(genes2plot$Gene)
genes2plot$Gene[genes2plot$Gene=="ARHGEF3"]<-"ARHGEF" #rename
#shift LG3 names
genes2plot$StartBP[genes2plot$Chrom=="LG3" & genes2plot$Gene=="ARHGEF"]<-
  genes2plot$StartBP[genes2plot$Chrom=="LG3" & genes2plot$Gene=="ARHGEF"]+200000
genes2plot$StartBP[genes2plot$Chrom=="LG3" & genes2plot$Gene=="mucin"]<-
  genes2plot$StartBP[genes2plot$Chrom=="LG3" & genes2plot$Gene=="mucin"]-100000
#shift LG7 names
genes2plot$StartBP[genes2plot$Chrom=="LG7" & genes2plot$Gene=="ARHGEF"]<-
  genes2plot$StartBP[genes2plot$Chrom=="LG7" & genes2plot$Gene=="ARHGEF"]+200000
genes2plot$StartBP[genes2plot$Chrom=="LG7" & genes2plot$Gene=="NHE"]<-
  genes2plot$StartBP[genes2plot$Chrom=="LG7" & genes2plot$Gene=="NHE"]-200000
#shift LG14 names
genes2plot$StartBP[genes2plot$Chrom=="LG14" & genes2plot$Gene=="ARHGEF"]<-
  genes2plot$StartBP[genes2plot$Chrom=="LG14" & genes2plot$Gene=="ARHGEF"]+550000
genes2plot$StartBP[genes2plot$Chrom=="LG14" & genes2plot$Gene=="NHE"]<-
  genes2plot$StartBP[genes2plot$Chrom=="LG14" & genes2plot$Gene=="NHE"]-600000
#get rid of the final ARHGEF
genes2plot<-genes2plot[-which(genes2plot$Chrom=="LG14" & genes2plot$Gene=="ARHGEF" & genes2plot$StartBP>23022883),]

#shared Fst outliers
fw.sig.reg<-read.csv("p4.StacksFWSWOutliers_annotatedByGenome.csv")
h.pi.name<-"HandPi_subgenes.png"
row.settings<-c(4,4)
chroms2plot<-unique(shared.upp$Chr)

#generate xlims
xlims<-lapply(chroms2plot,function(lg,ld,genes,vcf){
  xs<-c(min(genes[genes$Chr == lg,"plot.pos"]-ld[lg]),
        max(genes[genes$Chr == lg,"plot.pos"]+ld[lg]))
  if(xs[1] < 0){
    xs[1]<-0
  }
  if(xs[2] > max(vcf$POS[vcf$`#CHROM`==lg])){
    xs[2]<-max(vcf$POS[vcf$`#CHROM`==lg])
  }
  return(xs)
},ld=chrom.ld,genes=shared.upp,vcf=vcf)
#or do full chroms
#generate xlims
xlims<-lapply(chroms2plot,function(lg,genes,vcf){
  xs<-c(min(vcf$POS[vcf$`#CHROM`==lg]),
        max(vcf$POS[vcf$`#CHROM`==lg]))
  return(xs)
},genes=shared.upp,vcf=vcf)
names(xlims)<-chroms2plot
HandPiName<-expression(Large~pi~and~italic(H))
includeArrows<-FALSE
```
```{r plotHandPi}
```
![Figure 6. Low $\delta$-divergence and high $\pi$](fwsw_results/HandPi_subgenes.png)

### Focus on LG8 to demonstrate the pattern
To demonstrate these patterns, let's focus on the clearest signal, on LG8. I'll do three plots, one for pi and H, one for $\delta$-divergence and Jost's D, and one with the four FWSW Fst comparisons.

```{r}
## SETUP
comp.col<-c(Het="#80cdc1",pi="#018571",Fst="black",D="#a6611a",deltad="#dfc27d")
this.chrom<-"LG8"
i<-which(chroms2plot==this.chrom) #LG8 is the second in the 'chroms2plot' list
this.df<-fwsw[fwsw$Chr %in% chroms2plot[i],]
this.xlim<-xlims[[as.character(chroms2plot[i])]]
xmin<-this.xlim[1]
xmax<-this.xlim[2]

# Find the shared peak
pos<-shared.upp$Pos[shared.upp$Chrom %in% chroms2plot[i]]
regmin<-pos-mean(ld$pos.diff[ld$Chrom==this.chrom & ld$LocIDA==pos & ld$D. > 0.5])
regmax<-pos+mean(ld$pos.diff[ld$Chrom==this.chrom & ld$LocIDA==pos & ld$D. > 0.5])


# Find the putative gene regions
g<-put.reg[put.reg$Chrom == this.chrom,c("Gene","Chrom","StartBP","StopBP")]
#remove duplicates
if(this.chrom=="LG8"){
  g<-g[g$Gene !="ATP6V1A",] 
  g<-g[-which(g$Gene=="VATPase" & g$StartBP<3000000),]
}
g<-g[!duplicated(g),]

txt.locs<-data.frame(starts=unique(g$StartBP),name=as.character(g$Gene[!duplicated(g$StartBP)]),
                     stringsAsFactors = FALSE)
txt.locs<-txt.locs[order(txt.locs$starts),]
rownames(txt.locs)<-NULL
#move the labels
if(this.chrom=="LG8"){
  txt.locs$starts[12]<-txt.locs$starts[12]+100000 #VATPase
  txt.locs$starts[10]<-txt.locs$starts[10]-100000 #MKP8
  txt.locs$starts[11]<-txt.locs$starts[11]-100000 #mucin
  txt.locs$starts[txt.locs$name=="RHOGTP8"]<-txt.locs$starts[txt.locs$name=="RHOGTP8"]+50000 #RhoGTP
  txt.locs$starts[5]<-txt.locs$starts[5]+50000 #PRL2
  
  txt.locs$starts[1]<-txt.locs$starts[1]+90000 #TRIM14
  txt.locs$starts[2]<-txt.locs$starts[2]+100000 #VATPase
  txt.locs$starts[3]<-txt.locs$starts[3]+100000 #PRL1
  #rename
  txt.locs$name[txt.locs$name=="ATP6V0A1"]<-"VATPase"
  txt.locs$name[txt.locs$name=="RHOGTP8"]<-"RhoGTP"
}

```
```{r}
## PLOT
png(paste(this.chrom,"_balancingsel.png",sep=""),height=6,width=10,units="in",res=300)
par(mfrow=c(3,1),oma=c(2,2,2,1),mar=c(1,2,1.5,2),xpd=TRUE)
# Empty plot for H and pi
plot(this.df$BP,this.df$Corrected.AMOVA.Fst, xlim=this.xlim,ylim=c(0,0.5),axes=F,ylab="",xlab="",type='n')
# Add the shared peak
points(y=c(0,0.5),x=c(pos,pos),type="l",col=alpha("#543005",0.75),cex=2,lwd=4)
rect(regmin,0,regmax,0.5,col=alpha("#543005",0.15),border=NA) #LD region
# Add the putative gene regions
rect(xleft=as.numeric(g$StartBP),xright=as.numeric(g$StopBP),
     ybottom=0,ytop=0.5,col="indianred",border="indianred")
# Add Pi
points(pi.bp.smooth[[2]][pi.bp.smooth[[2]][,"chr"]%in% chroms2plot[i],c("pos","smoothed.stats")],
     type="l",lwd=2,col=comp.col["pi"])
#upp.low.pts(smooth=pi.bp.smooth[[1]],target=pi.bp.smooth[[2]],chrom=chroms2plot[i],
#            color=comp.col["pi"],stat="Pi",pos.name="Pos")
# Add Het
points(ht.bp.smooth[[2]][ht.bp.smooth[[2]][,"chr"]%in% chroms2plot[i],c("pos","smoothed.stats")],
       type="l",col=comp.col["Het"],lwd=2)
#upp.low.pts(smooth=ht.bp.smooth[[1]],target=ht.bp.smooth[[2]],chrom=chroms2plot[i],
#            color=comp.col["Het"],stat="Het",pos.name="Pos")  
# Add putative gene name
#text(x=txt.locs$starts[4:12],y=c(0.25,rep(0.35,3),rep(0.25,5)),
#     cex=2,labels=txt.locs$name[4:12],srt=90,xpd=T,font=2)
#text(x=txt.locs$starts[1:3],y=c(0.43,0.3,0.05),cex=2,labels=txt.locs$name[1:3],xpd=T,font=2,pos=2)
# axes etc
axis(1,pos=0,c(xmin,xmax),labels = FALSE)
axis(2,las=1,cex.axis=2,pos=xmin,at=c(0,0.25,0.5))
legend(0,0.65,legend=c(expression(italic(H)),expression(pi)),
       bty='n',lwd=c(2,2),lty=c(1,1),xpd=TRUE,ncol=2,
       cex = 2,col=c(comp.col["Het"],comp.col["pi"]),x.intersp = 0.2)

# Empty plot for D and delta-divergence
plot(this.df$BP,this.df$Corrected.AMOVA.Fst, xlim=this.xlim,ylim=c(-0.1,0.2),axes=F,ylab="",xlab="",type='n')
# Add the shared peak
points(y=c(-0.1,0.2),x=c(pos,pos),type="l",col=alpha("#543005",0.75),cex=2,lwd=4)
rect(regmin,-0.1,regmax,0.2,col=alpha("#543005",0.15),border=NA) #LD region
# Add the putative gene regions
rect(xleft=as.numeric(g$StartBP),xright=as.numeric(g$StopBP),
     ybottom=-0.1,ytop=0.2,col="indianred",border="indianred")
# Add deltad
points(dd.bp.smooth[[2]][dd.bp.smooth[[2]][,"chr"]%in% chroms2plot[i],c("pos","smoothed.stats")],
       type="l",col=comp.col["deltad"],lwd=2)
#upp.low.pts(smooth=dd.bp.smooth[[1]],dd.bp.smooth[[2]],chrom=chroms2plot[i],
#            color=comp.col["deltad"],stat="deltad",pos.name="Pos")
# Add Josts D
points(jd.bp.smooth[[2]][jd.bp.smooth[[2]][,"chr"]%in% chroms2plot[i],c("pos","smoothed.stats")],
       type="l",col=comp.col["D"],lwd=2)
#upp.low.pts(smooth=jd.bp.smooth[[1]],jd.bp.smooth[[2]],chrom=chroms2plot[i],
#            color=comp.col["D"],stat="D",pos.name="Pos")
# axes etc
axis(1,pos=-0.1,c(xmin,xmax),labels = FALSE)
axis(2,las=1,cex.axis=2,pos=xmin,at=c(-0.1,0.05,0.2))
legend(0,0.28,legend=c(expression("Jost's"~italic(D)),expression(delta~-divergence)),
       bty='n',lwd=c(2,2),lty=c(1,1),xpd=TRUE,ncol=2,x.intersp = 0.2,text.width = 1000000,
       cex = 2,col=c(comp.col["D"],comp.col["deltad"]))

# Empty plot for Fsts
plot(this.df$BP,this.df$Corrected.AMOVA.Fst, xlim=this.xlim,ylim=c(0,0.5),axes=F,ylab="",xlab="",type='n')
# Add the shared peak
points(y=c(0,0.5),x=c(pos,pos),type="l",col=alpha("#543005",0.75),cex=2,lwd=4)
rect(regmin,0,regmax,0.5,col=alpha("#543005",0.15),border=NA) #LD region
# Add the putative gene regions
rect(xleft=as.numeric(g$StartBP),xright=as.numeric(g$StopBP),
     ybottom=0,ytop=0.5,col="indianred",border="indianred")
# Add Fsts
points(fwsw.fl$BP[fwsw.fl$Chr==this.chrom],fwsw.fl$Smoothed.AMOVA.Fst[fwsw.fl$Chr==this.chrom],
       type="l",col=grp.colors[6],lwd=2)
points(fwsw.tx$BP[fwsw.tx$Chr==this.chrom],fwsw.tx$Smoothed.AMOVA.Fst[fwsw.tx$Chr==this.chrom],
       type="l",col=grp.colors[1],lwd=2)
points(fwsw.la$BP[fwsw.la$Chr==this.chrom],fwsw.la$Smoothed.AMOVA.Fst[fwsw.la$Chr==this.chrom],
       type="l",col=grp.colors[2],lwd=2)
points(fwsw.al$BP[fwsw.al$Chr==this.chrom],fwsw.al$Smoothed.AMOVA.Fst[fwsw.al$Chr==this.chrom],
       type="l",col=grp.colors[2],lwd=2,lty=2)
# Add putative gene name
if(this.chrom=="LG8"){
  text(x=txt.locs$starts[4:12],y=c(0.25,rep(0.35,7),0.25),
      cex=2,labels=txt.locs$name[4:12],srt=90,xpd=T,font=2)

  text(x=txt.locs$starts[1:3],y=c(0.43,0.3,0.15),cex=2,labels=txt.locs$name[1:3],xpd=T,font=2,pos=2)
}else{
  text(x=txt.locs$starts,y=rep(0.25,length(txt.locs$starts)),
      cex=2,labels=txt.locs$name,srt=90,xpd=T,font=2)
}
# axes etc
axis(1,pos=0,c(xmin,xmax),
   labels = c(round((xmin/1000000),2),round((xmax/1000000),2)),cex.axis=2)
axis(2,las=1,cex.axis=2,pos=xmin,at=c(0,0.25,0.5))
legend(0,0.65,legend=c(expression("TX FWSW"~italic(F)[ST]),
                          expression("LA FWSW"~italic(F)[ST]),
                          expression("AL FWSW"~italic(F)[ST]),
                          expression("FL FWSW"~italic(F)[ST])),
       bty='n',lwd=2,lty=c(1,1,2,1),ncol=4,xpd=TRUE,
       cex = 2,col=c(grp.colors[1],grp.colors[2],grp.colors[2],grp.colors[6]),
       x.intersp = 0.2)

# Add x-axis label
mtext(paste("Position on",this.chrom,"(Mb)"),1,cex=2*0.75,line=1)

dev.off()
```
```{r, echo=FALSE}
## PLOT
png("LG8_balancingsel_nogenes.png",height=6,width=10,units="in",res=300)
par(mfrow=c(3,1),oma=c(2,2,2,1),mar=c(1,2,1.5,2),xpd=TRUE)
# Empty plot for H and pi
plot(this.df$BP,this.df$Corrected.AMOVA.Fst, xlim=this.xlim,ylim=c(0,0.5),axes=F,ylab="",xlab="",type='n')
# Add the shared peak
points(y=c(0,0.5),x=c(pos,pos),type="l",col=alpha("#543005",0.75),cex=2,lwd=4)
rect(regmin,0,regmax,0.5,col=alpha("#543005",0.15),border=NA) #LD region
# Add Pi
points(pi.bp.smooth[[2]][pi.bp.smooth[[2]][,"chr"]%in% chroms2plot[i],c("pos","smoothed.stats")],
     type="l",lwd=2,col=comp.col["pi"])
upp.low.pts(smooth=pi.bp.smooth[[1]],target=pi.bp.smooth[[2]],chrom=chroms2plot[i],
            color=comp.col["pi"],stat="Pi",pos.name="Pos")
# Add Het
points(ht.bp.smooth[[2]][ht.bp.smooth[[2]][,"chr"]%in% chroms2plot[i],c("pos","smoothed.stats")],
       type="l",col=comp.col["Het"],lwd=2)
upp.low.pts(smooth=ht.bp.smooth[[1]],target=ht.bp.smooth[[2]],chrom=chroms2plot[i],
            color=comp.col["Het"],stat="Het",pos.name="Pos")  
# axes etc
axis(1,pos=0,c(xmin,xmax),labels = FALSE)
axis(2,las=1,cex.axis=2,pos=xmin,at=c(0,0.25,0.5))
legend(0,0.65,legend=c(expression(italic(H)),expression(pi)),
       bty='n',lwd=c(2,2),lty=c(1,1),xpd=TRUE,ncol=2,
       cex = 2,col=c(comp.col["Het"],comp.col["pi"]),x.intersp = 0.2)

# Empty plot for D and delta-divergence
plot(this.df$BP,this.df$Corrected.AMOVA.Fst, xlim=this.xlim,ylim=c(-0.1,0.2),axes=F,ylab="",xlab="",type='n')
# Add the shared peak
points(y=c(-0.1,0.2),x=c(pos,pos),type="l",col=alpha("#543005",0.75),cex=2,lwd=4)
rect(regmin,-0.1,regmax,0.2,col=alpha("#543005",0.15),border=NA) #LD region
# Add deltad
points(dd.bp.smooth[[2]][dd.bp.smooth[[2]][,"chr"]%in% chroms2plot[i],c("pos","smoothed.stats")],
       type="l",col=comp.col["deltad"],lwd=2)
upp.low.pts(smooth=dd.bp.smooth[[1]],dd.bp.smooth[[2]],chrom=chroms2plot[i],
            color=comp.col["deltad"],stat="deltad",pos.name="Pos")
# Add Josts D
points(jd.bp.smooth[[2]][jd.bp.smooth[[2]][,"chr"]%in% chroms2plot[i],c("pos","smoothed.stats")],
       type="l",col=comp.col["D"],lwd=2)
upp.low.pts(smooth=jd.bp.smooth[[1]],jd.bp.smooth[[2]],chrom=chroms2plot[i],
            color=comp.col["D"],stat="D",pos.name="Pos")
# axes etc
axis(1,pos=-0.1,c(xmin,xmax),labels = FALSE)
axis(2,las=1,cex.axis=2,pos=xmin,at=c(-0.1,0.05,0.2))
legend(0,0.4,legend=c(expression("Jost's"~italic(D)),expression(delta~-divergence)),
       bty='n',lwd=c(2,2),lty=c(1,1),xpd=TRUE,ncol=2,x.intersp = 0.2,text.width = 1000000,
       cex = 2,col=c(comp.col["D"],comp.col["deltad"]))


# Empty plot for Fsts
plot(this.df$BP,this.df$Corrected.AMOVA.Fst, xlim=this.xlim,ylim=c(0,0.5),axes=F,ylab="",xlab="",type='n')
# Add the shared peak
points(y=c(0,0.5),x=c(pos,pos),type="l",col=alpha("#543005",0.75),cex=2,lwd=4)
rect(regmin,0,regmax,0.5,col=alpha("#543005",0.15),border=NA) #LD region
# Add Fsts
points(fwsw.fl$BP[fwsw.fl$Chr=="LG8"],fwsw.fl$Smoothed.AMOVA.Fst[fwsw.fl$Chr=="LG8"],
       type="l",col=grp.colors[6],lwd=2)
points(fwsw.tx$BP[fwsw.tx$Chr=="LG8"],fwsw.tx$Smoothed.AMOVA.Fst[fwsw.tx$Chr=="LG8"],
       type="l",col=grp.colors[1],lwd=2)
points(fwsw.la$BP[fwsw.la$Chr=="LG8"],fwsw.la$Smoothed.AMOVA.Fst[fwsw.la$Chr=="LG8"],
       type="l",col=grp.colors[2],lwd=2)
points(fwsw.al$BP[fwsw.al$Chr=="LG8"],fwsw.al$Smoothed.AMOVA.Fst[fwsw.al$Chr=="LG8"],
       type="l",col=grp.colors[2],lwd=2,lty=2)
# axes etc
axis(1,pos=0,c(xmin,xmax),
   labels = c(round((xmin/1000000),2),round((xmax/1000000),2)),cex.axis=2)
axis(2,las=1,cex.axis=2,pos=xmin,at=c(0,0.25,0.5))
legend(0,0.65,legend=c(expression("TX FWSW"~italic(F)[ST]),
                          expression("LA FWSW"~italic(F)[ST]),
                          expression("AL FWSW"~italic(F)[ST]),
                          expression("FL FWSW"~italic(F)[ST])),
       bty='n',lwd=2,lty=c(1,1,2,1),ncol=4,xpd=TRUE,
       cex = 2,col=c(grp.colors[1],grp.colors[2],grp.colors[2],grp.colors[6]),
       x.intersp = 0.2)

# Add x-axis label
mtext("Position on LG8 (Mb)",1,cex=2*0.75,line=1)

dev.off()
```

![Figure 6. Low $\delta$-divergence and high $\pi$](fwsw_results/LG8_balancingsel.png)

### Look for regions of reduced diversity as evidence of selective sweeps.

```{r low_diversity}
upp.pi<-NULL
low.pi<-NULL
upp.het<-NULL
low.het<-NULL
upp.dd<-NULL
low.dd<-NULL
for(i in 1:length(lgs)){
  upp.pi<-rbind(upp.pi,avg.pi.adj[avg.pi.adj$Avg.Stat >= 
                     quantile(avg.pi.adj$Avg.Stat[avg.pi.adj$Chr %in% lgs[i]],0.95) &
                     avg.pi.adj$Chr %in% lgs[i],])
  low.pi<-rbind(low.pi,avg.pi.adj[avg.pi.adj$Avg.Stat <= 
                     quantile(avg.pi.adj$Avg.Stat[avg.pi.adj$Chr %in% lgs[i]],0.05) &
                     avg.pi.adj$Chr %in% lgs[i],])

  upp.het<-rbind(upp.het,avg.het.adj[avg.het.adj$Avg.Stat >= 
                       quantile(avg.het.adj$Avg.Stat[avg.het.adj$Chr %in% lgs[i]],0.95) &
                       avg.het.adj$Chr %in% lgs[i],])
  low.het<-rbind(low.het,avg.het.adj[avg.het.adj$Avg.Stat <= 
                       quantile(avg.het.adj$Avg.Stat[avg.het.adj$Chr %in% lgs[i]],0.05) &
                       avg.het.adj$Chr %in% lgs[i],])

  
}
shared.low<-low.pi[low.pi$plot.pos %in% low.het$plot.pos,]
shared.low$plot.min<-shared.low$Avg.Pos-250000
shared.low$plot.max<-shared.low$Avg.Pos+250000

h.pi.name<-"lowdiv_subgenes.png"
row.settings<-c(4,3)
chroms2plot<-unique(shared.low$Chr)
shared.upp<-shared.low
fst.points<-FALSE
HandPiName<-expression(Low~pi~and~italic(H))
```
```{r plotHandPi}
```

![Low pi and low het](fwsw_results/lowdiv_subgenes.png)




## Test for selective sweeps

To test for selective sweeps, I'm using SweeD, which is a modified version of SweepFinder. Although it allows for multi-threading, I've found that I can highly parallelize the analysis by first calculating the genome-wide frequency spectrum from the whole vcf and then running each chromosome separately in the background on a supercomputer. So I need to make separate vcf files per chromosome, with a header line.

```{r write_vcfs_perLG,eval=FALSE}
header<-"##fileformat=VCFv4.2"
for(i in 1:length(lgs)){
  write.table(header,paste("sweed/",lgs[i],".vcf",sep=""),quote=FALSE,
              col.names=FALSE,row.names=FALSE )
  suppressWarnings(write.table(vcf[vcf$`#CHROM`==lgs[i],-708],paste("sweed/",lgs[i],".vcf",sep=""),
              col.names=TRUE,row.names=FALSE,quote=FALSE,sep='\t',append = TRUE))
}
```

Then I can run SweeD on each file, specifying the genoem-wide frequency spectrum file and a grid size of 50 - which I've done. Now I can start to make sense of the results. SweeD produces output that shows the position, likelihood, and alpha value. The likelihood value is the one we're primarily interested in, so I'll plot those genome-wide.

### Plot SweeD results

```{r sweed}
sweed.files<-list.files(path="sweed",pattern="SweeD_Report",full.names=TRUE)
sweed<-do.call(rbind,lapply(sweed.files,function(file){
  swlg<-read.delim(file,skip=2,header=TRUE)
  if(length(grep("lg",file)==TRUE)>0){ #correct lowercase chrom names
    swlg$Chrom<-paste("LG",gsub(".*lg(\\d+)$","\\1",file),sep="")
  }else if(length(grep("LG",file)==TRUE)>0){
    swlg$Chrom<-gsub(".*(LG\\d+)$","\\1",file)
  }else{
    swlg$Chrom<-file
    print("Warning: error parsing chromosome name from filename")
  }
  return(swlg)
}))

#try this
sweed.plot<-fst.plot(sweed,fst.name = "Likelihood", bp.name = "Position",chrom.name = "Chrom", 
                    scaffs.to.plot=plot.scaffs,scaffold.widths = bounds,pch=19,
                    pt.cex=1,axis.size=0)
axis(2,pos=-5000000,las=1)
labs<-tapply(sweed.plot$plot.pos,sweed.plot$Chrom,median)
text(x=labs[lgs],y=-.5,labels=lgn,xpd=TRUE)
abline(h=quantile(sweed.plot$Likelihood,0.99),lty=2,col="cornflowerblue",lwd=2)

```

There are `r nrow(sweed[sweed$Likelihood>=quantile(sweed$Likelihood,0.99),])` of `r nrow(sweed)` estimated likelihoods by SweeD that exceed the upper 1% quantile. These are distributed on `r length(summary(as.factor(sweed$Chrom[sweed$Likelihood>=quantile(sweed$Likelihood,0.99)])))` chromosomes: `r summary(as.factor(sweed$Chrom[sweed$Likelihood>=quantile(sweed$Likelihood,0.99)]))`

### Investigate nearby genes

```{r sweed_outliers}
sweed.out<-sweed[sweed$Likelihood >= quantile(sweed$Likelihood,0.99),]
#need to add a snp for these to work
sweed.out$SNP<-paste(sweed.out$Chrom,sweed.out$Position,sep=".")
sweed.in<-outlier.in.region(sweed.out,put.reg,oBP = "Position",oChrom = "Chrom")
sweed.nb<-outlier.nearby(sweed.out,put.reg,chrom.ld,oBP = "Position",oChrom="Chrom")
```

`r length(sweed.in[sweed.in!="NA"])` genes contain SweeD outliers and `r length(sweed.nb[sweed.nb!="NA"])` genes are within the LD distance of the SweeD estimators. However, this is likely because the SweeD likelihood estimates are fairly spread out. So let's plot those five chromosomes.

```{r sweed_plotprep,eval=FALSE}
chroms2plot<-unique(sweed.out$Chrom)
h.pi.name<-"sweed_perchrom.png"
row.settings<-c(3,2)
shared.upp<-sweed.out
fst.points<-FALSE
xlims<-lapply(chroms2plot,function(lg,genes,vcf){
  xs<-c(min(vcf$POS[vcf$`#CHROM`==lg]),
        max(vcf$POS[vcf$`#CHROM`==lg]))
  return(xs)
},genes=shared.upp,vcf=vcf)
names(xlims)<-chroms2plot
#these are the genes nearby
fav.genes<-c("LEPR","EFNB1","TRIM14","ATP6V0A1","WNT11","angiotensin II receptor",
             "EYA","CA","SGK3","FLT4","MSX2")
genes2plot<-put.reg[put.reg$Gene %in% fav.genes,]
genes2plot$Gene<-as.character(genes2plot$Gene)
genes2plot$Gene[genes2plot$Gene == "angiotensin II receptor"]<-"AGTR1"
## fix the locations of a couple for readability
#trim14
trim14.min<-min(put.reg$StartBP[put.reg$Gene=="TRIM14" & put.reg$Chrom=="LG10"])
trim14.max<-max(put.reg$StopBP[put.reg$Gene=="TRIM14" & put.reg$Chrom=="LG10"])
genes2plot$StartBP[put.reg$Chrom=="LG10"&put.reg$Gene=="TRIM14"]<-trim14.min
genes2plot$StopBP[put.reg$Chrom=="LG10"&put.reg$Gene=="TRIM14"]<-trim14.max



comp.col<-c(Het="#80cdc1",pi="#018571",Fst="black",D="#a6611a",deltad="#dfc27d")
HandPiName<-"SweeD outliers"
```
```{r sweed_plotPerchrom,eval=FALSE}
png("Sweed.png",height=6,width=10,res=300,units = "in")
nf <- layout(matrix(c(1,1,1,
                      2,3,4,
                      5,6,7), nrow=3, byrow=TRUE),widths=c(1,1,1),heights=c(0.75,1.25,1.25))
# genome-wide
par(oma=c(1,1,1,1),mar=c(1,2,0.5,1))
sweed.plot<-fst.plot(sweed,fst.name = "Likelihood", bp.name = "Position",chrom.name = "Chrom", 
                    scaffs.to.plot=plot.scaffs,scaffold.widths = bounds,pch=19,
                    pt.cex=1,axis.size=0,y.lim=c(0,15))
axis(2,pos=-5000000,las=1,at=c(0,15),ylim=c(0,15),cex.axis=1.5)
mtext("CLR",2,line=1.5)
labs<-tapply(sweed$plot.pos,sweed$Chrom,median)
text(x=labs[lgs],y=-1.75,labels=lgn,xpd=TRUE,cex=1.5)
abline(h=quantile(sweed.plot$Likelihood,0.99),lty=2,col="cornflowerblue",lwd=2)

# add each chrom with outliers
for(i in 1:length(chroms2plot)){
  this.df<-fwsw[fwsw$Chr %in% chroms2plot[i],]
  this.xlim<-xlims[[as.character(chroms2plot[i])]]
  plot(this.df$BP,this.df$Corrected.AMOVA.Fst, xlim=this.xlim,ylim=c(-0.2,0.5),axes=F,ylab="",xlab="",type='n')
  xmin<-this.xlim[1]#min(pi.plot$Pos[pi.plot$Chrom%in%chroms2plot[i]])
  xmax<-this.xlim[2]#max(pi.plot$Pos[pi.plot$Chrom%in%chroms2plot[i]])
  
  #the shared peaks
  p<-lapply(shared.upp$Pos[shared.upp$Chrom %in% chroms2plot[i]],
         function(pos){
           points(y=c(-0.2,0.5),x=c(pos,pos),
                  type="l",col=alpha("#f1b6da",0.75),cex=2,lwd=4)
         })
  
  points(y=rep(c(-0.2,0.5),length(shared.upp$plot.pos[shared.upp$Chrom %in% chroms2plot[i]])),
         x=c(shared.upp$plot.pos[shared.upp$Chrom %in% chroms2plot[i]],
             shared.upp$plot.pos[shared.upp$Chrom %in% chroms2plot[i]]),
         type="l",col=alpha("#f1b6da",0.75),cex=2,lwd=4)
  #putative gene regions
  g<-genes2plot[genes2plot$Chrom %in% chroms2plot[i] & 
                  genes2plot$StartBP >= xmin & genes2plot$StartBP <= xmax,]
  a<-put.reg[put.reg$Chrom %in% chroms2plot[i] & !(put.reg$Gene %in% fav.genes),]
  
  if(nrow(g) > 0){
    rect(xleft=as.numeric(g$StartBP),xright=as.numeric(g$StopBP),
       ybottom=-0.2,ytop=0.44,col="indianred",border="indianred")
  }
  
  #Fst
  if(fst.points==TRUE){
    points(this.df$BP,this.df$Corrected.AMOVA.Fst,pch=19,cex=1.5,
           col=alpha(col=comp.col["Fst"],0.25),bg=alpha(col=comp.col["Fst"],0.25))
  }
  #Pi
  points(pi.bp.smooth[[2]][pi.bp.smooth[[2]][,"chr"]%in% chroms2plot[i],c("pos","smoothed.stats")],
       type="l",lwd=2,col=comp.col["pi"])
  upp.low.pts(smooth=pi.bp.smooth[[1]],target=pi.bp.smooth[[2]],chrom=chroms2plot[i],
              color=comp.col["pi"],stat="Pi",pos.name="Pos")
  #Het
  points(ht.bp.smooth[[2]][ht.bp.smooth[[2]][,"chr"]%in% chroms2plot[i],c("pos","smoothed.stats")],
         type="l",col=comp.col["Het"],lwd=2)
  upp.low.pts(smooth=ht.bp.smooth[[1]],target=ht.bp.smooth[[2]],chrom=chroms2plot[i],
              color=comp.col["Het"],stat="Het",pos.name="Pos")
  
  #deltad
  points(dd.bp.smooth[[2]][dd.bp.smooth[[2]][,"chr"]%in% chroms2plot[i],c("pos","smoothed.stats")],
         type="l",col=comp.col["deltad"],lwd=2)
  upp.low.pts(smooth=dd.bp.smooth[[1]],dd.bp.smooth[[2]],chrom=chroms2plot[i],
              color=comp.col["deltad"],stat="deltad",pos.name="Pos")

  #Josts D
  points(jd.bp.smooth[[2]][jd.bp.smooth[[2]][,"chr"]%in% chroms2plot[i],c("pos","smoothed.stats")],
         type="l",col=comp.col["D"],lwd=2)
  upp.low.pts(smooth=jd.bp.smooth[[1]],jd.bp.smooth[[2]],chrom=chroms2plot[i],
              color=comp.col["D"],stat="D",pos.name="Pos")
  
  #shared Fst outliers
  points(this.df$BP[this.df$BP %in% fw.sig.reg$BP],
         this.df$Corrected.AMOVA.Fst[this.df$BP %in% fw.sig.reg$BP],
         pch=8,cex=2,col="orchid4",lwd=3)
  #add text for putative genes
  if(i == 1){
    txt.locs<-data.frame(starts=unique(g$StartBP),name=g$Gene[!duplicated(g$StartBP)])
    txt.locs<-txt.locs[order(txt.locs$starts),]
    txt.locs[1,"starts"]<-txt.locs[1,"starts"]-500000
    txt.locs[2,"starts"]<-txt.locs[2,"starts"]+500000
    text(x=txt.locs$starts,y=0.35,cex=1.5,labels=txt.locs$name,srt=90,xpd=T)  
  }else if(i==2){
    txt.locs<-data.frame(starts=unique(g$StartBP),name=g$Gene[!duplicated(g$StartBP)])
    txt.locs<-txt.locs[order(txt.locs$starts),]
    txt.locs[3,"starts"]<-mean(txt.locs[3:5,"starts"])
    txt.locs<-txt.locs[1:3,]
    text(x=txt.locs$starts,y=0.35,cex=1.5,labels=txt.locs$name,srt=90,xpd=T) 
  }else if(i==4){
    txt.locs<-data.frame(starts=unique(g$StartBP),name=g$Gene[!duplicated(g$StartBP)])
    txt.locs<-txt.locs[order(txt.locs$starts),]
    txt.locs[1,"starts"]<-txt.locs[1,"starts"]+75000
    text(x=txt.locs$starts[-4],y=0.35,cex=1.5,labels=txt.locs$name[-4],srt=90,xpd=T)  
    text(x=txt.locs$starts[4],y=0,cex=1.5,labels=txt.locs$name[4],srt=90,xpd=T)  
  }else{
    txt.locs<-data.frame(starts=unique(g$StartBP),name=g$Gene[!duplicated(g$StartBP)])
    txt.locs<-txt.locs[order(txt.locs$starts),]
    #txt.locs<-txt.locs[-4,]
    text(x=txt.locs$starts,y=0.35,cex=1.5,labels=txt.locs$name,srt=90,xpd=T) 
  }
  
  #axes etc
   axis(1,pos=-0.2,c(xmin,xmax),
       labels = c(round((xmin/1000000),2),round((xmax/1000000),2)),cex.axis=1.5)
  axis(2,las=1,hadj=0.75,cex.axis=1.5,pos=xmin,at=c(-0.25,0,0.25,0.5))
  mtext(chroms2plot[i],1,cex=1.5*0.75,line=1)
}

# legend
plot(0, 0, type='n', bty='n', xaxt='n', yaxt='n')
legend("topleft",xpd=TRUE,
       legend=c("Putative Gene",
                expression(Shared~italic(F)[ST]~Outlier),
                HandPiName, expression(italic(H)),
                expression(pi),
                expression("Jost's"~italic(D)),
                expression(delta~-divergence)),
       bty='n',pch=c(15,8,15,15,15,15,15),#lwd=c(2,1,4,2,2,0,2,2),lty=c(1,0,1,1,1,0,1,1),
       pt.cex = 2,cex=1.5,x.intersp = 0.5,y.intersp = 0.75,text.width=0.45,
       col=c("indianred","orchid4",alpha("#f1b6da",0.75),comp.col[1:2],comp.col[4:5]))
dev.off()
```

![SweeD Plot](fwsw_results/Sweed.png)


<!-- To look for selective sweeps, I'm going to use the FLK R code by Bonhomme et al, downloaded from https://qgsp.jouy.inra.fr/index.php?option=com_content&view=article&id=50&Itemid=55 -->

<!-- The mandatory input is a matrix of allele frequencies for each population. -->

<!-- ```{r FLK_freqs,eval=FALSE} -->
<!-- calc.allFreqs<-function(vcf,pop.list, pop.labs){ -->
<!--   allFreqs<-do.call(rbind,lapply(pop.list, function(pop){ -->
<!--     this.vcf<-cbind(vcf[,1:9],vcf$SNP,vcf[,grep(pop,colnames(vcf))]) -->
<!--     afs<-do.call(rbind,apply(this.vcf,1,calc.afs.vcf)) -->
<!--     return(afs$RefFreq) -->
<!--   })) -->
<!--   colnames(allFreqs)<-vcf$SNP -->
<!--   rownames(allFreqs)<-pop.labs -->
<!--   return(allFreqs) -->
<!-- } -->

<!-- freqs<-calc.allFreqs(remove.missing.data(vcf, pop.list),pop.list,pop.labs) -->
<!-- write.table(freqs,"flk.freqs",row.names = TRUE) -->
<!-- ``` -->
<!-- ```{r FLK,eval=FALSE} -->
<!-- source("../scripts/FLK.R") -->
<!-- library(ape); library(phangorn) -->
<!-- freqs<-read.table("flk.freqs",row.names=1) -->
<!-- ## estimate the population tree using Reynolds distances -->
<!-- ## computed on the SNP data, without specifying an outgroup -->
<!-- Fsnp<-Fij(freqs) -->

<!-- ## Now compute the FLK and LK tests -->
<!-- tests<-FLK(freqs,Fsnp)  -->

<!-- ``` -->

<!-- Then I run the `programs/FLKnull.py` program on the output to estimate the empirical null distribution. Once that has run, we use the following code provided by Bonhomme et al to plot the null distribution -->

<!-- ```{r plotNull,eval=FALSE} -->
<!-- null<-read.table('envelope.txt',head=T) -->
<!-- plot(tests$Ht,tests$F.LK,pch=19,col="gray",xlab='Heterozygosity',ylab='FLK statistic',xlim=c(0,0.5)) -->
<!-- lines(null$Ht,null$q0.005,type='l',col='navy') -->
<!-- lines(null$Ht,null$q0.995,type='l',col='navy') -->
<!-- lines(null$Ht,null$q0.025,type='l',col='navy') -->
<!-- lines(null$Ht,null$q0.975,type='l',col='navy') -->
<!-- lines(null$Ht,null$q0.5,type='l',col='navy') -->
<!-- lines(smooth.spline(null$Ht,null$q0.995)) -->
<!-- lines(smooth.spline(null$Ht,null$q0.005)) -->
<!-- lines(smooth.spline(null$Ht,null$q0.025),lty=2) -->
<!-- lines(smooth.spline(null$Ht,null$q0.975),lty=2) -->
<!-- lines(smooth.spline(null$Ht,null$q0.5),lty=3) -->
<!-- ``` -->

<!-- Use PopGenome to do the CLR method. First I need to convert my vcf file to a tabix-ed vcf file, using `bgzip p4.upd.vcf` followed by `tabix -p vcf p4.upd.vcf.gz`, and saved these in the popgenome/ directory. -->

<!-- ```{r popgenome,eval=FALSE} -->
<!-- mins<-tapply(X = vcf$POS,INDEX = vcf$`#CHROM`,min)[scaffs] -->
<!-- maxs<-tapply(X = vcf$POS,INDEX = vcf$`#CHROM`,max)[scaffs] -->
<!-- snps<-tapply(X = vcf$POS,INDEX = vcf$`#CHROM`,length)[scaffs] -->
<!-- library(PopGenome) -->
<!-- GENOME.class <- readVCF("popgenome/p4.upd.vcf.gz",numcols=snps["LG1"],tid="LG1", -->
<!--                   frompos=mins["LG1"],topos=maxs["LG1"], -->
<!--                   include.unknown = TRUE) -->
<!-- TXSP<-grep("TXSP",colnames(vcf),value = TRUE) -->
<!-- TXCC<-grep("TXCC",colnames(vcf),value = TRUE) -->
<!-- TXFW<-grep("TXFW",colnames(vcf),value = TRUE) -->
<!-- TXCB<-grep("TXCB",colnames(vcf),value = TRUE) -->
<!-- LAFW<-grep("LAFW",colnames(vcf),value = TRUE) -->
<!-- ALST<-grep("ALST",colnames(vcf),value = TRUE) -->
<!-- ALFW<-grep("ALFW",colnames(vcf),value = TRUE) -->
<!-- FLSG<-grep("FLSG",colnames(vcf),value = TRUE) -->
<!-- FLKB<-grep("FLKB",colnames(vcf),value = TRUE) -->
<!-- FLFD<-grep("FLFD",colnames(vcf),value = TRUE) -->
<!-- FLSI<-grep("FLSI",colnames(vcf),value = TRUE) -->
<!-- FLAB<-grep("FLAB",colnames(vcf),value = TRUE) -->
<!-- FLPB<-grep("FLPB",colnames(vcf),value = TRUE) -->
<!-- FLHB<-grep("FLHB",colnames(vcf),value = TRUE) -->
<!-- FLCC<-grep("FLCC",colnames(vcf),value = TRUE) -->
<!-- FLFW<-grep("FLFW",colnames(vcf),value = TRUE) -->
<!-- genvcf<-set.populations(genvcf, -->
<!--                         list(TXSP,TXCC,TXFW,TXCB,LAFW,ALST,ALFW,FLSG,FLKB,FLFD,FLSI,FLAB,FLPB,FLHB,FLCC,FLFW), -->
<!--                         diploid=TRUE) -->

<!-- ``` -->

<!-- Convert to sweepfinder2 format: -->

<!-- ```{r convert_SF2,eval=FALSE} -->
<!-- #one file for each chromosome -->
<!-- #first column is position -->
<!-- #second column is count of derived alleles -->
<!-- #third column is the total number of observed alleles -->
<!-- #fourth column indicates whether it's derived or ancestral.  -->

<!-- vcf2sfaf<-function(vcf,lgs){ -->
<!--   chrs<-lapply(lgs,function(lg){ -->
<!--     gts<-extract.gt.vcf(vcf[vcf$`#CHROM` == lg,]) -->
<!--     sf.af<-do.call(rbind,apply(gts,1,function(row){ -->
<!--       gt<-row[10:length(row)] -->
<!--       ref<-(length(gt[gt=="0/0"])*2)+ -->
<!--         length(gt[gt=="0/1"])+length(gt[gt=="1/0"]) -->
<!--       alt<-(length(gt[gt=="1/1"])*2)+ -->
<!--         length(gt[gt=="0/1"])+length(gt[gt=="1/0"]) -->
<!--       return(data.frame(position=row["POS"],x=ref,n=alt)) -->
<!--     })) -->
<!--     write.table(sf.af,paste("SF2/",lg,".AF.txt",sep=""), -->
<!--                 col.names = TRUE,row.names=FALSE,sep='\t', -->
<!--                 quote=FALSE,eol='\n') -->
<!--     print(paste("Writing to file: SF2/",lg,".AF.txt",sep="")) -->
<!--     return(sf.af) -->
<!--   }) -->
<!-- } -->
<!-- af<-vcf2sfaf(vcf,lgs) -->
<!-- ``` -->



## Figure 7


I'm highlighting a few of the putative genes that have a bunch of outliers nearby or in them. First is TNS1, which matched three genome annotations but only had one region, on LG1, that contained shared outlier Fsts, delta divergence, Bayenv salinity, were near monophyletic neighbor joining trees. 

```{r combine_fsts}
fst.dfs<-list(fwsw.tx,fwsw.la,fwsw.al,fwsw.fl)
names(fst.dfs)<-c("TX FWSW","LA FWSW","AL FWSW","FL FWSW")
colors=c(grp.colors[1],grp.colors[2],grp.colors[3],grp.colors[6])
alphas=c(0.5,0.5,1,0.5)
ltys=c(1,1,2,1)
```

### Plotting function

The plotting function `gene.region.plot` accpets a number of parameters.

```{r plotting_function}
gene.region.plot<-function(chrom,gene,put.reg,vcf,chrom.ld, fst.dfs,deltad=FALSE,D=FALSE,
                           colors="black",lwds=2,alphas=0.5,ltys=1,legend=TRUE,bases="bp", 
                           smooth=FALSE, smooth.loess=TRUE,fst.name="Corrected.AMOVA.FST",txt.cex=1,y.lim=c(0,1),...){
  pstart<-min(as.numeric(as.character(put.reg[put.reg$Gene ==gene & 
                                                     put.reg$Chrom==chrom,"StartBP"])))-(chrom.ld[chrom]/2)
  pstop<-max(as.numeric(as.character(put.reg[put.reg$Gene ==gene & 
                                                    put.reg$Chrom==chrom,"StartBP"])))+(chrom.ld[chrom]/2)
  if(pstart < 0){ pstart<- 0 }
  if(pstop > max(vcf[vcf$`#CHROM`==chrom,"POS"])){ pstop <- max(vcf[vcf$`#CHROM`==chrom,"POS"]) }
  starts<-as.numeric(put.reg[put.reg$Chrom %in% chrom & put.reg$Gene == gene,"StartBP"])
  stops<-as.numeric(put.reg[put.reg$Chrom %in% chrom & put.reg$Gene == gene,"StopBP"])
  
  if(smooth==TRUE){
    #generate the dataframes
    smooth.fsts<-lapply(fst.dfs,function(df){
      this.df<-df[df$Chr %in% chrom,]
      this.smooth<-do.call("rbind",lapply(seq(1,nrow(this.df),(nrow(this.df)*0.15)/5),sliding.avg,
                                        dat=data.frame(Pos=this.df$BP,Fst=this.df[,fst.name]),
                                        width=nrow(this.df)*0.15))
      return(this.smooth)
    })
  }  else{
    smooth.fsts<-lapply(fst.dfs,function(df){
      this.smooth<-df[df$Chr %in% chrom,c("BP",fst.name)]
    })
  }
  
  if(is.data.frame(deltad)){
    this.dd<-deltad[deltad$Chrom %in% chrom,]
    if(smooth.loess==TRUE){
      dd.smooth<-loess.smooth(this.dd$Pos,this.dd$deltad,span=0.1,degree=2)
      names(dd.smooth)<-c("pos","smoothed.stats")
    }else{
      dd.smooth<-this.dd
    }
  }else if(is.list(deltad)){
    dd.smooth<-deltad[[2]][deltad[[2]][,"chr"]%in%chrom,]
  }else{
    dd.smooth<-NULL
  }
  
  if(is.data.frame(D)){
    this.d<-D[D$Chr %in% chrom,]
    if(smooth.loess==TRUE) {
      dsmooth<-loess.smooth(this.d$POS,this.d$D,span=0.1,degree=2)
      names(dd.smooth)<-c("pos","smoothed.stats")
    }else{
      dsmooth<-this.d
    } 
  }else if(is.list(D)){
    dsmooth<-D[[2]][D[[2]][,"chr"]%in%chrom,]
  }else{
    D<-NULL
  }
  
  pr.gene<-put.reg[put.reg$Chrom==chrom & put.reg$Gene==gene,]
  fst.gene<- unlist(strsplit(gsub(paste(chrom,".",sep=""),"",pr.gene$rad.loci[pr.gene$rad.loci != "NA"]),","))
  sal.gene<- unlist(strsplit(gsub(paste(chrom,".",sep=""),"",pr.gene$bfs.in[pr.gene$bfs.in != "NA"]),","))
 # tmp.gene<- unlist(strsplit(gsub(paste(chrom,".",sep=""),"",pr.gene$bft.in[pr.gene$bft.in != "NA"]),","))
  #grs.gene<- unlist(strsplit(gsub(paste(chrom,".",sep=""),"",pr.gene$bfg.in[pr.gene$bfg.in != "NA"]),","))
  #jd.gene<-unlist(strsplit(gsub(paste(chrom,".",sep=""),"",pr.gene$jostd.nb[jostd.nb != "NA"]),","))
  sdd.gene<- unlist(strsplit(gsub(paste(chrom,".",sep=""),"",pr.gene$sdd.in[pr.gene$sdd.in != "NA"]),","))
 #nj.gene<-as.numeric(unlist(strsplit(gsub(paste(chrom,".",sep=""),"",pr.gene$nj.nb[pr.gene$nj.nb != "NA"]),",")))
  nj.gene<-NULL
  nb.gene<-as.numeric(unlist(strsplit(gsub(paste(chrom,".",sep=""),"",pr.gene$nearby.rad[pr.gene$nearby.rad != "NA"]),",")))
  gene.out<-data.frame(BP=c(as.numeric(fst.gene),as.numeric(sal.gene),as.numeric(sdd.gene)),
                       shape=c(rep(8,length(fst.gene)),rep(1,length(sal.gene)),rep(4,length(sdd.gene))))
  
  if(length(colors) != length(smooth.fsts)){
    colors<-rep(colors,length(smooth.fsts)/length(colors))
  }
  if(length(lwds) != length(smooth.fsts)){
    lwds<-rep(lwds,length(smooth.fsts)/length(lwds))
  }
  if(length(alphas) != length(smooth.fsts)){
    alphas<-rep(alphas,length(smooth.fsts)/length(alphas))
  }
  if(length(ltys) != length(smooth.fsts)){
    ltys<-rep(ltys,length(smooth.fsts)/length(ltys))
  }
  
  plot(smooth.fsts[[1]],type='n',ylim=c(y.lim[1],y.lim[2]+0.02),
       bty="L",xlab="",ylab="",xaxt='n',yaxt='n',xlim=c(pstart,pstop))
  axis(2,las=1,cex.axis=txt.cex)  
  xlabs<-c(pstart,pstop)
  if(bases %in% c("mb","MB","Mb")) xlabs<-c(round((pstart/1000000),2),round((pstop/1000000),2))
  if(bases %in% c("kb","KB","Kb")) xlabs<-c(round((pstart/1000),2),round((pstop/1000),2))
  axis(1,at=c(pstart,pstop),cex.axis=txt.cex,labels = xlabs)
  #add putative gene
  rect(xleft=as.numeric(starts),xright=as.numeric(stops),
         ybottom=y.lim[1]-0.04,ytop=y.lim[2],col="indianred",border="indianred")
  #add fsts
  mtext(chrom,1,cex=0.75*txt.cex,line = 1)
  for(i in 1:length(smooth.fsts)){
    points(smooth.fsts[[i]],col=alpha(colors[i],alphas[i]),type="l",lwd=lwds[i],lty=ltys[i])
  }
  
  #add delta divergence
  if(is.data.frame(dd.smooth)){
    points(dd.smooth$pos,dd.smooth$smoothed.stats,col="#dfc27d",type="l",lwd=2)
  }
  if(is.list(deltad)){
    upp.low.pts(smooth=deltad[[1]],target=deltad[[2]],chrom=chrom,color=comp.col["deltad"],stat="deltad",pos.name="Pos")
  }
  
  #add Jost's D
  if(is.data.frame(dsmooth)){
    points(dsmooth$pos,dsmooth$smoothed.stats,type="l",col="#a6611a",lwd=2)
  }
  if(is.list(D)){
    upp.low.pts(smooth=D[[1]],target=D[[2]],chrom=chrom,color=comp.col["D"],stat="D",pos.name="Pos")
  }
  
  
  #are nj trees shown in scope of fig?
  njs.eval<-lapply(nj.gene,function(x){
    if(x >= pstart & x <= pstop) { eval = TRUE }
    else { eval = FALSE }
    return(eval)
  })
  
  #add delta d
  if(is.data.frame(deltad)){
    lgnd<-unlist(lapply(names(fst.dfs),function(n) { bquote(.(n)~italic(F[ST])) }))
    lgnd<-c(lgnd,expression(delta~-divergence))
  }else{
    lgnd<-unlist(lapply(names(fst.dfs),function(n) { substitute(paste(name,italic(F[ST]),sep=""),list(name=n)) }))

  }
  
  cols<-NULL
  pchs<-rep(32,length(lwds))
  for(i in 1:length(colors)){
    cols<-c(cols,alpha(colors[i],alphas[i]))
  }
  if(!is.null(deltad)){
    cols<-c(cols,"#dfc27d")
    pchs<-c(pchs,32)
    ltys<-c(ltys,1)
    lwds<-c(lwds,2)
  }
  if(!is.null(D)){
    cols<-c(cols,"#a6611a")
    pchs<-c(pchs,32)
    lgnd<-c(lgnd,"Jost's D")
    ltys<-c(ltys,1)
    lwds<-c(lwds,2)
  }
  
  lgnd<-c(lgnd,substitute(italic(g),list(g=gene)),"Outlier RAD loci")
  
  cols<-c(cols,"indianred","black")
  pchs<-c(pchs,15,124)
  if(length(grep(TRUE,njs.eval))>0){
    lgnd<-c(lgnd,"Monophyletic Gene Tree")
    cols<-c(cols,"#08519c")
    pchs<-c(pchs,124)
  }
  
  if(length(sal.gene)>0){
    lgnd<-c(lgnd,"Salinity-associated")
    cols<-c(cols,"black")
    pchs<-c(pchs,25)
  }
  if(legend==TRUE){
  legend("topleft",
         legend=lgnd,pch=pchs,
         bty='n',lwd=c(lwds,0,0,0,0),lty=c(ltys,0,0,0,0),
         col=cols,cex = txt.cex)
  }
  #add outlier loci
  clip(x1=min(as.numeric(pstart)),x2=max(as.numeric(pstop)),y1=y.lim[2]+.01,y2=y.lim[2]+0.2)
  abline(v=fst.gene,col="black")
  points(x=sal.gene,y=rep(y.lim[2]+0.05,length(sal.gene)),col="black",pch=25,cex=0.75*txt.cex,lwd=2)
  abline(v=nb.gene,col=alpha("black",0.5),cex=2)
  abline(v=nj.gene,col="#08519c",cex=2)
}

outside.legend<-function(...){
  opar <- par(fig=c(0, 1, 0, 1), oma=c(0, 0, 0, 0), 
    mar=c(0, 0, 0, 0), new=TRUE)
  on.exit(par(opar))
  plot(0, 0, type='n', bty='n', xaxt='n', yaxt='n')
  legend(...)
}
```

### Plot all genes - for supplement

```{r plot_putative_regions,eval=FALSE}
#set up legend parameters
leg.text<-c(expression(TX~FWSW~italic(F)[ST]),expression(LA~FWSW~italic(F)[ST]),
            expression(AL~FWSW~italic(F)[ST]),expression(FL~FWSW~italic(F)[ST]),
            expression(delta~-divergence),expression("Jost's"~italic(D)),
            expression(Shared~italic(F)[ST]~Outliers),
            "Salinity-associated SNPs")
leg.pchs<-c(rep(32,6),124,25,124)
leg.ltys<-c(1,1,2,1,1,1,0,0,0)
leg.cols<-c(colors,comp.col["deltad"],comp.col["D"],"black","black","indianred")


png("ARGHEF3.png",height=8,width=10,units="in",res=300)       
par(mfrow=c(5,3),oma=c(2,2,3,2),mar=c(2,2,1,1))
arhgef3<-lapply(unique(put.reg[put.reg$Gene=="ARHGEF3" & put.reg$Chrom%in%lgs,"Chrom"]),# & !is.na(put.reg$rad.loci)
       gene.region.plot,gene="ARHGEF3",put.reg=put.reg,vcf=vcf,chrom.ld=chrom.ld,
       fst.dfs=fst.dfs,deltad=dd.bp.smooth,D=jd.bp.smooth,colors=colors,alphas=alphas,ltys=ltys,
       smooth=FALSE,smooth.loess=FALSE,fst.name="Smoothed.AMOVA.Fst",bases="MB",legend=FALSE)
outside.legend("top",legend=c(leg.text,expression(italic(ARHGEF3))),pch=leg.pchs,lty=leg.ltys,lwd=2,
               bty='n',ncol=3,cex=1.25,x.intersp=0,col=leg.cols)
dev.off()

png("mucin.png",height=8,width=10,units="in",res=300)       
par(mfrow=c(5,3),oma=c(2,2,3,2),mar=c(2,2,1,1))
mucin<-lapply(unique(put.reg[put.reg$Gene=="mucin"& put.reg$Chrom%in%lgs,"Chrom"]),# & !is.na(put.reg$rad.loci)
       gene.region.plot,gene="mucin",put.reg=put.reg,vcf=vcf,chrom.ld=chrom.ld,
       fst.dfs=fst.dfs,deltad=dd.bp.smooth,D=jd.bp.smooth,colors=colors,alphas=alphas,ltys=ltys,
       smooth=FALSE,fst.name="Smoothed.AMOVA.Fst",bases="MB",legend=FALSE)
outside.legend("top",legend=c(leg.text,expression(italic(mucin))),pch=leg.pchs,lty=leg.ltys,lwd=2,
               bty='n',ncol=3,cex=1.25,x.intersp=0,col=leg.cols)
dev.off()

png("NHE.png",height=4,width=6,units="in",res=300)       
par(mfrow=c(2,4),oma=c(2,2,3,2),mar=c(2,2,2,2))
nhe<-lapply(unique(put.reg[put.reg$Gene=="NHE" & put.reg$Chrom%in%lgs,"Chrom"]),# & !is.na(put.reg$rad.loci)
       gene.region.plot,gene="NHE",put.reg=put.reg,vcf=vcf,chrom.ld=chrom.ld,
       fst.dfs=fst.dfs,deltad=dd.bp.smooth,D=jd.bp.smooth,colors=colors,alphas=alphas,ltys=ltys,
       smooth=FALSE,fst.name="Smoothed.AMOVA.Fst",bases="MB",legend=FALSE)
outside.legend("top",legend=c(leg.text,expression(italic(NHE))),pch=leg.pchs,lty=leg.ltys,lwd=2,
               bty='n',ncol=3,cex=1.25,x.intersp=0,col=leg.cols)
dev.off()

png("TAAR.png",height=4,width=6,units="in",res=300)       
par(mfrow=c(1,2),oma=c(2,2,3,2),mar=c(2,2,2,2))
taar<-lapply(unique(put.reg[put.reg$Gene=="TAAR" & put.reg$Chrom%in%lgs,"Chrom"]), #& !is.na(put.reg$rad.loci)
       gene.region.plot,gene="TAAR",put.reg=put.reg,vcf=vcf,chrom.ld=chrom.ld,
       fst.dfs=fst.dfs,deltad=dd.bp.smooth,D=jd.bp.smooth,colors=colors,alphas=alphas,ltys=ltys,
       smooth=FALSE,fst.name="Smoothed.AMOVA.Fst",bases="MB",legend=FALSE)
outside.legend("top",legend=c(leg.text,expression(italic(TAAR))),pch=leg.pchs,lty=leg.ltys,lwd=2,
               bty='n',ncol=3,cex=.75,x.intersp=0,col=leg.cols)
dev.off()

```

![Supplmental Fig. 5](fwsw_results/ARGHEF3.png)


![Supplemental Fig. 6](fwsw_results/mucin.png)


![Supplemental Fig. 7](fwsw_results/NHE.png)


![Supplemental Fig. 8](fwsw_results/TAAR.png)

### Figure 7

```{r making_Fig7,eval=FALSE}
colors=c(grp.colors[1],grp.colors[2],grp.colors[3],grp.colors[6])
alphas=c(0.5,0.5,1,0.5)
ltys=c(1,1,2,1)

png("Fig7candidateGenes.png",height=10,width=10,units="in",res=300)

par(mfrow=c(4,3),oma=c(2,2,4.5,2),mar=c(1,3,2,1))
#row1
gene.region.plot("LG1","NHE",put.reg,vcf=vcf,chrom.ld=chrom.ld,
       fst.dfs=fst.dfs,deltad=dd.bp.smooth,D=jd.bp.smooth,colors=colors,alphas=alphas,ltys=ltys,
       smooth=FALSE,smooth.loess=FALSE,fst.name="Smoothed.AMOVA.Fst",bases="MB",legend=FALSE)
text(x=4500000,y=0.5,expression(italic(NHE)),xpd=T,cex=2)

gene.region.plot("LG5","NHE",put.reg,vcf=vcf,chrom.ld=chrom.ld,
       fst.dfs=fst.dfs,deltad=dd.bp.smooth,D=jd.bp.smooth,colors=colors,alphas=alphas,ltys=ltys,
       smooth=FALSE,smooth.loess=FALSE,fst.name="Smoothed.AMOVA.Fst",bases="MB",legend=FALSE)
text(x=4500000,y=0.5,expression(italic(NHE)),xpd=T,cex=2)

gene.region.plot("LG11","NHE",put.reg,vcf=vcf,chrom.ld=chrom.ld,
       fst.dfs=fst.dfs,deltad=dd.bp.smooth,D=jd.bp.smooth,colors=colors,alphas=alphas,ltys=ltys,
       smooth=FALSE,smooth.loess=FALSE,fst.name="Smoothed.AMOVA.Fst",bases="MB",legend=FALSE)
text(x=3000000,y=0.5,expression(italic(NHE)),xpd=T,cex=2)

#row2
gene.region.plot("LG2","mucin",put.reg,vcf=vcf,chrom.ld=chrom.ld,
       fst.dfs=fst.dfs,deltad=dd.bp.smooth,D=jd.bp.smooth,colors=colors,alphas=alphas,ltys=ltys,
       smooth=FALSE,smooth.loess=FALSE,fst.name="Smoothed.AMOVA.Fst",bases="MB",legend=FALSE)
text(x=4500000,y=0.5,expression(italic(mucin)),xpd=T,cex=2)

gene.region.plot("LG4","TAAR",put.reg,vcf=vcf,chrom.ld=chrom.ld,
       fst.dfs=fst.dfs,deltad=dd.bp.smooth,D=jd.bp.smooth,colors=colors,alphas=alphas,ltys=ltys,
       smooth=FALSE,smooth.loess=FALSE,fst.name="Smoothed.AMOVA.Fst",bases="MB",legend=FALSE)
text(x=15000000,y=0.5,expression(italic(TAAR)),xpd=T,cex=2)

gene.region.plot("LG7","TAAR",put.reg,vcf=vcf,chrom.ld=chrom.ld,
       fst.dfs=fst.dfs,deltad=dd.bp.smooth,D=jd.bp.smooth,colors=colors,alphas=alphas,ltys=ltys,
       smooth=FALSE,smooth.loess=FALSE,fst.name="Smoothed.AMOVA.Fst",bases="MB",legend=FALSE)
text(x=3000000,y=0.5,expression(italic(TAAR)),xpd=T,cex=2)

#row3
gene.region.plot("LG7","ARHGEF3",put.reg,vcf=vcf,chrom.ld=chrom.ld,
       fst.dfs=fst.dfs,deltad=dd.bp.smooth,D=jd.bp.smooth,colors=colors,alphas=alphas,ltys=ltys,
       smooth=FALSE,smooth.loess=FALSE,fst.name="Smoothed.AMOVA.Fst",bases="MB",legend=FALSE)
text(x=8500000,y=0.5,expression(italic(ARHGEF3)),xpd=T,cex=2)

gene.region.plot("LG13","ARHGEF3",put.reg,vcf=vcf,chrom.ld=chrom.ld,
       fst.dfs=fst.dfs,deltad=dd.bp.smooth,D=jd.bp.smooth,colors=colors,alphas=alphas,ltys=ltys,
       smooth=FALSE,smooth.loess=FALSE,fst.name="Smoothed.AMOVA.Fst",bases="MB",legend=FALSE)
text(x=2200000,y=0.5,expression(italic(ARHGEF3)),xpd=T,cex=2)

gene.region.plot("LG14","ARHGEF3",put.reg,vcf=vcf,chrom.ld=chrom.ld,
       fst.dfs=fst.dfs,deltad=dd.bp.smooth,D=jd.bp.smooth,colors=colors,alphas=alphas,ltys=ltys,
       smooth=FALSE,smooth.loess=FALSE,fst.name="Smoothed.AMOVA.Fst",bases="MB",legend=FALSE)
text(x=6500000,y=0.5,expression(italic(ARHGEF3)),xpd=T,cex=2)

#row4
gene.region.plot("LG18","ARHGEF3",put.reg,vcf=vcf,chrom.ld=chrom.ld,
       fst.dfs=fst.dfs,deltad=dd.bp.smooth,D=jd.bp.smooth,colors=colors,alphas=alphas,ltys=ltys,
       smooth=FALSE,smooth.loess=FALSE,fst.name="Smoothed.AMOVA.Fst",bases="MB",legend=FALSE)
text(x=5500000,y=0.5,expression(italic(ARHGEF3)),xpd=T,cex=2)

gene.region.plot("LG19","ARHGEF3",put.reg,vcf=vcf,chrom.ld=chrom.ld,
       fst.dfs=fst.dfs,deltad=dd.bp.smooth,D=jd.bp.smooth,colors=colors,alphas=alphas,ltys=ltys,
       smooth=FALSE,smooth.loess=FALSE,fst.name="Smoothed.AMOVA.Fst",bases="MB",legend=FALSE)
text(x=4000000,y=0.5,expression(italic(ARHGEF3)),xpd=T,cex=2)

gene.region.plot("LG20","ARHGEF3",put.reg,vcf=vcf,chrom.ld=chrom.ld,
       fst.dfs=fst.dfs,deltad=dd.bp.smooth,D=jd.bp.smooth,colors=colors,alphas=alphas,ltys=ltys,
       smooth=FALSE,smooth.loess=FALSE,fst.name="Smoothed.AMOVA.Fst",bases="MB",legend=FALSE)
text(x=4000000,y=0.5,expression(italic(ARHGEF3)),xpd=T,cex=2)


outside.legend("top",legend=c(expression(TX~FWSW~italic(F)[ST]),expression(LA~FWSW~italic(F)[ST]),
            expression(AL~FWSW~italic(F)[ST]),expression(FL~FWSW~italic(F)[ST]),
            expression(delta~-divergence),expression("Jost's"~italic(D)),
            expression(Shared~italic(F)[ST]~Outliers),
            "Salinity-associated SNPs","FW gene"),
            pch=c(rep(32,6),124,25,124),lty=c(1,1,2,1,1,1,0,0,0),lwd=2,
               bty='n',ncol=5,cex=1.25,x.intersp=0,
            col=c(colors,comp.col["deltad"],comp.col["D"],"black","black","indianred"))
# 
# par(fig = c(0, 1, 0, 1),oma=rep(0, 4), mar=rep(0, 4), new=TRUE)
# plot(0:1.5, 0:1.5, type="n", xlab="", ylab="", axes=FALSE)
# legend(x=0.5,y=0.22,c(expression(Shared~italic(F)[ST]~Outliers),
#                 "Salinity-associated SNPs",
#                 "FW Candidate Gene"),
#        pch=c(124,25,124),lty=c(0,0,0),lwd=2,
#        col=c("black","black","indianred"),
#        bty='n',ncol=1,cex=2,x.intersp=-0.5,xpd=T)
# 
# 
# #add lines to the top
# par(fig = c(0, 1, 0, 1),oma=rep(0, 4), mar=rep(0, 4), new=TRUE)
# plot(0:1, 0:1, type="n", xlab="", ylab="", axes=FALSE)
# legend("top",c(expression(TX~FWSW~italic(F)[ST]),
#                 expression(LA~FWSW~italic(F)[ST]),
#                 expression(AL~FWSW~italic(F)[ST]),
#                 expression(FL~FWSW~italic(F)[ST]),
#                 expression(delta~-divergence)),
#        pch=rep(32,5),lty=c(1,1,1,1,1),lwd=2,text.width=0.16,
#        col=c(grp.colors[1],grp.colors[2],grp.colors[3],grp.colors[6],
#           "#dfc27d"),
#        bty='n',ncol=3,cex=2,x.intersp=0.5,y.intersp=0.75,xpd=T)
dev.off()
```

![Fig. 7](fwsw_results/Fig7candidateGenes.png)

## Figure 8: LG4

LG4 clearly is enriched for outliers, let's look at it more closely, including putative FW genes.

```{r prep_lg4,eval=TRUE}
#define a few things
chrom<-"LG4"
pchs<-c(rep(32,6),15,124,124)
cols<-c(grp.colors[1],grp.colors[2],grp.colors[3],grp.colors[6],
        "#dfc27d","#a6611a","indianred","black","#08519c")
comp.col<-c(Het="#80cdc1",pi="#018571",Fst="black",D="#a6611a",deltad="#dfc27d")
ltys=c(1,1,2,1,1,1,0,0,0)
lwds<-c(rep(2,6),0,0,0)

#put together the data for LG4
#this.dd<-deltad[deltad$Chrom %in% chrom,]
#dd.smooth<-loess.smooth(this.dd$Pos,this.dd$deltad,span=0.1,degree=2)
#add Jost's D
#this.d<-jostd[jostd$Chr %in% chrom,]
#dsmooth<-loess.smooth(this.d$POS,this.d$D,span=0.1,degree=2) 
#get the outliers
pr.gene<-put.reg[put.reg$Chrom==chrom ,]
#rad loci 
fst.gene<- stacks.sig[stacks.sig$Chr==chrom,"BP"]
#none of the salinity-associated RAD loci are in or near genes on LG8, but we could plot them all anyway
sal.gene<-sal.bf.sig[sal.bf.sig$scaffold=="LG8","BP"]
#jost's d - none are in the putative genes
jd.gene<-unlist(strsplit(gsub(paste(chrom,".",sep=""),"",pr.gene$jost.in[jost.in != "NA"]),","))
#delta divergence outliers- none are in the putative genes
sdd.gene<- unlist(strsplit(gsub(paste(chrom,".",sep=""),"",pr.gene$sdd.in[pr.gene$sdd.in != "NA"]),","))
#put all of them together with their associated shapes
gene.out<-data.frame(BP=c(as.numeric(fst.gene),as.numeric(sal.gene),as.numeric(sdd.gene)),
                     shape=c(rep(8,length(fst.gene)),rep(1,length(sal.gene)),rep(4,length(sdd.gene))))
#add putative genes
g<-put.reg[put.reg$Chrom %in% chrom,]
  g$Gene<-as.character(g$Gene)
  g$Gene[grep("ATP6",g$Gene)]<-"ATP6V" #standardize the names
  g<-g[,c("Gene","StartBP","StopBP")]
  g<-g[!duplicated(g$StartBP),]
  g<-g[order(g$StartBP),]
## Model 1
source("../programs/dmc-master/getMCLE.R")
dmc.pattern<-"p4LG4_100000_2_9_forReal"
positions<-readRDS("dmc/selectedRegionPositions_p4LG4.RDS")
selSite = positions[seq(1, length(positions[positions<10000000]), length.out = 100)]
sels = c(1e-4, 1e-3, 0.01, seq(0.02, 0.14, by = 0.01), seq(0.15, 0.3, by = 0.05), 
             seq(0.4, 0.6, by = 0.1))
times = c(0, 5, 25, 50, 100, 500, 1000, 1e4, 1e6)
migs = c(10^-(seq(5, 1, by = -2)), 0.5, 1)
Ne<-100000
rec=2*10^-9
sources<-c(3,5,7,16)
gs<-c(1/(2*Ne), 10^-(4:1))
compLikelihood_ind<-readRDS(paste("dmc/compLikelihood_ind_",dmc.pattern,".RDS",sep=""))
mcle_ind = getMCLEind(compLikelihood_ind, selSite, sels)
mcle_ind_index<-which(mcle_ind[1]==selSite)
profileLike_sel_ind = sapply(1: length(sels), function(i) {
  max(unlist(compLikelihood_ind[[mcle_ind_index]][[i]]))
})

## Model 3
compLikelihood_sv<-readRDS(paste("dmc/compLikelihood_sv_",dmc.pattern,".RDS",sep=""))
mcle_sv<-getMCLEsv_source(compLikelihood_sv, selSite, sels, gs, times, sources)
mcle_sv_index<-which(mcle_sv[1]==selSite)
profileLike_sel_sv = sapply(1: length(sels), function(i) {
  max(unlist(compLikelihood_sv[[mcle_sv_index]][[i]]))
})

## Model 5
compLikelihood_mixed_svInd<-readRDS(paste("dmc/compLikelihood_mixed_svInd_",dmc.pattern,".RDS",sep=""))
mcle_mixed_svInd<-getMCLEmixed(compLikelihood_mixed_svInd, selSite, sels, gs, times, migs[1], sources)
mcle_mixed_svInd_index<-which(mcle_mixed_svInd[1]==selSite)
profileLike_sel_mixed_svInd = sapply(1: length(sels), function(i) {
  max(unlist(compLikelihood_mixed_svInd[[mcle_mixed_svInd_index]][[i]]))
})

#functions for plotting dmc output
calc.max.complike<-function(pattern,neutral_name=NA){
  #read in composite likelihood files and calculate max for all proposed selected sites
  if(is.na(neutral_name)){
    compLikelihood_neutral = readRDS(paste("dmc/compLikelihood_neutral_",dmc.pattern,".RDS",sep=""))
  }else{
    compLikelihood_neutral = readRDS(neutral_name)
  }
  
  compLikelihood_neutral_site = sapply(1 : length(compLikelihood_neutral), function(i) {
    max(unlist(compLikelihood_neutral[[i]]))
  })
  
  compLikelihood_ind = readRDS(paste("dmc/compLikelihood_ind_",pattern,".RDS",sep=""))
  compLikelihood_ind_site = sapply(1 : length(compLikelihood_ind), function(i) {
    max(unlist(compLikelihood_ind[[i]]))
  })
  
  compLikelihood_mig = readRDS(paste("dmc/compLikelihood_mig_",pattern,".RDS",sep=""))
  compLikelihood_mig_site = sapply(1 : length(compLikelihood_mig), function(i) {
    max(unlist(compLikelihood_mig[[i]]))
  })
  
  compLikelihood_sv = readRDS(paste("dmc/compLikelihood_sv_",pattern,".RDS",sep=""))
  compLikelihood_sv_site = sapply(1 : length( compLikelihood_sv), function(i) {  
    max(unlist(compLikelihood_sv[[i]]))
  })
  
  compLikelihood_mixed_migInd = readRDS(paste("dmc/compLikelihood_mixed_migInd_",pattern,".RDS",sep=""))
  compLikelihood_mixed_migInd_site = sapply(1 : length(compLikelihood_mixed_migInd), function(i) {
    max(unlist(compLikelihood_mixed_migInd[[i]]))
  })
  
  compLikelihood_mixed_svInd = readRDS(paste("dmc/compLikelihood_mixed_svInd_",pattern,".RDS",sep=""))
  compLikelihood_mixed_svInd_site = sapply(1 : length(compLikelihood_mixed_svInd), function(i) {
    max(unlist(compLikelihood_mixed_svInd[[i]]))
  })
  return(list(max.likes=c(ind=(compLikelihood_ind_site - compLikelihood_neutral_site),
           mig=(compLikelihood_mig_site - compLikelihood_neutral_site), 
           sv=(compLikelihood_sv_site - compLikelihood_neutral_site),
           migInd=(compLikelihood_mixed_migInd_site - compLikelihood_neutral_site),
           svInd=(compLikelihood_mixed_svInd_site - compLikelihood_neutral_site)),
         max.complikes=c(neutral=compLikelihood_neutral,ind=compLikelihood_ind,
           mig=compLikelihood_mig, 
           sv=compLikelihood_sv,
           migInd=compLikelihood_mixed_migInd,
           svInd=compLikelihood_mixed_svInd)))
}

plot.complike<-function(pattern,leg=TRUE,lab=TRUE,plot_range = NA,selSite){
  
}

```
```{r plot_lg4}
png("LG4.png",width=10,height=7,units="in",res=300)

nf <- layout(matrix(c(1,1,1,1,
                      2,2,2,2,
                      3,3,3,3), nrow=3, byrow=TRUE))

### Plot all of LG4
par(oma=c(2.5,5,2,1),mar=c(1.5,1,2,1))
plot(fst.dfs[[1]]$BP[fst.dfs[[1]]$Chr %in% chrom],
     fst.dfs[[1]]$Smoothed.AMOVA.Fst[fst.dfs[[1]]$Chr %in% chrom],
     type='n',ylim=c(0,1),bty="L",xlab="",ylab="",xaxt='n',yaxt='n')
  axis(2,las=1,cex.axis=1.75)  
  axis(1,cex.axis=1.75,at=seq(0,1.8*10^7,3*10^6),labels = seq(0,18,3))
  #add fsts
  #mtext(chrom,1,cex=2*0.75,line=2.5)
  for(i in 1:length(fst.dfs)){
    points(fst.dfs[[i]]$BP[fst.dfs[[i]]$Chr %in% chrom],
           fst.dfs[[i]]$Smoothed.AMOVA.Fst[fst.dfs[[i]]$Chr %in% chrom],
           col=alpha(colors[i],alphas[i]),type="l",lwd=lwds[i],lty=ltys[i])
  }
  #add delta-d and Jost's D
  #Pi
#  points(pi.bp.smooth[[2]][pi.bp.smooth[[2]][,"chr"]%in% chrom,c("pos","smoothed.stats")],
#       type="l",lwd=2,col=comp.col["pi"])
#  upp.low.pts(smooth=pi.bp.smooth[[1]],target=pi.bp.smooth[[2]],
#              chrom=chrom,color=comp.col["pi"],stat="Pi",pos.name="Pos",cex=1.75)
  #Het
 # points(ht.bp.smooth[[2]][ht.bp.smooth[[2]][,"chr"]%in% chrom,c("pos","smoothed.stats")],
#         type="l",col=comp.col["Het"],lwd=2)
 # upp.low.pts(smooth=ht.bp.smooth[[1]],target=ht.bp.smooth[[2]],
#              chrom=chrom,color=comp.col["Het"],stat="Het",pos.name="Pos",cex=1.75)
  
  #deltad
  points(dd.bp.smooth[[2]][dd.bp.smooth[[2]][,"chr"]%in% chrom,c("pos","smoothed.stats")],
         type="l",col=comp.col["deltad"],lwd=2)
  upp.low.pts(smooth=dd.bp.smooth[[1]],target=dd.bp.smooth[[2]],
              chrom=chrom,color=comp.col["deltad"],stat="deltad",pos.name="Pos",cex=1.75)

  #Josts D
  points(jd.bp.smooth[[2]][jd.bp.smooth[[2]][,"chr"]%in% chrom,c("pos","smoothed.stats")],
         type="l",col=comp.col["D"],lwd=2)
  upp.low.pts(smooth=jd.bp.smooth[[1]],target=jd.bp.smooth[[2]],
              chrom=chrom,color=comp.col["D"],stat="D",pos.name="Pos",cex=1.75)
  
  
   #add the putative genes
  starts<-as.numeric(g[,"StartBP"])
  stops<-as.numeric(g[,"StopBP"])
  rect(xleft=as.numeric(starts),xright=as.numeric(stops),
         ybottom=-0.04,ytop=1,col="indianred",border="indianred")
  #add the ones that are spaced out
  text(x=g$StartBP[!g$Gene %in% c("SCUBE1","TRIM14")],y=0.5,
       labels=g$Gene[!g$Gene %in% c("SCUBE1","TRIM14")],font=2,srt=90,xpd=T,cex=1.75)
  text(x=g$StartBP[g$Gene == "SCUBE1"]-50000,y=0.8,
       labels=g$Gene[g$Gene =="SCUBE1"],font=2,srt=90,xpd=T,cex=1.75)
  text(x=g$StartBP[g$Gene == "TRIM14"]+50000,y=0.2,
       labels=g$Gene[g$Gene =="TRIM14"],font=2,srt=90,xpd=T,cex=1.75)
  #add outlier loci
  clip(x1=min(as.numeric(fst.dfs[[1]]$BP[fst.dfs[[1]]$Chr %in% chrom])),
       x2=max(as.numeric(fst.dfs[[1]]$BP[fst.dfs[[1]]$Chr %in% chrom])),y1=0.99,y2=1.06)
  abline(v=fst.gene,col="black",lwd=1.5)
  points(x=sal.gene,y=rep(1.05,length(sal.gene)),col="black",pch=25,cex=1)
  

### Plot the recombination rate
load("../../scovelli_genome/ssc_map.rda")
rec.cols<-c("#fdbb84","#fc8d59","#ef6548")
plot(set[["LG4"]]@interpolations$slidingwindow@physicalPositions,
     set[["LG4"]]@interpolations$slidingwindow@rates,type="l",bty="L",
     ylim=c(-5,25),xlab="",ylab="",xaxt='n',yaxt='n',lwd=2,col=rec.cols[1])
abline(h=0,lty=2)
axis(2,cex.axis=1.75,las=1)
axis(1,at=seq(0,1.8*10^7,3*10^6),labels = seq(0,18,3),cex.axis=1.75)
mtext("Recombination Rate\n(cM/Mb)",2,line=3,cex=1.5*0.75)
lines(set[["LG4"]]@interpolations$spline@physicalPositions,
      set[["LG4"]]@interpolations$spline@rates,type="l",col=rec.cols[2],lwd=2)
lines(set[["LG4"]]@interpolations$loess@physicalPositions,
      set[["LG4"]]@interpolations$loess@rates,type="l",lwd=2,col=rec.cols[3])
legend("topleft",bty='n',col=rec.cols,
       lwd=2,c("Sliding Window","Spline","Loess"),cex=1.5)

### Plot dmc results
max.complikes<-calc.max.complike(dmc.pattern)
max.likes<-max.complikes[[1]]
plot_range = range(max.likes)
plot(selSite, max.likes[grep("ind",names(max.likes))], type = "b",bty="l",
       ylim = c(plot_range[1] - 50, plot_range[2] + 50),
     xlim=range(fst.dfs[[1]]$BP[fst.dfs[[1]]$Chr %in% chrom]),
     xlab = "x.lab",ylab = "",cex=2,las=1,cex.axis=1.75,xaxt='n')
axis(1,at=seq(0,1.8*10^7,3*10^6),labels = seq(0,18,3),cex.axis=1.75)
lines(selSite, max.likes[grep("mig\\d+",names(max.likes))],cex=2, col = "#d7191c",#red
        type = "b")
lines(selSite, max.likes[grep("sv\\d+",names(max.likes))],cex=2, col = "#2b83ba",#blue
        type = "b")
lines(selSite, max.likes[grep("migInd",names(max.likes))],cex=2,#orange
        col = "#fdae61", lty = 2, type = "b")
lines(selSite, max.likes[grep("svInd",names(max.likes))],cex=2,#green
        col = "#91cf60", lty = 2, type = "b")
legend("topright", col = c("black", "#d7191c", "#2b83ba", "#fdae61", "#abdda4"),
           lty = c(rep(1, 3), rep(2, 2)), sapply(1 : 5, function(i) paste("Model", i)),
       bty='n',cex=1.5,lwd=2)
mtext("Composite Log Likelihood",2,line=3.75,cex=1.5*0.75)
mtext("Position on LG4 (Mb)",1,line=2.2,cex=1.5*0.75)
abline(v=mcle_ind[1],lty=2,lwd=2,col="black",xpd=FALSE)
abline(v=mcle_sv[1],lty=2,lwd=2,col="#2b83ba",xpd=FALSE)
abline(v=mcle_mixed_svInd[1],lty=2,lwd=2,col="#91cf60",xpd=FALSE)
  
### add legend
#create the legend text, and parameters
lgnd<-unlist(lapply(names(fst.dfs),function(n) { bquote(.(n)~italic(F[ST])) }))
lgnd<-c(lgnd,expression(delta~-divergence),"Jost's D","gene regions",
        expression("Shared"~italic(F[ST])~"outlier"),"Salinity-associated")
pchs<-c(rep(32,6),15,124,25)
cols<-c(grp.colors[1],grp.colors[2],grp.colors[3],grp.colors[6],
        "#dfc27d","#a6611a","indianred","black","black")
ltys=c(1,1,2,1,1,1,0,0,0)
lwds<-c(rep(2,6),0,0,1)
#plot the legend
par(fig=c(0, 1, 0, 1), oma=c(0, 0, 0, 0), mar=c(0, 0, 0, 0), new=TRUE,xpd=TRUE)
plot(c(0,1),c(0,1),bty='n',type='n',xlab="",ylab="",xaxt='n',yaxt='n')
legend("top",legend=lgnd,pch=pchs,ncol=5,
       bty='n',lwd=lwds,lty=ltys,
       col=cols,xpd=TRUE,cex=1.5,
       x.intersp = 0.5,y.intersp = 0.75)
dev.off()
```

![LG 4 Figure](fwsw_results/LG4.png)

The loci that are the most likely targets of selection in models 3 and 5 are located at $`r mcle_sv[1]`$ and $`r mcle_mixed_svInd[1]`$, respectively. Let's use the gff file to annotate them.

```{r annotate_dmc}
#read in the gff if necessary
if(!("gff" %in% ls())){
  if(length(grep("gz",gff.name))>0){
    gff<-read.delim(gzfile(paste("../../scovelli_genome/",gff.name,sep="")),header=F)
  } else{
    gff<-read.delim(paste("../../scovelli_genome/",gff.name,sep=""),header=F)
  }
  colnames(gff)<-c("seqname","source","feature","start","end","score","strand","frame","attribute")
}
#get the blast matches
genome.blast<-read.csv("../../scovelli_genome/ssc_2016_12_20_cds_nr_blast_results.csv",skip=1)

#where are the loci?
gff[gff$seqname=="LG4" & gff$start <= mcle_sv[1] & gff$end >= mcle_sv[1],]
gff[gff$seqname=="LG4" & gff$start <= mcle_mixed_svInd[1] & gff$end >= mcle_mixed_svInd[1],]

dmc.genes<-data.frame(Locus.ID=c("Mod3","Mod5"),Chr=c("LG4","LG4"),BP=c(mcle_sv[1],mcle_mixed_svInd[1]),Column=c(1,1)) #format it appropriately
dmc.ann<-sig.region.ann(dmc.genes,gff,genome.blast)

kable(dmc.ann[,c("Locus","description")],row.names = FALSE)

```

Finally, I will write the putative gene regions to a file to be supplemental table 2.

```{r supp_Table2}
#Provide more informative names
colnames(put.reg)<-c("Gene","Function","Chromosome_CitedSpeices","CitedSpecies","Citation","Scovelli_geneID",
                     "My_Annotation_Notes","Scovelli_Chrom","Scovelli_StartBP","Scovelli_StopBP",
                     "Contains_RAD_locus","Near_RAD_locus","Contains_DeltaDivergence","Near_DeltaDivergence",
                     "Contains_BayenvSalinity","Contains_BayenvTemp","Contains_BayenvSeagrass",
                     "Near_JostD","Contains_JostD","Contains_Fst")
write.table(put.reg,"putative_genes_annotated.txt",sep='\t',col.names = TRUE,row.names = FALSE,quote=FALSE)
```
