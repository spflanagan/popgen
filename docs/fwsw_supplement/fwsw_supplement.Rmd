---
title: Supplemental Material for "Multiple colonizations of freshwater by the Gulf pipefish reveal a shared genomic signature of adaptation"
preprint: false
author: 
  - name: Sarah P. Flanagan
    affiliation: 1
    corresponding: true
    email: spflanagan.phd@gmail.com
  - name: Emily Rose
    affiliation: 2
  - name: Adam Jones
    affiliation: 3
affiliation:
  - code: 1
    address: School of Biological Sciences, University of Canterbury, 4800 Private Bag, Christchurch 8140 New Zealand
  - code: 2
    address: Department of Biology, The University of Tampa, Tampa, FL 33606 USA
  - code: 3
    address: Department of Biological Sciences, University of Idaho, Moscow, ID 83844 USA
abstract: >
  This document include supplementary material for the paper.
header-includes: >
  \usepackage{lipsum}
bibliography: programs.bib
output:
  pdf_document:
    fig_caption: yes
    keep_tex: yes
    number_sections: yes
    template: manuscript.latex
  html_document: null
  word_document: null
fontsize: 11pt
capsize: normalsize
csl: molecular-ecology.csl
documentclass: article
spacing: doublespacing
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir='../../fwsw_results/', fig.pos='H')
knitr::opts_chunk$set(fig.path = '../../figs',echo=FALSE,dpi=300)
```
```{r source}
source("../../gwscaR/R/gwscaR.R")
source("../../gwscaR/R/gwscaR_plot.R")
source("../../gwscaR/R/gwscaR_utility.R")
source("../../gwscaR/R/gwscaR_fsts.R")
source("../../gwscaR/R/gwscaR_popgen.R")
source("../../gwscaR/R/vcf2dadi.R")
source("../R/203_treemix_plotting_funcs.R")#I've modified these functions
library(knitr)
library(scales)
```

```{r}
pop.list<-c("TXSP","TXCC","TXFW","TXCB","LAFW","ALST","ALFW","FLSG","FLKB",
	"FLFD","FLSI","FLAB","FLPB","FLHB","FLCC","FLLG")
pop.labs<-c("TXSP","TXCC","TXFW","TXCB","LAFW","ALST","ALFW","FLSG","FLKB",
            "FLFD","FLSI","FLAB","FLPB","FLHB","FLCC","FLFW")
fw.list<-c("TXFW","LAFW","ALFW","FLLG")
sw.list<-c("TXSP","TXCC","TXCB","ALST","FLSG","FLKB",
	"FLFD","FLSI","FLAB","FLPB","FLHB","FLCC")
lgs<-c("LG1","LG2","LG3","LG4","LG5","LG6","LG7","LG8","LG9","LG10","LG11",
	"LG12","LG13","LG14","LG15","LG16","LG17","LG18","LG19","LG20","LG21",
	"LG22")
lgn<-seq(1,22)
all.colors<-c(rep("black",2),"#2166ac","black","#2166ac","black","#2166ac",
        rep("black",8),"#2166ac")
#grp.colors<-c('#e41a1c','#377eb8','#4daf4a','#984ea3','#ffff33','#f781bf')
grp.colors<-c('#762a83','#af8dc3','#e7d4e8','#d9f0d3','#7fbf7b','#1b7837')
col_vector<-c(red='#e6194b', green='#3cb44b', blue='#4363d8',yellow='#ffe119', cyan='#46f0f0',orange='#f58231', teal='#008080', purple='#911eb4',  magenta='#f032e6', lime='#bcf60c', pink='#fabebe',  lavendar='#e6beff', brown='#9a6324', olive='#808000', apricot='#ffd8b1',maroon='#800000', mint='#aaffc3', navy='#000075', beige='#fffac8', grey='#808080', white='#ffffff', black='#000000')

col_vector<-c('#762a83','#762a83',"#2166ac",'#762a83',"#2166ac",'#af8dc3',"#2166ac",'#e7d4e8','#e7d4e8','#e7d4e8','#e7d4e8','#7fbf7b','#1b7837','#1b7837','#1b7837',"#2166ac")
#ppi<-data.frame(Pop=pop.labs,cols = all.colors,pch=c(0,1,21,2,24,3,23,4,5,6,7,9,10,11,12,22))
ppi<-data.frame(Pop=pop.labs,cols = col_vector,pch=rep(c(15,16,17,18),4))
```



# Introduction {-}

This document contains additional data and figures that support our genetic analyses.


# Population Structure {-}

## Admixture scree plots {-}


```{r}
admixK<-read.delim("admixture/K_CVs.txt",header = FALSE)
admixK$K<-as.numeric(gsub(".*\\(K=(\\d+)\\).*","\\1",admixK$V1))
admixK$CV<-as.numeric(gsub("^.*\\: (\\d+\\.\\d+)$","\\1",admixK$V1))

admixK<-admixK[order(admixK$K),]

plot(admixK$K,admixK$CV,pch=19,type = "b",lty=1,xlab = "K",ylab="CV",las=1,lwd=2)

```


## PCAdapt  {-}


````{r pcadapt_choose}
library(pcadapt)
filename<-read.pcadapt("filter_rad_20191014@1654/14_filtered/radiator_data_20191014@1710.vcf",type="vcf")
x<-pcadapt(filename, K=20)
plot(x,option="screeplot") #K=7
```


```{r pcadapt_pc1thru6, fig.height=8,fig.width=10.5,dev=c('png', 'pdf'),fig.dim="in"}
pa<-readRDS("fwsw_all_pcadapt.RDS")
pap<-read.delim("pcadapt_colp.txt",header = TRUE)
pa.props<-round((pa$singular.values/sum(pa$singular.values))*100,2)
#plot
par(mfrow=c(2,3),oma=c(2,2,2,2),mar=c(2,2,2,2))
plot(pa$scores[,1],pa$scores[,2],col=alpha(pap$cols,0.5),bg=alpha(pap$cols,0.75),
     pch=as.numeric(pap$pch),	cex=1.5)
mtext(paste("PC1 (",pa.props[1],"%)",sep=""),1,line = 2,cex=0.75)
mtext(paste("PC2 (",pa.props[2],"%)",sep=""),2,line = 2,cex=0.75)
plot(pa$scores[,1],pa$scores[,3],col=alpha(pap$cols,0.5),bg=alpha(pap$cols,0.75),pch=as.numeric(pap$pch),
	cex=1.5)
mtext(paste("PC1 (",pa.props[1],"%)",sep=""),1,line = 2,cex=0.75)
mtext(paste("PC3 (",pa.props[3],"%)",sep=""),2,line = 2,cex=0.75)
plot(pa$scores[,1],pa$scores[,4],col=alpha(pap$cols,0.5),bg=alpha(pap$cols,0.75),pch=as.numeric(pap$pch),
	cex=1.5)
mtext(paste("PC1 (",pa.props[1],"%)",sep=""),1,line = 2,cex=0.75)
mtext(paste("PC4 (",pa.props[4],"%)",sep=""),2,line = 2,cex=0.75)
plot(pa$scores[pap$grp=="freshwater",1],pa$scores[pap$grp=="freshwater",2],
     col=alpha(pap$cols[pap$grp=="freshwater"],0.5),
     bg=alpha(pap$cols[pap$grp=="freshwater"],0.75),pch=as.numeric(pap$pch[pap$grp=="freshwater"]),
	cex=1.5)
mtext(paste("PC1 (",pa.props[1],"%)",sep=""),1,line = 2,cex=0.75)
mtext(paste("PC2 (",pa.props[2],"%)",sep=""),2,line = 2,cex=0.75)
plot(pa$scores[pap$grp=="freshwater",1],pa$scores[pap$grp=="freshwater",3],
     col=alpha(pap$cols[pap$grp=="freshwater"],0.5),
     bg=alpha(pap$cols[pap$grp=="freshwater"],0.75),pch=as.numeric(pap$pch[pap$grp=="freshwater"]),
	cex=1.5)
mtext(paste("PC1 (",pa.props[1],"%)",sep=""),1,line = 2,cex=0.75)
mtext(paste("PC3 (",pa.props[3],"%)",sep=""),2,line = 2,cex=0.75)
plot(pa$scores[pap$grp=="freshwater",1],pa$scores[pap$grp=="freshwater",4],
     col=alpha(pap$cols[pap$grp=="freshwater"],0.5),
     bg=alpha(pap$cols[pap$grp=="freshwater"],0.75),pch=as.numeric(pap$pch[pap$grp=="freshwater"]),
	cex=1.5)
mtext(paste("PC1 (",pa.props[1],"%)",sep=""),1,line = 2,cex=0.75)
mtext(paste("PC4 (",pa.props[4],"%)",sep=""),2,line = 2,cex=0.75)

par(fig = c(0, 1, 0, 1), oma=c(2,1,0,1), mar = c(0, 0, 0, 0), new = TRUE,
	cex=1)
plot(0, 0, type = "n", bty = "n", xaxt = "n", yaxt = "n")

legend("top", legend=ppi$Pop, pch=as.numeric(ppi$pch), pt.cex=1.5,cex=0.85,
       col=alpha(ppi$cols, 0.5),pt.bg=alpha(ppi$cols,0.25), ncol=8,bty='n')

```


## Treemix extras {-}

### Tree with no migration edges and no root

```{r}
source("../R/203_treemix_plotting_funcs.R") #I've modified the functions from treemix
library(lattice); library(grid); library(RColorBrewer)
poporder<-read.delim("treemix/poporder")
colors<-poporder$colors
poporder<-poporder$poporder
par(mfrow=c(1,2),oma=c(2,2,2,2),mar=c(2,2,2,2))
tree<-plot_tree("treemix/fwsw_k100b",plotmig=F,scale=F,mbar=F,plus=0.05)
mtext("Drift parameter",1,line=2)
resid<-plot_resid("treemix/fwsw_k100b","treemix/poporder",wcols="rb")
```

### Residuals for trees with migration edges

These assume FLPB is the root.

```{r,fig.width=8,fig.height=7}
par(mfrow=c(2,3),oma=c(6,4,2,1))
r0<-plot_resid("treemix/fwsw_k100bFLPBr",  "treemix/poplist")
mtext("m = 0",3)
r1<-plot_resid("treemix/fwsw_k100bFLPBrm1","treemix/poplist")
mtext("m = 1",3)
r2<-plot_resid("treemix/fwsw_k100bFLPBrm2","treemix/poplist")
mtext("m = 2",3)
r3<-plot_resid("treemix/fwsw_k100bFLPBrm3","treemix/poplist")
mtext("m = 3",3)
r4<-plot_resid("treemix/fwsw_k100bFLPBrm4","treemix/poplist")
mtext("m = 4",3)
r5<-plot_resid("treemix/fwsw_k100bFLPBrm5","treemix/poplist")
mtext("m = 5",3)
```

### Trees with migration edges

```{r}
par(mfrow=c(2,3),mar=c(1,1,1,1),oma=c(1,1,1,1))
t0<-plot_tree("treemix/fwsw_k100bFLPBr",plotmig = F,plus=0.05,scale=T,mbar=T,mig_left = FALSE)
t1<-plot_tree("treemix/fwsw_k100bFLPBrm1",plus=0.05,scale=F,mbar=T,mig_left = FALSE)
t2<-plot_tree("treemix/fwsw_k100bFLPBrm2",plus=0.05,scale=F,mbar=T,mig_left = FALSE)
t3<-plot_tree("treemix/fwsw_k100bFLPBrm3",plus=0.05,scale=F,mbar=T,mig_left = FALSE)
t4<-plot_tree("treemix/fwsw_k100bFLPBrm4",plus=0.05,scale=F,mbar=T,mig_left = FALSE)
t5<-plot_tree("treemix/fwsw_k100bFLPBrm5",plus=0.05,scale=F,mbar=T,mig_left = FALSE)
```

### Choosing the optimal number of migration edges

To choose the optimal number of migration edges, we used the R package optM [@fitak_optm:_2019].

```{r}
library(OptM)
tmOpt<-optM("treemix")
```

```{r,fig.height=8}
plot_optM(tmOpt)
```


Let's plot the no-migration-edge tree with the two-migration-edge tree, which optM chose as the best fit using the Evanno method.

```{r,fig.height = 4.5,fig.width=8}
par(mfrow=c(1,2),mar=c(1,1,1,2),oma=c(1,1,1,2),xpd=TRUE)
t0<-plot_tree("treemix/fwsw_k100bFLPBr",scale=T,mbar=F,cex = 1.5,
              lwd=2,mig_left=FALSE,disp=0.0002,xlab=FALSE,scadj=0.05)
t2<-plot_tree("treemix/fwsw_k100bFLPBrm2",scale=T,mbar=T,cex = 1.5,
              lwd=2,mig_left=FALSE,disp=0.0002,xlab=FALSE,scadj=0.05)

```


# Demographic history {-}

dadi analyses.

# Outliers 

## Stacks 

```{r stacks_fsts_swsw}
swsw.al<-read.delim("stacks/populations_subset75/all_pops_subset75/batch_2.fst_ALST-FLSG.tsv")
swsw.la<-read.delim("stacks/populations_subset75/all_pops_subset75/batch_2.fst_ALST-TXCB.tsv")
swsw.tx<-read.delim("stacks/populations_subset75/all_pops_subset75/batch_2.fst_TXCC-TXSP.tsv")
swsw.fl<-read.delim("stacks/populations_subset75/all_pops_subset75/batch_2.fst_FLCC-FLHB.tsv")
```

```{r assignplotpos}
assign.plotpos<-function(df, plot.scaffs, bounds, df.chrom="Chrom", df.bp="BP"){
  colnames(bounds)<-c("Chrom","End")
  new.dat<-data.frame(stringsAsFactors = F)
  last.max<-0
  for(i in 1:length(plot.scaffs)){
    #pull out the data for this scaffold
    if(nrow(bounds[bounds$Chrom %in% plot.scaffs[i],])>0){ #sanity check
      chrom.dat<-df[df[[df.chrom]] %in% plot.scaffs[i],]
      if(nrow(chrom.dat)>0){
        chrom.dat$plot.pos<-as.numeric(as.character(chrom.dat[[df.bp]]))+last.max
        new.dat<-rbind(new.dat,chrom.dat)
        #last.max<-max(chrom.dat$plot.pos)+
        #               as.numeric(scaffold.widths[scaffold.widths[,1] %in% scaffs.to.plot[i],2])
      }
      last.max<-last.max+
        as.numeric(bounds[bounds$Chrom %in% plot.scaffs[i],2])
    }
  }
  #make sure everything is the correct class
  new.dat$plot.pos<-as.numeric(as.character(new.dat$plot.pos))
  return(new.dat)
}
```
```{r perlglines}
perlg.add.lines<-function(fwsw.plot,lgs,width=NULL,lwds=4,color="cornflowerblue"){
 
  for(i in 1:length(lgs)){
    this.df<-fwsw.plot[fwsw.plot$Chr %in% lgs[i],]
    if(is.null(width)){
      width<-(nrow(this.df)*0.15)
    }
    this.smooth<-do.call("rbind",lapply(seq(1,nrow(this.df),width/5),sliding.avg,
                                        dat=data.frame(Pos=this.df$plot.pos,
                                                       Fst=this.df$Corrected.AMOVA.Fst),
                                        width=width))
    points(this.smooth,col=color,type="l",lwd=lwds)
  }
}
```


```{r plotmultiplelgs}
plot_multiple_LGs<-function(list_fsts,fst_name,chr_name,bp_name,lgs,plot_labs,pt_cols=NULL,plot_scaffs=NULL,addSmooth=TRUE,smoothFst="Smoothed.Fst",smoothcol="cornflowerblue",ncol=2,...){
  nrow<-length(list_fsts)/ncol
  
  # check the variables
  if(length(list_fsts)>1){
    if(length(fst_name)==1){
      fst_names<-rep(list(fst_name),length(list_fsts))
    }else if(length(list_fsts)==length(fst_name)){
      fst_names<-fst_name
    }else{
      print("ERROR: invalid fst_name")
      return(NULL)
    }
    if(length(chr_name)==1){
      chr_names<-rep(list(chr_name),length(list_fsts))
    }else if(length(list_fsts)==length(chr_name)){
      chr_names<-chr_name
    }else{
      print("ERROR: invalid chr_name")
      return(NULL)
    }
    if(length(bp_name)==1){
      bp_names<-rep(list(bp_name),length(list_fsts))
    }else if(length(list_fsts)==length(bp_name)){
      bp_names<-bp_name
    }else{
      print("ERROR: invalid bp_name")
      return(NULL)
    }
    if(length(smoothFst)==1){
      smoothFsts<-rep(list(smoothFst),length(list_fsts))
    }else if(length(list_fsts)==length(smoothFst)){
      smoothFsts<-smoothFst
    }else{
      print("ERROR: invalid smoothFst")
      return(NULL)
    }
    if(!is.null(pt_cols)){ #if it's not null, then need to check it's a list
      if(length(pt_cols)==1){
        pch_cols<-rep(list(pt_cols),length(list_fsts))
      }else if(length(list_fsts)==length(pt_cols)){
        pch_cols<-pt_cols
      }else{
        print("WARNING: invalid pt_cols, using defaults")
        pch_cols<-c("darkgrey","lightgrey")
      }
    }
  }
  if(length(plot_labs) != length(list_fsts) | is.null(plot_labs)){
    print("WARNING: invalid plot labels (plot_labs). Omitting plot labels")
    plot_labs<-rep(list(""),length(list_fsts))
  }
  
  # aggregate data
  all_chr<-data.frame(Chr=unlist(lapply(list_fsts,function(x){ as.character(x[,chr_name])})),
                      BP=unlist(lapply(list_fsts,function(x){ as.character(x[,bp_name])})),stringsAsFactors = F)
  bounds<-tapply(as.numeric(as.character(all_chr$BP)), all_chr$Chr,max)
  bounds<-data.frame(Chrom=dimnames(bounds),End=bounds)
  colnames(bounds)<-c("Chrom","End")
  if(is.null(plot_scaffs)){
    plot_scaffs<-levels(bounds$Chr)
    plot_scaffs[1:22]<-lgs
  }
  bounds<-bounds[match(plot_scaffs,bounds$Chrom),]
  
  #Plot
  if(nrow*ncol < length(list_fsts)) nrow<-nrow+1
  par(mfrow=c(nrow,ncol),mar=c(3,3,2,2),oma=c(2,2,2,2))
  fsts<-mapply(function(f, fst,bp,chr,cols, plot_lab,smF,plot_scaffs,bounds,smoothcol,...){

    fst<-fst.plot(f,fst.name = fst, bp.name = bp,chrom.name = chr, 
                    scaffs.to.plot=plot_scaffs, scaffold.widths = bounds,
                    pt.cols = cols,...) #pch=19,y.lim = c(0,1),pt.cex=1,axis.size = 1
    
    if(addSmooth==TRUE) points(fst$plot.pos,fst[,smF],col=smoothcol,type="l") 
    
    clip(0,max(fst$plot.pos),0,1)
    
    mtext(plot_lab,2,cex=0.75)#,line=-1)
    labs<-tapply(fst$plot.pos,fst[,chr],median)
    text(x=labs[lgs],y=-0.1,labels=lgn,xpd=TRUE)
    
    return(fst)
  },f=list_fsts,fst=fst_names,bp=bp_names,chr=chr_names,cols=pch_cols,plot_lab=plot_labs,smF=smoothFsts,MoreArgs = list(plot_scaffs=plot_scaffs,bounds=bounds, smoothcol=smoothcol,...))
  return(fsts)
}
```
```{r plot_stacks_fsts_swsw}
fst_dat<-list(swsw.al,swsw.la,swsw.tx,swsw.fl)
fsts<-plot_multiple_LGs(list_fsts = fst_dat,fst_name = "Corrected.AMOVA.Fst",bp_name="BP",chr_name="Chr",
                        lgs=lgs,plot_labs=list("ALST vs FLSG","ALST vs TXCC","TXSP vs TXCC","FLHB vs FLCC"),
                        pt_cols = list(c(grp.colors[3],grp.colors[2]),c(grp.colors[2],grp.colors[3]),
                                       c(grp.colors[1],grp.colors[2]),c(grp.colors[6],grp.colors[5])),
                        ncol=1,addSmooth = FALSE,pch=19,y.lim = c(0,1),pt.cex=1,axis.size = 1)
```

So this generated a plot for each pairwise comparison. We could look for shared outliers and see if we can find anything.

```{r get_stacks_sig_swsw}
tx.sig<-swsw.tx[swsw.tx$Fisher.s.P<0.01,"Locus.ID"]
la.sig<-swsw.la[swsw.la$Fisher.s.P<0.01,"Locus.ID"]
al.sig<-swsw.al[swsw.al$Fisher.s.P<0.01,"Locus.ID"]
fl.sig<-swsw.fl[swsw.fl$Fisher.s.P<0.01,"Locus.ID"]
all.shared<-fl.sig[fl.sig %in% la.sig & fl.sig %in% al.sig & fl.sig %in% tx.sig]
```

There are `r length(unique(all.shared))` outliers (as determined by Fisher's P from stacks < 0.01).

These results can be compared to pairwise freshwater-saltwater comparisons

```{r stacks_fsts}
fwsw.al<-read.delim("stacks/populations_subset75/batch_2.fst_ALFW-ALST.tsv")
fwsw.la<-read.delim("stacks/populations_subset75/batch_2.fst_ALST-LAFW.tsv")
fwsw.tx<-read.delim("stacks/populations_subset75/batch_2.fst_TXCC-TXFW.tsv")
fwsw.fl<-read.delim("stacks/populations_subset75/batch_2.fst_FLCC-FLFW.tsv")
```

```{r plot_stacks_fsts}
fst_dat<-list(fwsw.al,fwsw.la,fwsw.tx,fwsw.fl)
fsts<-plot_multiple_LGs(list_fsts = fst_dat,fst_name = "Corrected.AMOVA.Fst",bp_name="BP",chr_name="Chr",
                        lgs=lgs,plot_labs=list("ALFW vs ALST","ALST vs LAFW","TXFW vs TXCC","FLFW vs FLCC"),
                        pt_cols = list(c(grp.colors[3],grp.colors[2]),c(grp.colors[2],grp.colors[3]),
                                       c(grp.colors[1],grp.colors[2]),c(grp.colors[6],grp.colors[5])),
                        ncol=1,addSmooth = FALSE,pch=19,y.lim = c(0,1),pt.cex=1,axis.size = 1)
```
```{r get_stacks_sig}
tx.sig<-fwsw.tx[fwsw.tx$Fisher.s.P<0.01,"Locus.ID"]
la.sig<-fwsw.la[fwsw.la$Fisher.s.P<0.01,"Locus.ID"]
al.sig<-fwsw.al[fwsw.al$Fisher.s.P<0.01,"Locus.ID"]
fl.sig<-fwsw.fl[fwsw.fl$Fisher.s.P<0.01,"Locus.ID"]
all.shared<-fl.sig[fl.sig %in% la.sig & fl.sig %in% al.sig & fl.sig %in% tx.sig]
```

There are `r length(unique(all.shared))` outliers (as determined by Fisher's P from stacks < 0.01) 


## PCAdapt

For this analysis, to maintain consistency with the other outlier analyses, I'm using the subestted dataset. So I need to run PCAdapt [@luu_pcadapt:_2017] another time.


```{r}
library(pcadapt)
#pap<-read.delim("pca_pcadapt.txt",sep=" ")
#snp_info<-read.delim("subset.map",header=FALSE)

filename<-read.pcadapt("pcadapt_fw/fwsw.pruned.vcf",type="vcf") #need to remove the first line with a # 
x<-pcadapt(filename, K=20)
plot(x,option="screeplot")
```

*K=4* seems like the best choice here to keep values to the left of the straight line. 

```{r}
# Organize pop info
vcf<-parse.vcf("pcadapt_fw/fwsw.pruned.vcf")
pops<-gsub("sample_(\\w{4}).*","\\1",colnames(vcf)[10:ncol(vcf)])	
grp<-pops
grp[grp=="TXFW" | grp=="LAFW" | grp=="ALFW" | grp=="FLLG"]<-"freshwater"
grp[grp!="freshwater"]<-"saltwater"
```


```{r}
res<-pcadapt(filename,K=4)
par(mfrow=c(2,2))
plot(res, option="manhattan")
plot(res, option="qqplot")
plot(res, option="stat.distribution")
plot(res, option="scores",pop=pops)
```

The vignette recommends displaying the loadings and evaluate if loadings are clustered in single or several genomic regions

```{r}
par(mfrow = c(2, 2))
for (i in 1:4)
  plot(res$loadings[, i], pch = 19, cex = .3, ylab = paste0("Loadings PC", i))
```

This suggests that loadings are not clustered (assuming these are grouped by space), so we don't need to worry about LD thinning. Now let's look chromosome by chromosome:

```{r}
par(mfrow=c(6,4),mar=c(3,3,2,1.5))
l<-lapply(lgs, function(lg,vcf){
  plot(res$loadings[which(vcf$`#CHROM` %in% lg), 1], pch = 19, cex = .3, xlab = paste0("Position on ", lg), ylab = "Loadings PC 1")
  mtext(lg,3,outer=FALSE)
},vcf=vcf)
```

None of the LGs seem to have huge clusters of outliers so we can move on, lumping them all together.

We need to choose a cutoff for outlier detection. I'll use the qvalue approach, which identifies outliers with a false discovery rate of $\alpha$, which I'm setting here to 0.05.

```{r}
library(qvalue)
qval <- qvalue(res$pvalues)$qvalues
alpha <- 0.05
outliers <- which(qval < alpha)
snp_pc<-get.pc(res,outliers) # Get the PCs associated with outliers
```

We identified `r length(outliers)` outliers with this analysis, which are associated with `r length(unique(snp_pc$PC))` of the 4 clusters. If we look at the distribution of these, though, we see that most are associated with PC 1

```{r}
summary(as.factor(snp_pc$SNP))
```



## Bayenv


Investigate the environmental data

```{r compareEnvVar}
env.data<-read.csv("bayenv/env_data_raw.csv",row.names = 1)
env.data<-rbind(env.data,pop=c(rep("SW",12),rep("FW",4)))
env.data<-as.data.frame(t(env.data))
wilcox.test(as.numeric(env.data$temp)~env.data$pop) #ties, but p=0.539
wilcox.test(as.numeric(env.data$seagrass)~env.data$pop) #ties, but p=0.897
```

Here are all of the matrices - I randomly chose one of them to analyse.

[!Bayenv matrices]("bayenv/fwsw75_pruned.png")

The rest of the results are in Fig. 3. 

## Annotating shared outliers

I can do this.

# References
