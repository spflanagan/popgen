---
title: "Revising FWSW paper"
author: "Sarah P. Flanagan"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document: default
  pdf_document:
    fig_caption: yes
graphics: yes
editor_options:
  chunk_output_type: console
description: Re-analyzing the freshwater-saltwater data based on reviewer comments (2018)
---

The initial analyses are in `200_fwsw_analysis.Rmd` and conducted the analyses on a dataset generated from comparing lumped 'freshwater' and 'saltwater' populations, containing SNPs found in 50% of individuals and with a minor allele frequency of at least 5%. The revised paper will instead focus on two datasets:

1. A set of all 16 populations, generated from all pairwise comparisons of populations, containing SNPs found in 4 populations, in 75% of individuals, and with a minor allele frequency of at least 5%. ("P4" or "subset")
2. A set containing only the 4 freshwater populations (TXFW, LAFW, ALFW, FLFW) and their 4 nearest saltwater populations (TXCC, ALST, ALST, FLCC)

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,out.extra='',fig.pos="H")
knitr::opts_knit$set(root.dir='./fwsw_results/')
```
```{r source}
source("../../gwscaR/R/gwscaR.R")
source("../../gwscaR/R/gwscaR_plot.R")
source("../../gwscaR/R/gwscaR_utility.R")
source("../../gwscaR/R/gwscaR_fsts.R")
source("../../gwscaR/R/gwscaR_popgen.R")
source("../../gwscaR/R/vcf2dadi.R")
source("../R/203_treemix_plotting_funcs.R")#I've modified these functions
library(knitr)
library(scales)
```

```{r}
pop.list<-c("TXSP","TXCC","TXFW","TXCB","LAFW","ALST","ALFW","FLSG","FLKB",
	"FLFD","FLSI","FLAB","FLPB","FLHB","FLCC","FLLG")
pop.labs<-c("TXSP","TXCC","TXFW","TXCB","LAFW","ALST","ALFW","FLSG","FLKB",
            "FLFD","FLSI","FLAB","FLPB","FLHB","FLCC","FLFW")
fw.list<-c("TXFW","LAFW","ALFW","FLLG")
sw.list<-c("TXSP","TXCC","TXCB","ALST","FLSG","FLKB",
	"FLFD","FLSI","FLAB","FLPB","FLHB","FLCC")
lgs<-c("LG1","LG2","LG3","LG4","LG5","LG6","LG7","LG8","LG9","LG10","LG11",
	"LG12","LG13","LG14","LG15","LG16","LG17","LG18","LG19","LG20","LG21",
	"LG22")
lgn<-seq(1,22)
all.colors<-c(rep("black",2),"#2166ac","black","#2166ac","black","#2166ac",
        rep("black",8),"#2166ac")
#grp.colors<-c('#e41a1c','#377eb8','#4daf4a','#984ea3','#ffff33','#f781bf')
grp.colors<-c('#762a83','#af8dc3','#e7d4e8','#d9f0d3','#7fbf7b','#1b7837')
col_vector<-c(red='#e6194b', green='#3cb44b', blue='#4363d8',yellow='#ffe119', cyan='#46f0f0',orange='#f58231', teal='#008080', purple='#911eb4',  magenta='#f032e6', lime='#bcf60c', pink='#fabebe',  lavendar='#e6beff', brown='#9a6324', olive='#808000', apricot='#ffd8b1',maroon='#800000', mint='#aaffc3', navy='#000075', beige='#fffac8', grey='#808080', white='#ffffff', black='#000000')

col_vector<-c('#762a83','#762a83',"#2166ac",'#762a83',"#2166ac",'#af8dc3',"#2166ac",'#e7d4e8','#e7d4e8','#e7d4e8','#e7d4e8','#7fbf7b','#1b7837','#1b7837','#1b7837',"#2166ac")
#ppi<-data.frame(Pop=pop.labs,cols = all.colors,pch=c(0,1,21,2,24,3,23,4,5,6,7,9,10,11,12,22))
ppi<-data.frame(Pop=pop.labs,cols = col_vector,pch=rep(c(15,16,17,18),4))
```


# Map of the populations

First, we'll plot these populations on a map

```{r map_setup, eval=FALSE}
library(maps);library(gplots);library(mapdata)
mar.coor<-read.csv("marine_coordinates_revised.csv", header=T)
fw.coor<-read.csv("fw_coordinates.csv", header=T)

```
```{r map}
jpeg("all_sites_map.jpeg", res=300, height=7,width=14, units="in")
#pdf("all_sites_map.pdf",height=7,width=14)
par(oma=c(0,0,0,0),mar=c(0,0,0,0),pin=c(7,7))
map("worldHires", "usa",xlim=c(-100,-76), ylim=c(24,32), 
	col="gray90", mar=c(0,0,0,0),fill=TRUE, res=300,myborder=0)
map("worldHires", "mexico",xlim=c(-100,-76), ylim=c(24,32), 
	col="gray95", fill=TRUE, add=TRUE)
points(mar.coor$lon, mar.coor$lat,  col="black", cex=2, pch=19)
points(-1*fw.coor$lon, fw.coor$lat,  col="cornflowerblue", cex=2, pch=18)
abline(h=c(25,30,35),lty=3)
abline(v=c(-80,-85,-90,-95),lty=3)
text(x=c(-99.5,-99.5),y=c(25,30),c("25N","30N"),cex=1.75)
text(x=c(-80,-85,-90,-95),y=rep(31.8,4),c("80W","85W","90W","95W"),cex=1.75)
text(y=26,x=-90,"Gulf of Mexico",cex=1.75)
text(y=25.5,x=-98.5,"Mexico",cex=1.75)
text(x=-91,y=31,"USA",cex=1.75)
text(x=-78,y=29.5,"Atlantic Ocean",cex=1.75)
text(x=-96.4,y=26,"TXSP",font=2,cex=1.75)
text(x=-96.6,y=27.2,"TXCC",font=2,cex=1.75)
text(x=-95.6,y=28.3,"TXFW",font=2,col="cornflowerblue",cex=1.75)
text(x=-94.4,y=29,"TXCB",font=2,cex=1.75)
text(x=-90.5,y=29.8,"LAFW",font=2,col="cornflowerblue",cex=1.75)
text(x=-88,y=30,"ALST",font=2,cex=1.75)
text(x=-87,y=30.75,"ALFW",font=2,col="cornflowerblue",cex=1.75)
text(x=-85,y=29.4,"FLSG",font=2,cex=1.75)
text(x=-83.7,y=29,"FLKB",font=2,cex=1.75)
text(x=-83.4,y=27.6,"FLFD",font=2,cex=1.75)
text(x=-82.4,y=26,"FLSI",font=2,cex=1.75)
text(x=-79.9,y=24.8,"FLAB",font=2,cex=1.75)
text(x=-79.2,y=26.8,"FLPB",font=2,cex=1.75)
text(x=-79.4,y=27.2,"FLHB",font=2,cex=1.75)
text(x=-79.9,y=28.5,"FLCC",font=2,cex=1.75)
text(x=-80.9,y=29.5,"FLFW",font=2,col="cornflowerblue",cex=1.75)
dev.off()

```


## Table of summary statistics


```{r}
pop_map<-read.delim("../fwsw_pops_map.txt",header = FALSE,stringsAsFactors = FALSE)
ful_vcf<-parse.vcf("filter_rad_20191014@1654/14_filtered/radiator_data_20191014@1710.vcf")
colnames(ful_vcf)<-gsub("\\-","_",colnames(ful_vcf))
sub_vcf<-parse.vcf("stacks/populations_subset75/batch_2.pruned.vcf")
sub_all_vcf<-parse.vcf("stacks/populations_subset75/all_pops_subset75/batch_2.vcf")
# combine the two
sub<-merge(sub_vcf,sub_all_vcf,by="ID",all = TRUE)
rmv<-grep(".y",colnames(sub))
sub<-sub[,-rmv]
colnames(sub)<-gsub(".x","",colnames(sub))
```

```{r}
pop_summaries<-do.call(rbind,lapply(pop.list,function(pop,ful,sub){
  ful_dat<-ful[,c(1:9,grep(pop,colnames(ful)))]
  sub_dat<-sub[,c(1:9,grep(pop,colnames(sub)))]
  # calc observed het values
  ful_ho<-apply(ful_dat,1,calc.het)
  sub_ho<-apply(sub_dat,1,calc.het)
  # estimate allele freqs
  ful_afs<-do.call(rbind,apply(ful_dat,1,calc.afs.vcf))
  sub_afs<-do.call(rbind,apply(sub_dat,1,calc.afs.vcf))
  # save data frame
  dat<-data.frame(pop=pop,
                  preg_full=length(grep(paste0(pop,"P"),colnames(ful))),
                  preg_sub=length(grep(paste0(pop,"P"),colnames(sub))),
                  nonp_full=length(grep(paste0(pop,"NP"),colnames(ful))),
                  nonp_sub=length(grep(paste0(pop,"NP"),colnames(sub))),
                  nfem_full=length(grep(paste0(pop,"F"),colnames(ful))),
                  nfem_sub=length(grep(paste0(pop,"F"),colnames(sub))),
                  njuv_full=length(grep(paste0(pop,"J"),colnames(ful)))+
                    length(grep(paste0(pop,"DB"),colnames(ful))),
                  njuv_sub=length(grep(paste0(pop,"J"),colnames(sub))) + 
                    length(grep(paste0(pop,"DB"),colnames(sub))),
                  ho_full = mean(ful_ho,na.rm = TRUE),
                  hov_full = var(ful_ho,na.rm = TRUE),
                  ho_sub = mean(sub_ho,na.rm = TRUE),
                  hov_sub = var(sub_ho,na.rm = TRUE),
                  poly_ful = nrow(ful_afs[ful_afs$RefFreq<1,])/nrow(ful_afs)*100,
                  poly_sub = nrow(sub_afs[sub_afs$RefFreq<1,])/nrow(sub_afs)*100,
                  p_full = mean(ful_afs$RefFreq,na.rm=TRUE),
                  pv_full = var(ful_afs$RefFreq,na.rm=TRUE),
                  p_sub = mean(sub_afs$RefFreq,na.rm=TRUE),
                  pv_sub = var(sub_afs$RefFreq,na.rm=TRUE))
  return(dat)
},ful=ful_vcf,sub=sub))
write.csv(pop_summaries,"population_summaries.csv",row.names = FALSE,quote=FALSE)
```

We can merge the genetic info with the environmental info. 
```{r}

```


## Population structure of all 16 populations

### FSTs

This will calculate the pairwise Fsts (but it's slow)

```{r, eval=FALSE}
pop_map<-read.delim("../fwsw_pops_map.txt",header = FALSE,stringsAsFactors = FALSE)
fst_mat<-matrix(NA,
                nrow=length(unique(pop_map$V2)),ncol=length(unique(pop_map$V2)),
                dimnames = list(pop.list,pop.list))
vcf<-parse.vcf("filter_rad_20191014@1654/14_filtered/radiator_data_20191014@1710.vcf")
colnames(vcf)<-gsub("\\-","_",colnames(vcf)) # fix individual names
# loop through each population pair
for(i in 1:(nrow(fst_mat)-1)){
  for(j in (i+1):ncol(fst_mat)){
    
    if(rownames(fst_mat)[i] != colnames(fst_mat)[j]){ # sanity check
      map1<-pop_map[pop_map[,2]==rownames(fst_mat)[i],]
      map2<-pop_map[pop_map[,2]==colnames(fst_mat)[j],]
      pwfsts<-gwsca(vcf,colnames(vcf)[1:9],map1[,1],map2[,1])
      fst_mat[i,j]<-mean(pwfsts$Fst,na.rm = TRUE)
    }
  }
}
colnames(fst_mat)<-rownames(fst_mat)<-pop.labs
write.table(fst_mat,"pairwise_fsts_full.txt",sep='\t',col.names = TRUE,row.names=TRUE,quote=FALSE)
```

```{r}
full_fsts<-read.delim("stacks/populations_whitelist/batch_2.fst_summary.tsv",row.names = 1)
full_fsts<-rbind(full_fsts,TXSP=rep(NA,ncol(full_fsts))) #add the final row
Tfull_fsts<-t(full_fsts)
full_fsts[lower.tri(full_fsts)]<-Tfull_fsts[lower.tri(Tfull_fsts)] # now it's symmetric
full_fsts<-full_fsts[pop.list,pop.list]
colnames(full_fsts)<-rownames(full_fsts)<-pop.labs
fst_mat<-as.matrix(full_fsts)
```


```{r}
library(lattice); library(grid); library(RColorBrewer)
poporder<-read.delim("treemix/poporder")
colors<-poporder$colors
poporder<-poporder$poporder

nr<-treemix.cov.plot("treemix/fwsw_k100b",poporder)
dimnames(nr)[[1]]<-dimnames(nr)[[2]]<-pop.labs
# colors
colors<-c("black","darkgrey","grey","lightgrey","cornflowerblue")
pal<-colorRampPalette(colors)
ncol=80
cols<-pal(ncol)
rev.colors<-c("cornflowerblue","lightgrey","grey","darkgrey","black")
rev.pal<-colorRampPalette(rev.colors)
rev.cols<-rev.pal(ncol)

hm.height<-list(x=2,units="in")#2.2/3.8
hm.width<-list(x=2.4,units="in")#2.4 in RStudio/3.9

heatmaps.name<-"../figs/fst_heatmaps.png"

png(heatmaps.name,height=5,width=8,units="in",res=300)

fst.lv<-levelplot(as.matrix(fst_mat),col.regions=cols,alpha.regions=0.7,
                  scales = list(x=list(rot=90),tck = 0),xlab="",ylab="")
print(fst.lv,split=c(1,1,2,1),more=TRUE,panel.width=hm.width,
      panel.height=hm.height,cex=2)
trellis.focus("legend", side="right", clipp.off=TRUE, highlight=FALSE)
grid.text(expression(italic(F)[ST]), 0.2, 0, hjust=0.5, vjust=1.2,gp=gpar(cex=0.75))
trellis.unfocus()

nr.lv<-levelplot(nr,col.regions=cols,alpha.regions=0.7,
                 scales = list(x=list(rot=90),tck = 0),xlab="",ylab="")
print(nr.lv,split=c(2,1,2,1),more=FALSE,newpage=FALSE,panel.width=hm.width,
      panel.height=hm.height,cex=2)
trellis.focus("legend", side="right", clipp.off=TRUE, highlight=FALSE)
grid.text("Treemix", 0.2, 0, hjust=0.5, vjust=1.2,gp=gpar(cex=0.75))
trellis.unfocus()

dev.off()

```

[!Heatmaps]("../figs/fst_heatmaps.png")


### PCAdapt


```{r}
library(pcadapt)
```

````{r pcadapt_choose}
filename<-read.pcadapt("filter_rad_20191014@1654/14_filtered/radiator_data_20191014@1710.vcf",type="vcf")
x<-pcadapt(filename, K=20)
plot(x,option="screeplot") #K=7
```

```{r pcadapt_analyze}
pa<-pcadapt(filename,K=7)
saveRDS(pa,"fwsw_all_pcadapt.RDS")
pa.props<-round((pa$singular.values/sum(pa$singular.values))*100,2)
pa.props

ind_dat<-read.table("filter_rad_20191014@1654/14_filtered/individuals.qc.stats_20191014@1654.tsv",header=T,
                    stringsAsFactors = F)
pops<-ind_dat$STRATA	
grp<-pops
grp[grp=="TXFW" | grp=="LAFW" | grp=="ALFW" | grp=="FLLG"]<-"freshwater"
grp[grp!="freshwater"]<-"saltwater"

#colors
pap<-data.frame(Pop=pops,cols=pops,pch=pops,grp=grp,stringsAsFactors = F)
pap$Pop[pap$Pop == "FLLG"]<-"FLFW"
for(i in 1:nrow(pap)){
  pap[i,"cols"]<-as.character(ppi[ppi$Pop %in% pap[i,"Pop"],"cols"])
}
for(i in 1:nrow(pap)){
  pap[i,"pch"]<-as.numeric(ppi[ppi$Pop %in% pap[i,"Pop"],"pch"])
}
write.table(pap,"pcadapt_colp.txt",col.names=TRUE,sep='\t',quote=F)

```


```{r plot_pcadapt_initial, fig.height=8,fig.width=10.5,fig.path="../figs/pcadapt.pc1-6",dev=c('png', 'pdf'),fig.dim="in"}

#plot
par(mfrow=c(2,3),oma=c(2,2,2,2),mar=c(2,2,2,2))
plot(pa$scores[,1],pa$scores[,2],col=alpha(pap$cols,0.5),bg=alpha(pap$cols,0.75),
     pch=as.numeric(pap$pch),	cex=1.5)
mtext(paste("PC1 (",pa.props[1],"%)",sep=""),1,line = 2,cex=0.75)
mtext(paste("PC2 (",pa.props[2],"%)",sep=""),2,line = 2,cex=0.75)
plot(pa$scores[,1],pa$scores[,3],col=alpha(pap$cols,0.5),bg=alpha(pap$cols,0.75),pch=as.numeric(pap$pch),
	cex=1.5)
mtext(paste("PC1 (",pa.props[1],"%)",sep=""),1,line = 2,cex=0.75)
mtext(paste("PC3 (",pa.props[3],"%)",sep=""),2,line = 2,cex=0.75)
plot(pa$scores[,1],pa$scores[,4],col=alpha(pap$cols,0.5),bg=alpha(pap$cols,0.75),pch=as.numeric(pap$pch),
	cex=1.5)
mtext(paste("PC1 (",pa.props[1],"%)",sep=""),1,line = 2,cex=0.75)
mtext(paste("PC4 (",pa.props[4],"%)",sep=""),2,line = 2,cex=0.75)
plot(pa$scores[grp=="freshwater",1],pa$scores[grp=="freshwater",2],
     col=alpha(pap$cols[pap$grp=="freshwater"],0.5),
     bg=alpha(pap$cols[pap$grp=="freshwater"],0.75),pch=as.numeric(pap$pch[pap$grp=="freshwater"]),
	cex=1.5)
mtext(paste("PC1 (",pa.props[1],"%)",sep=""),1,line = 2,cex=0.75)
mtext(paste("PC2 (",pa.props[2],"%)",sep=""),2,line = 2,cex=0.75)
plot(pa$scores[grp=="freshwater",3],pa$scores[grp=="freshwater",4],
     col=alpha(pap$cols[pap$grp=="freshwater"],0.5),
     bg=alpha(pap$cols[pap$grp=="freshwater"],0.75),pch=as.numeric(pap$pch[pap$grp=="freshwater"]),
	cex=1.5)
mtext(paste("PC3 (",pa.props[3],"%)",sep=""),1,line = 2,cex=0.75)
mtext(paste("PC4 (",pa.props[4],"%)",sep=""),2,line = 2,cex=0.75)
plot(pa$scores[grp=="freshwater",5],pa$scores[grp=="freshwater",6],
     col=alpha(pap$cols[pap$grp=="freshwater"],0.5),
     bg=alpha(pap$cols[pap$grp=="freshwater"],0.75),pch=as.numeric(pap$pch[pap$grp=="freshwater"]),
	cex=1.5)
mtext(paste("PC5 (",pa.props[5],"%)",sep=""),1,line = 2,cex=0.75)
mtext(paste("PC6 (",pa.props[2],"%)",sep=""),2,line = 2,cex=0.75)

par(fig = c(0, 1, 0, 1), oma=c(2,1,0,1), mar = c(0, 0, 0, 0), new = TRUE,
	cex=1)
plot(0, 0, type = "n", bty = "n", xaxt = "n", yaxt = "n")

legend("top", legend=ppi$Pop, pch=as.numeric(ppi$pch), pt.cex=1.5,cex=0.85,
       col=alpha(ppi$cols, 0.5),pt.bg=alpha(ppi$cols,0.25), ncol=8,bty='n')

```


### Admixture


```{r}
admixK<-read.delim("admixture/K_CVs.txt",header = FALSE)
admixK$K<-as.numeric(gsub(".*\\(K=(\\d+)\\).*","\\1",admixK$V1))
admixK$CV<-as.numeric(gsub("^.*\\: (\\d+\\.\\d+)$","\\1",admixK$V1))

admixK<-admixK[order(admixK$K),]

plot(admixK$K,admixK$CV,pch=19,type = "b",lty=1,xlab = "K",ylab="CV",las=1,lwd=2)

```

Looks like K=5 or K=7 are the best, let's look at those outputs.


```{r}
library(RColorBrewer)
qfile<-"admixture/fwsw_all_filt.5.Q"
famfile<-"admixture/fwsw_all_filt.fam"
poporderFile<-"treemix/poplist"
K<-5

# read files in 
qtbl<-read.table(qfile,stringsAsFactors = F)
famTable<- read.table(famfile,
                      col.names = c("Pop","Ind","Father","Mother","Sex","phenotype"),stringsAsFactors = F)[1:2]
poporder<-read.table(poporderFile,col.names = c("Pop"),stringsAsFactors = F)
poporder$orderNum<-1:nrow(poporder)


# create useful tables
mergedAdmixtureTable <- cbind(qtbl, famTable)
mergedAdmixTabOrderNs <- merge(mergedAdmixtureTable,poporder,by="Pop")
ordered <- mergedAdmixTabOrderNs[order(mergedAdmixTabOrderNs$orderNum),]


plotting.structure(ordered[,1:(ncol(ordered)-2)],k = 5,pop.order = poporder$Pop,make.file = FALSE)
admixK5<-ordered[,1:(ncol(ordered)-2)]
write.table(admixK5,"admixture/admixK5.txt",sep = '\t',quote = FALSE,col.names = TRUE,row.names = FALSE)
```

```{r}
qfile<-"admixture/fwsw_all_filt.7.Q"
famfile<-"admixture/fwsw_all_filt.fam"
poporderFile<-"treemix/poplist"
K<-7

# read files in 
qtbl<-read.table(qfile,stringsAsFactors = F)
famTable<- read.table(famfile,
                      col.names = c("Pop","Ind","Father","Mother","Sex","phenotype"),stringsAsFactors = F)[1:2]
poporder<-read.table(poporderFile,col.names = c("Pop"),stringsAsFactors = F)
poporder$orderNum<-1:nrow(poporder)


# create useful tables
mergedAdmixtureTable <- cbind(qtbl, famTable)
mergedAdmixTabOrderNs <- merge(mergedAdmixtureTable,poporder,by="Pop")
ordered <- mergedAdmixTabOrderNs[order(mergedAdmixTabOrderNs$orderNum),]

par(mar=c(1,0,0,0))
plotting.structure(ordered[,1:(ncol(ordered)-2)],k = 7,pop.order = poporder$Pop,make.file = FALSE)
admixK7<-ordered[,1:(ncol(ordered)-2)]
plotting.structure(admixK7,k = 7,pop.order = poporder$Pop,make.file = FALSE)
write.table(admixK7,"admixture/admixK7.txt",sep = '\t',quote = FALSE,col.names = TRUE,row.names = FALSE)
```


### Treemix


```{r}
poporder<-c("TXSP","TXCC","TXFW","TXCB","LAFW","ALST",
            "ALFW","FLSG","FLKB","FLFD","FLSI","FLAB",
            "FLPB","FLHB","FLCC","FLLG")
colors<-poporder
colors[colors %in% "FLLG"]<-grp.colors[6]
colors[colors %in% c("FLPB","FLHB","FLCC")]<-grp.colors[6]
colors[colors %in% c("FLAB")]<-grp.colors[5]
colors[colors %in% c("FLSI","FLFD","FLKB","FLSG")]<-grp.colors[3]
colors[colors %in% c("ALST","ALFW","LAFW")]<-grp.colors[2]
colors[colors %in% c("TXSP","TXCC","TXFW","TXCB")]<-grp.colors[1]
write.table(cbind(poporder,colors),"poporder",quote=F,sep='\t')
```

```{r}
source("../R/203_treemix_plotting_funcs.R") #I've modified the functions from treemix
library(lattice); library(grid); library(RColorBrewer)
poporder<-read.delim("treemix/poporder")
colors<-poporder$colors
poporder<-poporder$poporder
par(mfrow=c(1,2),oma=c(2,2,2,2),mar=c(2,2,2,2))
tree<-plot_tree("treemix/fwsw_k100b",plotmig=F,scale=F,mbar=F,plus=0.05)
mtext("Drift parameter",1,line=2)
resid<-plot_resid("treemix/fwsw_k100b","treemix/poporder",wcols="rb")

# nr<-treemix.cov.plot("treemix/fwsw_k100b",poporder)
# m0<-treemix.cov.plot("treemix/fwsw_k100bFLPBr",poporder,split=c(1,1,3,2),more=TRUE)
# m1<-treemix.cov.plot("treemix/fwsw_k100bFLPBrm1",poporder,split=c(2,1,3,2),more=TRUE)
# m2<-treemix.cov.plot("treemix/fwsw_k100bFLPBrm2",poporder,split=c(3,1,3,2),more=TRUE)
# m3<-treemix.cov.plot("treemix/fwsw_k100bFLPBrm3",poporder,split=c(1,2,3,2),more=TRUE)
# m4<-treemix.cov.plot("treemix/fwsw_k100bFLPBrm4",poporder,split=c(2,2,3,2),more=TRUE)
# m5<-treemix.cov.plot("treemix/fwsw_k100bFLPBrm5",poporder,split=c(3,2,3,2),more=FALSE)

# visualize residuals
png("treemix/treemix-residuals_FLPB.png",height=8,width=8,units="in",res=300)
par(mfrow=c(3,3))
t0<-plot_resid("treemix/fwsw_k100b",  "treemix/poplist")
r0<-plot_resid("treemix/fwsw_k100bFLPBr",  "treemix/poplist")
r1<-plot_resid("treemix/fwsw_k100bFLPBrm1","treemix/poplist")
r2<-plot_resid("treemix/fwsw_k100bFLPBrm2","treemix/poplist")
r3<-plot_resid("treemix/fwsw_k100bFLPBrm3","treemix/poplist")
r4<-plot_resid("treemix/fwsw_k100bFLPBrm4","treemix/poplist")
r5<-plot_resid("treemix/fwsw_k100bFLPBrm5","treemix/poplist")
dev.off()

# look at the trees
png("treemix/migration_trees_treemix_FLPB.png",height=6,width=11,units="in",res=300)
par(mfrow=c(3,3),mar=c(1,1,1,1),oma=c(1,1,1,1))
r0<-plot_tree("treemix/fwsw_k100b",plus=0.05,plotmig = F,scale=T,mbar=T)
t0<-plot_tree("treemix/fwsw_k100bFLPBr",plotmig = F,plus=0.05,scale=T,mbar=F)
t1<-plot_tree("treemix/fwsw_k100bFLPBrm1",plus=0.05,scale=F,mbar=F)
t2<-plot_tree("treemix/fwsw_k100bFLPBrm2",plus=0.05,scale=F,mbar=F)
t3<-plot_tree("treemix/fwsw_k100bFLPBrm3",plus=0.05,scale=F,mbar=F)
t4<-plot_tree("treemix/fwsw_k100bFLPBrm4",plus=0.05,scale=F,mbar=F)
t5<-plot_tree("treemix/fwsw_k100bFLPBrm5",plus=0.05,scale=F,mbar=F)
dev.off()

# Evaluate migration p-values
nort0<-read.table(gzfile("treemix/fwsw_k100b.treeout.gz"), as.is  = T, comment.char = "", quote = "")
tree0<-read.table(gzfile("treemix/fwsw_k100bFLPBr.treeout.gz"), as.is  = T, comment.char = "", quote = "")
tree1<-read.table(gzfile("treemix/fwsw_k100bFLPBrm1.treeout.gz"), as.is  = T, comment.char = "", quote = "",skip=1)
tree2<-read.table(gzfile("treemix/fwsw_k100bFLPBrm2.treeout.gz"), as.is  = T, comment.char = "", quote = "",skip=1)
tree3<-read.table(gzfile("treemix/fwsw_k100bFLPBrm3.treeout.gz"), as.is  = T, comment.char = "", quote = "",skip=1)
tree4<-read.table(gzfile("treemix/fwsw_k100bFLPBrm4.treeout.gz"), as.is  = T, comment.char = "", quote = "",skip=1)
tree5<-read.table(gzfile("treemix/fwsw_k100bFLPBrm5.treeout.gz"), as.is  = T, comment.char = "", quote = "",skip=1)

d <- read.table("fwsw.k100bFLPBrm3.vertices.gz", as.is  = T, comment.char = "", quote = "")
branch.cols<-rep("black",nrow(d))
branch.cols[d[,2] %in% c("TXFW","ALFW","LAFW","FLLG")]<-"cornflowerblue"

tip.names<-as.vector(d[d[,5] == "TIP",2])
tip.names<-data.frame(Original=tip.names,Replacement=tip.names,stringsAsFactors = FALSE)
tip.names$Replacement[tip.names$Replacement=="FLLG"]<-"FLFW"

png("FWSW_treemix_m3_FLPB.png",height=7,width=7,units="in",res=300)
t3<-plot_tree("fwsw.k100bFLPBrm3","poporder",plus=0.05,scale=F,mbar=F,arrow=0.1,tip.order = tip.names)
ybar<-0.01
mcols = rev( heat.colors(150) )
mcols = mcols[50:length(mcols)]
ymi = ybar+0.15
yma = ybar+0.35
l = 0.2
w = l/100
xma = max(t3$d$x/20)
rect( rep(0.15, 100), ymi+(0:99)*w, rep(0.15+xma, 100), ymi+(1:100)*w, col = mcols, border = mcols)
text(0.15+xma+0.001, ymi, lab = "0", adj = 0, cex = 0.7)
text(0.15+xma+0.001, yma, lab = "0.5", adj = 0, cex =0.7)
text(0.15, yma+0.06, lab = "Migration", adj = 0 , cex = 0.6)
text(0.15, yma+0.03, lab = "weight", adj = 0 , cex = 0.6)
dev.off()

```

Ok, but how do I actually choose which number of migration edges to choose? Well, apparently [there's an R package for that!](https://rdrr.io/cran/OptM/#vignettes)

```{r}
library(OptM)
tmOpt<-optM("treemix")
plot_optM(tmOpt)
```

Let's plot the no-migration-edge tree with the two-migration-edge tree.

```{r}
png("../figs/treemix_comparison.png",height = 4.5,width=8,units="in",res=300)
par(mfrow=c(1,2),mar=c(1,1,1,2),oma=c(1,1,1,2),xpd=TRUE)
t0<-plot_tree("treemix/fwsw_k100bFLPBr",scale=T,mbar=F,cex = 1.5,
              lwd=2,mig_left=FALSE,disp=0.0002,xlab=FALSE,scadj=0.05)
t2<-plot_tree("treemix/fwsw_k100bFLPBrm2",scale=T,mbar=T,cex = 1.5,
              lwd=2,mig_left=FALSE,disp=0.0002,xlab=FALSE,scadj=0.05)
dev.off()
```


### Make figure

```{r}
grp.colors<-c('#762a83','#af8dc3','#e7d4e8','#d9f0d3','#7fbf7b','#1b7837') 
grp7colors<-c('#762a83','#9970ab','#c2a5cf','#d9f0d3','#a6dba0','#5aae61','#1b7837')
grp5colors<-c('#762a83','#c2a5cf','#a6dba0','#5aae61','#1b7837')
```

```{r}
#admixture 
admixK5<-read.delim("admixture/admixK5.txt",header = TRUE)
admixK7<-read.delim("admixture/admixK7.txt",header = TRUE)
#pcadapt
pa<-readRDS("fwsw_all_pcadapt.RDS")
pa.props<-round((pa$singular.values/sum(pa$singular.values))*100,2)
pap<-read.delim("pcadapt_colp.txt",sep=' ')
# map
library(jpeg)
img<-readJPEG("all_sites_map.jpeg")

# stuff for treemix
source("../R/203_treemix_plotting_funcs.R") #I've modified the functions from treemix
library(lattice); library(grid); library(RColorBrewer)
poporder<-read.delim("treemix/poporder")
colors<-poporder$colors
poporder<-poporder$poporder

```


```{r}
npop<-length(pop.list)
pseq<-1:npop
m<-matrix(c(rep(1,16),rep(2,6),
            3:18,rep(2,6),
            19:34,rep(2,6),
            rep(35,8),rep(36,8),rep(37,6)),
          nrow=4,ncol=npop+6,byrow = T)
jpeg("../figs/NewPopStructure_v1.jpeg",res=300,height=8,width=10,units="in")
#set the layout
layout(mat=m,heights=c(6,1,1,6))
#MAP
#open an empty plot window with coordinates
par(oma=c(1.5,3.5,1,2),mar=c(0,0,0,0),xpd=NA)
plot(1:14,ty="n",axes=FALSE,xlab="",ylab="",xpd=TRUE)
#specify the position of the image through bottom-left and top-right coords
rasterImage(img,1,1,14,14,xpd=TRUE)
text(x = 1.5,y=11.5,"A",cex = 2,font =2)
text(x = 0.5,y=1.2,"C",cex = 2,font =2)

#Treemix
par(mar=c(0,0,0,1))
t2<-plot_tree("treemix/fwsw_k100bFLPBrm2",scale=T,mbar=T,cex = 1.5,
              lwd=2,mig_left=FALSE,disp=0.0002,xlab=FALSE,scadj=0.05)
text(x = 0.035,y=0.9,"B",cex = 2,font =2)
#STRUCTURE
par(mar=c(1,0,0,0))
plotting.structure(admixK5,5,pop.order = poporder, pop.list, make.file=FALSE, 
                   xlabcol = all.colors,plot.new=FALSE,
                   colors=grp5colors[c(3,5,4,1,2)],xlabel=FALSE,
                   ylabel=expression(atop(italic(K)==5)),lab.cex=0.85)
plotting.structure(admixK7,7,pop.order = poporder,pop.labs, make.file=FALSE,
                   plot.new=FALSE,colors=grp7colors[c(6,7,1,2,5,3,4)],xlabel=TRUE,
                   xlabcol = all.colors,
                   ylabel=expression(atop(italic(K)==7)),lab.cex=0.85)

#PCADAPT
par(mar=c(2,2,2,2))
plot(pa$scores[,1],pa$scores[,2],col=alpha(pap$cols,0.5),bg=alpha(pap$cols,0.75),
     pch=as.numeric(pap$pch),	cex=3,bty="L",xlab="",ylab="",cex.axis=1.5)

mtext(paste("PC1 (",pa.props[1],"%)",sep=""),1,line = 2.5,cex=1)
mtext(paste("PC2 (",pa.props[2],"%)",sep=""),2,line = 2.5,cex=1)
text(x = -0.07,y=0.1,"D",cex = 2,font =2)

plot(pa$scores[,3],pa$scores[,4],col=alpha(pap$cols,0.5),bg=alpha(pap$cols,0.75),pch=as.numeric(pap$pch),
     cex=3,	bty="L",xlab="",ylab="",cex.axis=1.5)

mtext(paste("PC3 (",pa.props[3],"%)",sep=""),1,line = 2.5,cex=1)
mtext(paste("PC4 (",pa.props[4],"%)",sep=""),2,line = 2.5,cex=1)

plot(1:10,ty="n",axes=FALSE,xlab="",ylab="",xpd=TRUE)
legend("bottom", legend=ppi$Pop, pch=as.numeric(ppi$pch), pt.cex=3,cex=1.5,
       col=alpha(ppi$cols, 0.5),pt.bg=alpha(ppi$cols,0.25), ncol=2,bty='n')
dev.off()
```

![Figure 2. Population Structure](../figs/NewPopStructure_v1.jpeg)


## Demographic history inference


### dadi


## Outliers: Fsts from Stacks, permutations, PCadapt

### Stacks

```{r stacks_fsts}
fwsw.al<-read.delim("stacks/populations_subset75/batch_2.fst_ALFW-ALST.tsv")
fwsw.la<-read.delim("stacks/populations_subset75/batch_2.fst_ALST-LAFW.tsv")
fwsw.tx<-read.delim("stacks/populations_subset75/batch_2.fst_TXCC-TXFW.tsv")
fwsw.fl<-read.delim("stacks/populations_subset75/batch_2.fst_FLCC-FLFW.tsv")
```

```{r assignplotpos}
assign.plotpos<-function(df, plot.scaffs, bounds, df.chrom="Chrom", df.bp="BP"){
  colnames(bounds)<-c("Chrom","End")
  new.dat<-data.frame(stringsAsFactors = F)
  last.max<-0
  for(i in 1:length(plot.scaffs)){
    #pull out the data for this scaffold
    if(nrow(bounds[bounds$Chrom %in% plot.scaffs[i],])>0){ #sanity check
      chrom.dat<-df[df[[df.chrom]] %in% plot.scaffs[i],]
      if(nrow(chrom.dat)>0){
        chrom.dat$plot.pos<-as.numeric(as.character(chrom.dat[[df.bp]]))+last.max
        new.dat<-rbind(new.dat,chrom.dat)
        #last.max<-max(chrom.dat$plot.pos)+
        #               as.numeric(scaffold.widths[scaffold.widths[,1] %in% scaffs.to.plot[i],2])
      }
      last.max<-last.max+
        as.numeric(bounds[bounds$Chrom %in% plot.scaffs[i],2])
    }
  }
  #make sure everything is the correct class
  new.dat$plot.pos<-as.numeric(as.character(new.dat$plot.pos))
  return(new.dat)
}
```
```{r perlglines}
perlg.add.lines<-function(fwsw.plot,lgs,width=NULL,lwds=4,color="cornflowerblue"){
 
  for(i in 1:length(lgs)){
    this.df<-fwsw.plot[fwsw.plot$Chr %in% lgs[i],]
    if(is.null(width)){
      width<-(nrow(this.df)*0.15)
    }
    this.smooth<-do.call("rbind",lapply(seq(1,nrow(this.df),width/5),sliding.avg,
                                        dat=data.frame(Pos=this.df$plot.pos,
                                                       Fst=this.df$Corrected.AMOVA.Fst),
                                        width=width))
    points(this.smooth,col=color,type="l",lwd=lwds)
  }
}
```


```{r plotmultiplelgs}
plot_multiple_LGs<-function(list_fsts,fst_name,chr_name,bp_name,lgs,plot_labs,pt_cols=NULL,plot_scaffs=NULL,addSmooth=TRUE,smoothFst="Smoothed.Fst",smoothcol="cornflowerblue",ncol=2,...){
  nrow<-length(list_fsts)/ncol
  
  # check the variables
  if(length(list_fsts)>1){
    if(length(fst_name)==1){
      fst_names<-rep(list(fst_name),length(list_fsts))
    }else if(length(list_fsts)==length(fst_name)){
      fst_names<-fst_name
    }else{
      print("ERROR: invalid fst_name")
      return(NULL)
    }
    if(length(chr_name)==1){
      chr_names<-rep(list(chr_name),length(list_fsts))
    }else if(length(list_fsts)==length(chr_name)){
      chr_names<-chr_name
    }else{
      print("ERROR: invalid chr_name")
      return(NULL)
    }
    if(length(bp_name)==1){
      bp_names<-rep(list(bp_name),length(list_fsts))
    }else if(length(list_fsts)==length(bp_name)){
      bp_names<-bp_name
    }else{
      print("ERROR: invalid bp_name")
      return(NULL)
    }
    if(length(smoothFst)==1){
      smoothFsts<-rep(list(smoothFst),length(list_fsts))
    }else if(length(list_fsts)==length(smoothFst)){
      smoothFsts<-smoothFst
    }else{
      print("ERROR: invalid smoothFst")
      return(NULL)
    }
    if(!is.null(pt_cols)){ #if it's not null, then need to check it's a list
      if(length(pt_cols)==1){
        pch_cols<-rep(list(pt_cols),length(list_fsts))
      }else if(length(list_fsts)==length(pt_cols)){
        pch_cols<-pt_cols
      }else{
        print("WARNING: invalid pt_cols, using defaults")
        pch_cols<-c("darkgrey","lightgrey")
      }
    }
  }
  if(length(plot_labs) != length(list_fsts) | is.null(plot_labs)){
    print("WARNING: invalid plot labels (plot_labs). Omitting plot labels")
    plot_labs<-rep(list(""),length(list_fsts))
  }
  
  # aggregate data
  all_chr<-data.frame(Chr=unlist(lapply(list_fsts,function(x){ as.character(x[,chr_name])})),
                      BP=unlist(lapply(list_fsts,function(x){ as.character(x[,bp_name])})),stringsAsFactors = F)
  bounds<-tapply(as.numeric(as.character(all_chr$BP)), all_chr$Chr,max)
  bounds<-data.frame(Chrom=dimnames(bounds),End=bounds)
  colnames(bounds)<-c("Chrom","End")
  if(is.null(plot_scaffs)){
    plot_scaffs<-levels(bounds$Chr)
    plot_scaffs[1:22]<-lgs
  }
  bounds<-bounds[match(plot_scaffs,bounds$Chrom),]
  
  #Plot
  if(nrow*ncol < length(list_fsts)) nrow<-nrow+1
  par(mfrow=c(nrow,ncol),mar=c(3,3,2,2),oma=c(2,2,2,2))
  fsts<-mapply(function(f, fst,bp,chr,cols, plot_lab,smF,plot_scaffs,bounds,smoothcol,...){

    fst<-fst.plot(f,fst.name = fst, bp.name = bp,chrom.name = chr, 
                    scaffs.to.plot=plot_scaffs, scaffold.widths = bounds,
                    pt.cols = cols,...) #pch=19,y.lim = c(0,1),pt.cex=1,axis.size = 1
    
    if(addSmooth==TRUE) points(fst$plot.pos,fst[,smF],col=smoothcol,type="l") 
    
    clip(0,max(fst$plot.pos),0,1)
    
    mtext(plot_lab,2,cex=0.75)#,line=-1)
    labs<-tapply(fst$plot.pos,fst[,chr],median)
    text(x=labs[lgs],y=-0.1,labels=lgn,xpd=TRUE)
    
    return(fst)
  },f=list_fsts,fst=fst_names,bp=bp_names,chr=chr_names,cols=pch_cols,plot_lab=plot_labs,smF=smoothFsts,MoreArgs = list(plot_scaffs=plot_scaffs,bounds=bounds, smoothcol=smoothcol,...))
  return(fsts)
}
```
```{r plot_stacks_fsts}
fst_dat<-list(fwsw.al,fwsw.la,fwsw.tx,fwsw.fl)
fsts<-plot_multiple_LGs(list_fsts = fst_dat,fst_name = "Corrected.AMOVA.Fst",bp_name="BP",chr_name="Chr",
                        lgs=lgs,plot_labs=list("ALFW vs ALST","ALST vs LAFW","TXFW vs TXCC","FLFW vs FLCC"),
                        pt_cols = list(c(grp.colors[3],grp.colors[2]),c(grp.colors[2],grp.colors[3]),
                                       c(grp.colors[1],grp.colors[2]),c(grp.colors[6],grp.colors[5])),
                        ncol=1,addSmooth = FALSE,pch=19,y.lim = c(0,1),pt.cex=1,axis.size = 1)
```

So this generated a plot for each pairwise comparison. We could look for shared outliers and see if we can find anything

```{r get_stacks_sig}
tx.sig<-fwsw.tx[fwsw.tx$Fisher.s.P<0.01,"Locus.ID"]
la.sig<-fwsw.la[fwsw.la$Fisher.s.P<0.01,"Locus.ID"]
al.sig<-fwsw.al[fwsw.al$Fisher.s.P<0.01,"Locus.ID"]
fl.sig<-fwsw.fl[fwsw.fl$Fisher.s.P<0.01,"Locus.ID"]
length(tx.sig[(tx.sig %in% c(la.sig,al.sig,fl.sig))])
length(la.sig[(la.sig %in% c(tx.sig,al.sig,fl.sig))])
length(al.sig[(al.sig %in% c(la.sig,tx.sig,fl.sig))])
all.shared<-fl.sig[fl.sig %in% la.sig & fl.sig %in% al.sig & fl.sig %in% tx.sig]
```

There are `r length(unique(all.shared))` outliers (as determined by Fisher's P from stacks < 0.01) 

### Permutations

```{r permute.gwsca}
permute.gwsca<-function(vcf,map1,nperms,z=1.96, maf.cutoff = 0.05,cov.thresh=0.2){
  # calculate the actuals
  actual_fsts<-gwsca(vcf,colnames(vcf)[1:9],
                     map1[map1[,2] %in% unique(map1[,2])[1],1],
                     map1[map1[,2] %in% unique(map1[,2])[2],1],
                     maf.cutoff=maf.cutoff,prop.ind.thresh=cov.thresh)
  # do the permutations
  perm_fsts<-lapply(1:nperms,function(i,vcf,map1){
    perm_map<-map1
    perm_map[,2]<-perm_map[,2][permute::shuffle(perm_map[,2])]
    perm_dat<-gwsca(vcf,colnames(vcf)[1:9],
                     perm_map[perm_map[,2] %in% unique(perm_map[,2])[1],1],
                     perm_map[perm_map[,2] %in% unique(perm_map[,2])[2],1],
                     maf.cutoff,cov.thresh)
   
    return(perm_dat)
  },vcf=vcf,map1=map1)
  
  # calculate stats
  fsts<-t(do.call(rbind,lapply(perm_fsts,'[[',"Fst"))) #extract permuted fsts
  perm_fst_mu<-rowMeans(fsts)
  perm_fst_in<-NULL
  for(i in 1:nrow(actual_fsts)){
    pmax<-max(fsts[i,] )
    pmin<-min(fsts[i,] )
    if(actual_fsts[i,"Fst"] > pmax | actual_fsts[i,"Fst"] < pmin ){
      perm_fst_in[i]<-1
    }else{
      perm_fst_in[i]<-0
    }
  }
  
  fst_dat<-data.frame(cbind(actual_fsts,
                            n_perms=nperms,
                            mean_perm=perm_fst_mu,
                            act_in_perm=perm_fst_in))
  return(fst_dat)
}
```
```{r permuteVCF,eval=FALSE}
vcf<-parse.vcf("stacks/populations_subset75/batch_2.pruned.vcf")
popmap<-data.frame(inds=colnames(vcf)[10:ncol(vcf)],
                   pops=gsub("sample_(\\w{4}).*","\\1",colnames(vcf)[10:ncol(vcf)]),
                   stringsAsFactors = FALSE)
pwise_maps<-list(popmap[popmap$pops %in% c("TXFW","TXCC"),],
                 popmap[popmap$pops %in% c("FLLG","FLCC"),],
                 popmap[popmap$pops %in% c("ALFW","ALST"),],
                 popmap[popmap$pops %in% c("LAFW","ALST"),])

permuted_fsts<-lapply(pwise_maps,permute.gwsca,vcf=vcf,nperms=1000, maf.cutoff=0)
saveRDS(permuted_fsts,"permuted_fsts.RDS")
```

Now let's visualize it.

```{r plot_fst_hists}
plot_fst_hists<-function(perms,plot_lab=NULL,cols=NULL,permlab="mean_perm",reallab="Fst",baseplot=TRUE,inset=NULL){
  require(scales)
  if(is.null(plot_lab)){
    plot_lab<-""
  }
  if(is.null(cols)){
    cols<-c("grey","black")
  } else if(length(cols)==1){
    cols<-c("dark grey",cols)
  }
  #inset<-par()$fig
  #browser()
  if(isTRUE(baseplot)){
    hist(perms[,permlab],col=alpha(cols[1],0.5),border = alpha(cols[1],0.5),
         xlim=c(0,1),breaks = seq(0,1,0.01),main = plot_lab,xlab=expression(italic(F)[ST]),
         ylab="Number of SNPs")
    hist(perms[,reallab],col=alpha(cols[2],0.5),border = alpha(cols[2],0.5),
         xlim=c(0,1),breaks = seq(0,1,0.01),main = "",xlab=expression(italic(F)[ST]),
         ylab="Number of SNPs",add=TRUE)
  }
  if(!is.null(inset)){ # add an inset
    # adjust the fig coordinates
    ifig<-c(inset[1]+0.25*(inset[2]-inset[1]),inset[2], 
            inset[3]+0.25*(inset[4]-inset[3]), inset[4])
    par(fig = ifig,new=TRUE) # start x, end x, start y, end y (percent plotting space)
    hist(perms[,permlab][perms[,reallab]>0],col=alpha(cols[1],0.5),border = alpha(cols[1],0.5),
         xlim=c(0,1),breaks = seq(0,1,0.01),main = "",xlab="",
         ylab="")
    box() #give it a box
    hist(perms[,reallab,][perms[,reallab]>0],col=alpha(cols[2],0.5),border = alpha(cols[2],0.5),
         xlim=c(0,1),breaks = seq(0,1,0.01),main = "",xlab="",
         ylab="",add=TRUE)
  }
  invisible(par()$fig)
}

```
```{r plot_permutations, eval=FALSE}
plot_labs<-list("TXFW vs TXCC","FLFW vs FLCC","ALFW vs ALST","ALST vs LAFW")
pt_cols<-list(TXTX=grp.colors[1],FLFL=grp.colors[6],
              ALAL=grp.colors[3],ALLA=grp.colors[2])
png("../figs/permuted_fsts.png",pointsize = 16,height=7,width=8,units="in",res=300)
par(mfrow=c(2,2),new=FALSE,mar=c(4,4,3,1))
#plot the base
pars<-mapply(plot_fst_hists,perms=permuted_fsts,plot_lab=plot_labs,cols=pt_cols,SIMPLIFY = FALSE)
# add the insets
ipars<-mapply(plot_fst_hists,perms=permuted_fsts,plot_lab=plot_labs,cols=pt_cols,
              inset=pars,
              MoreArgs = list(baseplot=FALSE))
dev.off()
```
[Permuted Fsts](../figs/permuted_fsts.png)

Now let's start to aggregate everything.

```{r}
permuted_fsts<-readRDS("permuted_fsts.RDS")
vcf<-parse.vcf("stacks/populations_subset75/batch_2.pruned.vcf")
fw_SNPinfo<-data.frame(ID=vcf$ID,Chrom=vcf$`#CHROM`,Pos=vcf$POS,BP=vcf$POS-1,
                       REF=vcf$REF,ALT=vcf$ALT,
                       perm_TX=permuted_fsts[[1]]$act_in_perm,
                       perm_FL=permuted_fsts[[2]]$act_in_perm,
                       perm_AL=permuted_fsts[[3]]$act_in_perm,
                       perm_LA=permuted_fsts[[4]]$act_in_perm,
                       stringsAsFactors = FALSE)
```


```{r}
# add Fsts
fw_SNPinfo<-merge(fw_SNPinfo,fwsw.al,by.x=c("Chrom","BP"),by.y=c("Chr","BP"),all.x=TRUE,all.y = FALSE)[,c(colnames(fw_SNPinfo),"Corrected.AMOVA.Fst")] 
colnames(fw_SNPinfo)[ncol(fw_SNPinfo)]<-"stacks_AL"
fw_SNPinfo<-merge(fw_SNPinfo,fwsw.la,by.x=c("Chrom","BP"),by.y=c("Chr","BP"),all.x=TRUE,all.y = FALSE)[,c(colnames(fw_SNPinfo),"Corrected.AMOVA.Fst")] 
colnames(fw_SNPinfo)[ncol(fw_SNPinfo)]<-"stacks_LA"
fw_SNPinfo<-merge(fw_SNPinfo,fwsw.tx,by.x=c("Chrom","BP"),by.y=c("Chr","BP"),all.x=TRUE,all.y = FALSE)[,c(colnames(fw_SNPinfo),"Corrected.AMOVA.Fst")] 
colnames(fw_SNPinfo)[ncol(fw_SNPinfo)]<-"stacks_TX"
fw_SNPinfo<-merge(fw_SNPinfo,fwsw.fl,by.x=c("Chrom","BP"),by.y=c("Chr","BP"),all.x=TRUE,all.y = FALSE)[,c(colnames(fw_SNPinfo),"Corrected.AMOVA.Fst")] 
colnames(fw_SNPinfo)[ncol(fw_SNPinfo)]<-"stacks_FL"
# add p-values
fw_SNPinfo<-merge(fw_SNPinfo,fwsw.al,by.x=c("Chrom","BP"),by.y=c("Chr","BP"),all.x=TRUE,all.y = FALSE)[,c(colnames(fw_SNPinfo),"Fisher.s.P")] 
colnames(fw_SNPinfo)[ncol(fw_SNPinfo)]<-"stacks_AL_P"
fw_SNPinfo<-merge(fw_SNPinfo,fwsw.la,by.x=c("Chrom","BP"),by.y=c("Chr","BP"),all.x=TRUE,all.y = FALSE)[,c(colnames(fw_SNPinfo),"Fisher.s.P")] 
colnames(fw_SNPinfo)[ncol(fw_SNPinfo)]<-"stacks_LA_P"
fw_SNPinfo<-merge(fw_SNPinfo,fwsw.tx,by.x=c("Chrom","BP"),by.y=c("Chr","BP"),all.x=TRUE,all.y = FALSE)[,c(colnames(fw_SNPinfo),"Fisher.s.P")] 
colnames(fw_SNPinfo)[ncol(fw_SNPinfo)]<-"stacks_TX_P"
fw_SNPinfo<-merge(fw_SNPinfo,fwsw.fl,by.x=c("Chrom","BP"),by.y=c("Chr","BP"),all.x=TRUE,all.y = FALSE)[,c(colnames(fw_SNPinfo),"Fisher.s.P")] 
colnames(fw_SNPinfo)[ncol(fw_SNPinfo)]<-"stacks_FL_P"
saveRDS(fw_SNPinfo,"fw_SNPinfo.RDS")
```

### PCAdapt

For this analysis we'll use the subset of populations rather than the full population set.

First I need to add the fileformat line to the vcf

```{r convertVCF, eval=FALSE}
vcf<-parse.vcf("stacks/populations_subset75/batch_2.pruned.vcf")
write.table("##fileformat=VCFv","pcadapt_fw/fwsw.pruned.vcf",quote=FALSE,
            col.names = FALSE,row.names = FALSE)
suppressWarnings(write.table(vcf,"pcadapt_fw/fwsw.pruned.vcf",quote=FALSE,append = TRUE,
            row.names = FALSE,col.names = TRUE,sep='\t'))
```



```{r}
library(pcadapt)

filename<-read.pcadapt("pcadapt_fw/fwsw.pruned.vcf",type="vcf") #need to remove the first line with a # 
x<-pcadapt(filename, K=20)
plot(x,option="screeplot")
```

*K=4* seems like the best choice here to keep values to the left of the straight line. 

```{r}
# Organize pop info
pops<-gsub("sample_(\\w{4}).*","\\1",colnames(vcf)[10:ncol(vcf)])	
grp<-pops
grp[grp=="TXFW" | grp=="LAFW" | grp=="ALFW" | grp=="FLLG"]<-"freshwater"
grp[grp!="freshwater"]<-"saltwater"
```


```{r}
res<-pcadapt(filename,K=4)
par(mfrow=c(2,2))
plot(res, option="manhattan")
plot(res, option="qqplot")
plot(res, option="stat.distribution")
plot(res, option="scores",pop=pops)
```

The vignette recommends displaying the loadings and evaluate if loadings are clustered in single or several genomic regions

```{r}
par(mfrow = c(2, 2))
for (i in 1:4)
  plot(res$loadings[, i], pch = 19, cex = .3, ylab = paste0("Loadings PC", i))
```

This suggests that loadings are not clustered (assuming these are grouped by space), so we don't need to worry about LD thinning. Now let's look chromosome by chromosome:

```{r}
par(mfrow=c(6,4),mar=c(3,3,2,1.5))
l<-lapply(lgs, function(lg,vcf){
  plot(res$loadings[which(vcf$`#CHROM` %in% lg), 1], pch = 19, cex = .3, xlab = paste0("Position on ", lg), ylab = "Loadings PC 1")
  mtext(lg,3,outer=FALSE)
},vcf=vcf)
```

None of the LGs seem to have huge clusters of outliers so we can move on, lumping them all together.

We need to choose a cutoff for outlier detection. I'll use the qvalue approach, which identifies outliers with a false discovery rate of $\alpha$, which I'm setting here to 0.05.

```{r}
library(qvalue)
qval <- qvalue(res$pvalues)$qvalues
alpha <- 0.05
outliers <- which(qval < alpha)
snp_pc<-get.pc(res,outliers) # Get the PCs associated with outliers
```

We identified `r length(outliers)` outliers with this analysis, which are associated with `r length(unique(snp_pc$PC))` of the 4 clusters. If we look at the distribution of these, though, we see that most are associated with PC 1

```{r}
summary(as.factor(snp_pc$SNP))
```

Now we can add the qvalues to the fw_SNPinfo dataframe

```{r}
fw_SNPinfo<-readRDS("fw_SNPinfo.RDS")
fw_SNPinfo$pcadaptQ<-qval
fw_SNPinfo$pcadaptPC<-get.pc(res,1:length(qval))$PC
saveRDS(fw_SNPinfo,"fw_SNPinfo.RDS")
```

I should note that for some of these PCAdapt gives "NA" -- not sure what causes this behaviour but there it is. It's true for the residuals and everything else. It looks to be due to low allele frequencies -- though stacks should have been run with a minimum allele frequency cutoff, so this is perplexing.

### Bayenv

Investigate the environmental data

```{r compareEnvVar}
env.data<-read.csv("bayenv/env_data_raw.csv",row.names = 1)
env.data<-rbind(env.data,pop=c(rep("SW",12),rep("FW",4)))
env.data<-as.data.frame(t(env.data))
wilcox.test(as.numeric(env.data$temp)~env.data$pop) #ties, but p=0.539
wilcox.test(as.numeric(env.data$seagrass)~env.data$pop) #ties, but p=0.897
```


This analysis is of just the freshwater and saltwater populations. First I ran bayenv using the script `run_bayenv2_matrix_general.sh`.

```{bash}
# set up correct file formats
../../scripts/run_bayenv2_matrix_general.sh FILEMANIP bayenv/sub75.pruned.clust stacks/populations_subset75/batch_2.pruned.ped stacks/populations_subset75/batch_2.pruned.map bayenv ~/Programs/bayenv 7
# estimate matrices
../../scripts/run_bayenv2_matrix_general.sh MATRIX bayenv ~/Programs/bayenv/ 7
```

At this point I looked at the matrices

[!Bayenv matrices]("bayenv/fwsw75_pruned.png")

They all looked fine so I chose the randomly selected matrix (`matrix`).

```{bash}
# Create the SNPFILES
../../scripts/run_bayenv2_matrix_general.sh SNPFILES SNPSFILE SNPFILES
# Run bayenv
nohup ../../scripts/run_bayenv2_matrix_general.sh BAYENV ~/Programs/bayenv/ matrix env_data_sub75.txt 7 3 SNPFILES > bayenv.log &
```

#### Analyze Bayenv output

Now I can aggregate the output:

```{r getBayenvResults}
get_bayenv_results<-function(dir,env_vars){
  # process the variable names
  var_names<-unlist(lapply(env_vars,function(var){
    nms<-c(paste0(var,"_BF"),paste0(var,"_rho"),paste0(var,"_rs"))
    return(nms)
  }))
  # list all the files
  bf.files<-list.files(pattern="bf",path = dir,full.names = TRUE)
  xtx.files<-list.files(pattern="xtx",path=dir,full.names = TRUE)
  # get the bf files
  bf.dat<-do.call(rbind,lapply(bf.files,function(filename){
    bf<-read.table(filename,header = FALSE)
  }))
  colnames(bf.dat)<-c("locus", var_names)
  
  # xtx files
  xtx.files<-list.files(pattern="xtx",path=dir,full.names = TRUE)
  xtx.dat<-do.call(rbind,lapply(xtx.files,function(filename){
    xtx<-read.table(filename,header = FALSE,stringsAsFactors = FALSE)
  }))
  colnames(xtx.dat)<-c("locus","XtX")
  
  # combine the two
  bayenv.dat<-merge(xtx.dat,bf.dat,by="locus")
  return(bayenv.dat)
}
```

The SNP names are uninformative, just the row number the SNP was in. We can make these better using the freq info

```{r snpnames4bayenv, eval=FALSE}
bayenv_dat<-get_bayenv_results(dir="bayenv/SNPFILES",env_vars=c("temp","salinity","seagrass"))

freq<-read.table("bayenv/bayenv.frq.strat",header=T, stringsAsFactors=F)
#want to get $MAC for every snp at every pop 
#and NCHROBS-MAC for every stnp at every pop
freq<-cbind(freq,freq$NCHROBS-freq$MAC)
colnames(freq)[ncol(freq)]<-"NAC"
snp.names<-split(freq$SNP,freq$CLST)[[1]]
snp.names<-gsub("(\\d+)_\\d+","\\1",snp.names)

snp_dat<-data.frame(ID=snp.names,loc=seq(1,length(snp.names)*2,2))
bayenv_dat$locus<-as.numeric(gsub("SNPFILES\\/(\\d+)","\\1",bayenv_dat$locus))
bayenv_dat<-bayenv_dat[order(bayenv_dat$locus),]
bayenv_dat<-merge(snp_dat,bayenv_dat,by.x="loc",by.y="locus")
colnames(bayenv_dat)[1:2]<-c("index","SNPID")

pmap<-read.delim("stacks/populations_subset75/batch_2.pruned.map",header = FALSE)
pmap$locus<-gsub("(\\d+)_\\d+","\\1",pmap[,2])

bayenv_dat<-merge(pmap[,c(1,4,5)],bayenv_dat,by.x="locus",by.y="SNPID")
colnames(bayenv_dat)[2:3]<-c("Chrom","SNPID")
write.table(bayenv_dat,"bayenv/bayenv_output.txt",sep="\t",col.names = TRUE,row.names = FALSE,quote = FALSE)
```

Merge it with other snp info
```{r}
bayenv_dat<-read.delim("bayenv/bayenv_output.txt",header = TRUE)
bayenv_dat$logSalBF<-log(bayenv_dat$salinity_BF)
bayenv_dat$logTemBF<-log(bayenv_dat$temp_BF)
bayenv_dat$logSegBF<-log(bayenv_dat$seagrass_BF)
fw_SNPinfo<-readRDS("fw_SNPinfo.RDS")
fw_SNPinfo<-merge(fw_SNPinfo,bayenv_dat[,c("locus","XtX","logSalBF","logTemBF","logSegBF")],by.x="ID",by.y="locus")
saveRDS(fw_SNPinfo,"fw_SNPinfo.RDS")
```

Now we can investigate the outliers etc.

```{r bayenv}
#taken directly from fwsw_analysis.R
bayenv.dat<-read.delim("bayenv/bayenv_output.txt",header=T)
# calculate quantiles for bayes factors
bf.co<-apply(bayenv.dat[,grep("BF",colnames(bayenv.dat))],2,quantile,0.99) #focus on Bayes Factors, because of Lotterhos & Whitlock (2015)
temp.bf.sig<-bayenv.dat[bayenv.dat$temp_BF>bf.co["temp_BF"],]
sal.bf.sig<-bayenv.dat[bayenv.dat$salinity_BF>bf.co["salinity_BF"],]
grass.bf.sig<-bayenv.dat[bayenv.dat$seagrass_BF>bf.co["seagrass_BF"],]
#get the log transformed Bayes Factors
bayenv.dat$logSal<-log(bayenv.dat$salinity_BF)
bayenv.dat$logTemp<-log(bayenv.dat$temp_BF)
bayenv.dat$logSeagrass<-log(bayenv.dat$seagrass_BF)

# xtx
xtx.sig<-bayenv.dat[bayenv.dat$XtX > quantile(bayenv.dat$XtX,0.99),]
```

There are `r nrow(temp.bf.sig[temp.bf.sig$locus %in% sal.bf.sig$locus & temp.bf.sig$locus %in% grass.bf.sig,])` overlapping outliers between temperature-, salinity-, and seagrass-associated loci.

But if we only care about salinity ones, there are `r nrow(sal.bf.sig)` outliers. Are any of those XtX outliers too? `r nrow(xtx.sig[xtx.sig$locus %in% sal.bf.sig$locus,])` overlap -- not bad!

Now, to plot.
```{r plotOutliersSetup}
library(scales)
fw_SNPinfo<-readRDS("fw_SNPinfo.RDS")
cols<-c(perm=alpha('#e41a1c',0.75),sal=alpha('#377eb8',0.75),pc=alpha('#4daf4a',0.75),xtx=alpha('#984ea3',0.75),stacks=alpha('#ff7f00',0.75))
```
```{r plotOutliers}
par(mfrow=c(2,1),oma=c(1,2,1,1),mar=c(2,2,1,1),xpd=TRUE)
# plot XtX
plot_dat<-fst.plot(fw_SNPinfo,scaffs.to.plot = lgs,fst.name = "XtX",chrom.name = "Chrom",bp.name = "Pos",axis.size = 0,pch=19)
points(plot_dat$plot.pos[plot_dat$XtX>=quantile(plot_dat$XtX,0.99)],
       plot_dat$XtX[plot_dat$XtX>=quantile(plot_dat$XtX,0.99)],
       col=cols["xtx"],cex=0.75,pch=19)
points(plot_dat$plot.pos[plot_dat$logSalBF>=quantile(plot_dat$logSalBF,0.99)],
       plot_dat$XtX[plot_dat$logSalBF>=quantile(plot_dat$logSalBF,0.99)],
       col=cols["sal"],cex=0.85,pch=17)
points(plot_dat$plot.pos[rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       plot_dat$XtX[rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       col=cols["perm"],cex=1,pch=4,lwd=2)
points(plot_dat$plot.pos[plot_dat$stacks_AL < 0.05 & plot_dat$stacks_LA < 0.05 &
                           plot_dat$stacks_TX < 0.05 & plot_dat$stacks_FL < 0.05],
       plot_dat$XtX[plot_dat$stacks_AL < 0.05 & plot_dat$stacks_LA < 0.05 &
                           plot_dat$stacks_TX < 0.05 & plot_dat$stacks_FL < 0.05],
       col=cols["stacks"],cex=1,pch=5,lwd=2)
points(plot_dat$plot.pos[plot_dat$pcadaptQ<0.01],
       plot_dat$XtX[plot_dat$pcadaptQ<0.01],
       col=cols["pc"],cex=1,pch=0,lwd=2)
axis(2,las=1)
mtext(expression(italic("X")^"T"~italic("X")),2,line=2)

# add the LG labels
midpts<-tapply(plot_dat$plot.pos,plot_dat$Chrom,median)
text(x=midpts[lgs],y=0)

# plot Bayes Factors
plot_dat<-fst.plot(plot_dat,scaffs.to.plot = lgs,fst.name = "logSalBF",chrom.name = "Chrom",bp.name = "Pos",axis.size = 0,pch=19)
points(plot_dat$plot.pos[plot_dat$logSalBF>=quantile(plot_dat$logSalBF,0.99)],
       plot_dat$logSalBF[plot_dat$logSalBF>=quantile(plot_dat$logSalBF,0.99)],
       col=cols["sal"],cex=0.85,pch=17)
points(plot_dat$plot.pos[plot_dat$XtX>=quantile(plot_dat$XtX,0.99)],
       plot_dat$logSalBF[plot_dat$XtX>=quantile(plot_dat$XtX,0.99)],
       col=cols["xtx"],cex=0.75,pch=19)
points(plot_dat$plot.pos[rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       plot_dat$logSalBF[rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       col=cols["perm"],cex=1,pch=4,lwd=2)
points(plot_dat$plot.pos[plot_dat$stacks_AL < 0.05 & plot_dat$stacks_LA < 0.05 &
                           plot_dat$stacks_TX < 0.05 & plot_dat$stacks_FL < 0.05],
       plot_dat$logSalBF[plot_dat$stacks_AL < 0.05 & plot_dat$stacks_LA < 0.05 &
                           plot_dat$stacks_TX < 0.05 & plot_dat$stacks_FL < 0.05],
       col=cols["stacks"],cex=1,pch=5,lwd=2)
points(plot_dat$plot.pos[plot_dat$pcadaptQ<0.01],
       plot_dat$logSalBF[plot_dat$pcadaptQ<0.01],
       col=cols["pc"],cex=1,pch=0,lwd=2)
axis(2,las=1)
mtext("log(Salinity Bayes Factors)",2,line=2)

# add the LG labels
midpts<-tapply(plot_dat$plot.pos,plot_dat$Chrom,median)
text(x=midpts[lgs],y=-5)

# add outside legend

opar <- par(fig=c(0, 1, 0, 1), oma=c(0, 0, 0, 0),
            mar=c(0, 0, 0, 0), new=TRUE)
on.exit(par(opar))
plot(0, 0, type='n', bty='n', xaxt='n', yaxt='n')
legend("top",c(expression("Permutation"~italic("F")["ST"]),
         expression("Stacks"~italic("F")["ST"]),
         "PCAdapt",expression(italic("X")^T~italic("X")),"Salinity BF"),xjust = 0.5,x.intersp = 0.5,
       col = cols[c("perm","stacks","pc","xtx","sal")],
       pt.bg=cols[c("perm","stacks","pc","xtx","sal")],pch=c(4,5,0,19,17),bty='n',ncol=3)
```




