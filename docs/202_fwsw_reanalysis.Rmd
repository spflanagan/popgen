---
title: Supplemental Material 1 for "Multiple colonizations of freshwater by the Gulf
  pipefish reveal a shared genomic signature of adaptation"
author:
- affilnum: 1
  corresponding: yes
  email: spflanagan.phd@gmail.com
  name: Sarah P. Flanagan
- affilnum: 2
  name: Emily Rose
- affilnum: 3
  name: Adam Jones
output:
  bookdown::pdf_document2:
    fig_caption: yes
    keep_tex: yes
    number_sections: no
    template: manuscript.latex
    toc: yes
    toc_depth: 2
  html_document: null
  pdf_document:
    toc: yes
    toc_depth: '2'
  word_document: null
bibliography: programs.bib
capsize: normalsize
csl: molecular-ecology.csl
documentclass: article
editor_options:
  chunk_output_type: console
fontsize: 11pt
header-includes: |
  \usepackage{lipsum} \usepackage{float} \floatplacement{figure}{H}
affiliation:
- affil: School of Biological Sciences, University of Canterbury, 4800 Private Bag,
    Christchurch 8140 New Zealand
  affilnum: 1
- affil: Department of Biology, The University of Tampa, Tampa, FL 33606 USA
  affilnum: 2
- affil: Department of Biological Sciences, University of Idaho, Moscow, ID 83844
    USA
  affilnum: 3
preprint: no
spacing: singlespacing
abstract: "This document includes supplementary material for the paper.  In this document,
  we walk through the analysis of all 16 populations, including
  all of the additional analyses that were used to decide on the final presentation
  of results. This document shows the population structure analyses (Fsts, PCAdapt,
  Admixture, and Treemix), which were used to generate Figure 1. \n"
---

# Overview of the study {-}

In this study, we have population genomic data (ddRAD-seq) from 16 populations of Gulf pipefish (*Syngnathus scovelli*), including samples from four freshwater sites. We performed three primary categories of analyses: 

1. Population structure (contained in this document)

2. Demographic inference (Supplement 2)

3. Outlier analyses (Supplement 3)

This document contains analyses of data from all 16 populations, generated from all pairwise comparisons of populations, containing SNPs found in every population, in 75% of individuals, and with a minor allele frequency of at least 5%.



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,out.extra='',fig.pos="H",
                      warning = FALSE,message = FALSE,
                      dev='png',dpi=300)
knitr::opts_knit$set(root.dir='../fwsw_results/')
```
```{r source}
source("../../gwscaR/R/gwscaR.R")
source("../../gwscaR/R/gwscaR_plot.R")
source("../../gwscaR/R/gwscaR_utility.R")
source("../../gwscaR/R/gwscaR_fsts.R")
source("../../gwscaR/R/gwscaR_popgen.R")
source("../../gwscaR/R/vcf2dadi.R")
source("../R/203_treemix_plotting_funcs.R")#I've modified these functions
library(knitr)
library(scales)
library(kableExtra)
library(vegan)
library(RColorBrewer)
```

```{r popSetup}
pop.list<-c("TXSP","TXCC","TXFW","TXCB","LAFW","ALST","ALFW","FLSG","FLKB",
	"FLFD","FLSI","FLAB","FLPB","FLHB","FLCC","FLLG")
pop.labs<-c("TXSP","TXCC","TXFW","TXCB","LAFW","ALST","ALFW","FLSG","FLKB",
            "FLFD","FLSI","FLAB","FLPB","FLHB","FLCC","FLFW")
fw.list<-c("TXFW","LAFW","ALFW","FLLG")
sw.list<-c("TXSP","TXCC","TXCB","ALST","FLSG","FLKB",
	"FLFD","FLSI","FLAB","FLPB","FLHB","FLCC")
lgs<-c("LG1","LG2","LG3","LG4","LG5","LG6","LG7","LG8","LG9","LG10","LG11",
	"LG12","LG13","LG14","LG15","LG16","LG17","LG18","LG19","LG20","LG21",
	"LG22")
lgn<-seq(1,22)
all.colors<-c(rep("black",2),"#2166ac","black","#2166ac","black","#2166ac",
        rep("black",8),"#2166ac")
#grp.colors<-c('#e41a1c','#377eb8','#4daf4a','#984ea3','#ffff33','#f781bf')
grp.colors<-c('#762a83','#af8dc3','#e7d4e8','#d9f0d3','#7fbf7b','#1b7837')
col_vector<-c(red='#e6194b', green='#3cb44b', blue='#4363d8',yellow='#ffe119', 
              cyan='#46f0f0',orange='#f58231', teal='#008080', purple='#911eb4',  
              magenta='#f032e6', lime='#bcf60c', pink='#fabebe',  lavendar='#e6beff', 
              brown='#9a6324', olive='#808000', apricot='#ffd8b1',maroon='#800000', 
              mint='#aaffc3', navy='#000075', beige='#fffac8', grey='#808080', 
              white='#ffffff', black='#000000')

col_vector<-c('#762a83','#762a83',"#2166ac",'#762a83',"#2166ac",'#c2a5cf',
              "#2166ac",'#d9f0d3','#d9f0d3','#d9f0d3','#d9f0d3','#a6dba0',
              '#5aae61','#5aae61','#5aae61',"#2166ac")

ppi<-data.frame(Pop=pop.labs,cols = col_vector,
                pch=rep(c(15,16,17,18),4))
ppi$pch[grep("FW",ppi$Pop)]<-c(15,16,17,18)
```



```{r map_setup, eval=FALSE}
#First, we'll plot these populations on a map
library(maps);library(gplots);library(mapdata)
mar.coor<-read.csv("marine_coordinates_revised.csv", header=T)
fw.coor<-read.csv("fw_coordinates.csv", header=T)

```
```{r map, eval=FALSE}
jpeg("all_sites_map.jpeg", res=300, height=7,width=14, units="in")
#pdf("all_sites_map.pdf",height=7,width=14)
par(oma=c(0,0,0,0),mar=c(0,0,0,0),pin=c(7,7))
map("worldHires", "usa",xlim=c(-100,-76), ylim=c(24,32), 
	col="gray90", mar=c(0,0,0,0),fill=TRUE, res=300,myborder=0)
map("worldHires", "mexico",xlim=c(-100,-76), ylim=c(24,32), 
	col="gray95", fill=TRUE, add=TRUE)
points(mar.coor$lon, mar.coor$lat,  col="black", cex=2, pch=19)
points(-1*fw.coor$lon, fw.coor$lat,  col="cornflowerblue", cex=2, pch=18)
abline(h=c(25,30,35),lty=3)
abline(v=c(-80,-85,-90,-95),lty=3)
text(x=c(-99.5,-99.5),y=c(25,30),c("25N","30N"),cex=1.75)
text(x=c(-80,-85,-90,-95),y=rep(31.8,4),c("80W","85W","90W","95W"),cex=1.75)
text(y=26,x=-90,"Gulf of Mexico",cex=1.75)
text(y=25.5,x=-98.5,"Mexico",cex=1.75)
text(x=-91,y=31,"USA",cex=1.75)
text(x=-78,y=29.5,"Atlantic Ocean",cex=1.75)
text(x=-96.4,y=26,"TXSP",font=2,cex=1.75)
text(x=-96.6,y=27.2,"TXCC",font=2,cex=1.75)
text(x=-95.6,y=28.3,"TXFW",font=2,col="cornflowerblue",cex=1.75)
text(x=-94.4,y=29,"TXCB",font=2,cex=1.75)
text(x=-90.5,y=29.8,"LAFW",font=2,col="cornflowerblue",cex=1.75)
text(x=-88,y=30,"ALST",font=2,cex=1.75)
text(x=-87,y=30.75,"ALFW",font=2,col="cornflowerblue",cex=1.75)
text(x=-85,y=29.4,"FLSG",font=2,cex=1.75)
text(x=-83.7,y=29,"FLKB",font=2,cex=1.75)
text(x=-83.4,y=27.6,"FLFD",font=2,cex=1.75)
text(x=-82.4,y=26,"FLSI",font=2,cex=1.75)
text(x=-79.9,y=24.8,"FLAB",font=2,cex=1.75)
text(x=-79.2,y=26.8,"FLPB",font=2,cex=1.75)
text(x=-79.4,y=27.2,"FLHB",font=2,cex=1.75)
text(x=-79.9,y=28.5,"FLCC",font=2,cex=1.75)
text(x=-80.9,y=29.5,"FLFW",font=2,col="cornflowerblue",cex=1.75)
dev.off()

```

## Phenotypic variation

Although our study is focused on genetic variation associated with an environmental variable, we also measured some meristic characters of the fish to identify whether the populations vary systematically in any phenotypic way. We found no substantial clustering in body traits (SVL, tail length, trunk depth, head length, snout length, snout depth) and no clear patterns in female ornaments (Figure \@ref(fig:plotPCA)). 

```{r organizeData, eval=FALSE}
raw.pheno<-read.table("../sw_results/popgen.pheno.txt", sep="\t", header=T)
	raw.pheno$PopID<-gsub("(\\w{4})\\w+","\\1",raw.pheno$ID)
	raw.pheno<-raw.pheno[raw.pheno$PopID %in% pop.list,]
	raw.pheno$sex<-gsub("\\w{4}(\\w)\\w+","\\1",raw.pheno$ID)
	raw.pheno$TailLength<-raw.pheno$std.length-raw.pheno$SVL
	raw.pheno$HeadLength<-raw.pheno$HeadLength-raw.pheno$SnoutLength

fem.pheno<-raw.pheno[raw.pheno$sex %in% c("F","D"),-8]
	fem.pheno<-fem.pheno[,c(11,1,10,2,12,4,5,6,7,8,9)]
	fem.pheno<-fem.pheno[order(match(fem.pheno$PopID,pop.list)),]
	write.table(fem.pheno,"fem.pheno.txt",sep='\t',row.names=F,col.names=T,
		quote=F)
	
mal.pheno<-raw.pheno[raw.pheno$sex %in% c("P","N"),-8]
	mal.pheno<-mal.pheno[,c(11,1,10,2,12,4,5,6,7)]
	mal.pheno<-mal.pheno[order(match(mal.pheno$PopID,pop.list)),]
	write.table(mal.pheno,"mal.pheno.txt",sep='\t',row.names=F,col.names=T,
		quote=F)
```
```{r readMalFem}
fem.pheno<-read.table("fem.pheno.txt",header=T)
	fem.pheno<-fem.pheno[!is.na(fem.pheno$BandNum),]
mal.pheno<-read.table("mal.pheno.txt",header=T)
```

```{r PCA}
fem.pheno$PopID<-factor(fem.pheno$PopID)
fem.pheno<-fem.pheno[!is.na(fem.pheno$BandNum),]
mal.pheno$PopID<-factor(mal.pheno$PopID)
bands.pcdat<-fem.pheno[!is.na(fem.pheno$BandNum),
	c("PopID","ID","MBandArea","BandNum")]
# run pcas
band.pca<-rda(bands.pcdat[,3:4])
fem.pheno.pca<-rda(fem.pheno[,4:9])
mal.pheno.pca<-rda(mal.pheno[,4:9])

```
```{r extractEigenvalue}
####extract eigenvalue
band.eig<-band.pca$CA$eig
band.pc<-band.eig/sum(band.eig)*100

#extract PC scores
band.u<-data.frame(bands.pcdat[,1:2],
                   "BandPC1"=band.pca$CA$u[,1],stringsAsFactors=F)
band.u.sep<-split(band.u, band.u[,1])
band.u.new<-rbind(band.u.sep$TXSP,band.u.sep$TXCC,band.u.sep$TXCB,
	band.u.sep$ALST,band.u.sep$FLSG,band.u.sep$FLKB,
	band.u.sep$FLFD,band.u.sep$FLSI,band.u.sep$FLAB,
	band.u.sep$FLPB,band.u.sep$FLHB,band.u.sep$FLCC)

fem.pheno.eig<-fem.pheno.pca$CA$eig
fem.pheno.pc<-fem.pheno.eig/sum(fem.pheno.eig)*100

#extract PC scores
fem.pheno.u<-data.frame(fem.pheno[,1:2],
	"FemBodyPC1"=fem.pheno.pca$CA$u[,1],stringsAsFactors=F)
fem.u.sep<-split(fem.pheno.u, fem.pheno.u[,1])
fem.u.new<-rbind(fem.u.sep$TXSP,fem.u.sep$TXCC,fem.u.sep$TXCB,
	fem.u.sep$ALST,fem.u.sep$FLSG,fem.u.sep$FLKB,
	fem.u.sep$FLFD,fem.u.sep$FLSI,fem.u.sep$FLAB,
	fem.u.sep$FLPB,fem.u.sep$FLHB,fem.u.sep$FLCC)

mal.pheno.eig<-mal.pheno.pca$CA$eig
mal.pheno.pc<-mal.pheno.eig/sum(mal.pheno.eig)*100

#extract PC scores
mal.u<-data.frame(mal.pheno[,1:2],"MalBodyPC1"=mal.pheno.pca$CA$u[,1],
	stringsAsFactors=F)
mal.u.sep<-split(mal.u, mal.u[,1])
mal.u.new<-rbind(mal.u.sep$TXSP,mal.u.sep$TXCC,mal.u.sep$TXCB,
	mal.u.sep$ALST,mal.u.sep$FLSG,mal.u.sep$FLKB,
	mal.u.sep$FLFD,mal.u.sep$FLSI,mal.u.sep$FLAB,
	mal.u.sep$FLPB,mal.u.sep$FLHB,mal.u.sep$FLCC)

```

```{r PCAplotSetup}
# females
fem.pop<-as.character(bands.pcdat$PopID)
fem.pop[fem.pop=="FLLG"]<-"FLFW"
fem.colors<-as.character(fem.pop)
fem.pch<-as.character(fem.pop)
fw.fem.col<-as.character(fem.pop[fem.pop %in% fw.list])
for(i in 1:length(fem.pop)){
  fem.colors[i]<-as.character(ppi[ppi$Pop %in% fem.pop[i],"cols"])
  fem.pch[i]<-as.numeric(as.character(ppi[ppi$Pop %in% fem.pop[i],"pch"]))
}
fem.pch<-as.numeric(fem.pch)

# males
mal.pop<-as.character(mal.pheno$PopID)
mal.pop[mal.pop=="FLLG"]<-"FLFW"
mal.colors<-as.character(mal.pop)
mal.pch<-as.character(mal.pop)
fw.mal.col<-as.character(mal.pop[mal.pop %in% fw.list])
for(i in 1:length(mal.pop)){
  mal.colors[i]<-as.character(ppi[ppi$Pop %in% mal.pop[i],"cols"])
  mal.pch[i]<-as.character(ppi[ppi$Pop %in% mal.pop[i],"pch"])
}
mal.pch<-as.numeric(mal.pch)


fw.fem.rows<-which(fem.pheno$PopID %in% fw.list)
fw.mal.rows<-which(mal.pheno$PopID %in% fw.list)

```


```{r plotPCA,fig.height=8,fig.width=10,fig.keep='last',fig.path="../figs/",fig.cap="Principal components analysis of morphological traits in S. scovelli reveals that phenotypic variation among populations is not based on habitat type. The top set of panels show the results of the PCA with all 16 populations, color-coded by populations and point shape. The bottom set of panels show the same PCA results, but with different x- and y-axis scaling and without the saltwater populations plotted, to facilitate visualizing the differences among saltwater populations. The left panels show male body traits (SVL, tail length, trunk depth, head length, snout length, and snout depth), the middle panels show those same traits in females, and the right panels show the female band traits (band number and band area)."}
ptCex<-2

par(mfrow=c(2,3),oma=c(2,2,2,2),mar=c(2,2,2,2),lwd=1.3)
mp<-plot(mal.pheno.pca,type="n",xlim=c(-3,3),ylim=c(-8.2,4)
	,xlab="",ylab="",las=1,cex.axis=1.5)
points(mal.pheno.pca,col=alpha(mal.colors,0.5),cex=ptCex,pch=mal.pch)
mtext(paste0("PC1 (",round(mal.pheno.pc[1],2),"%)"),1,line=2)
mtext(paste0("PC2 (",round(mal.pheno.pc[2],2),"%)"),2,line=2.5)
legend("top",bty='n',c("Male Body Traits"),cex=1.5)

fp<-plot(fem.pheno.pca,type="n",xlab="",ylab="",las=1,cex.axis=1.5,ylim=c(-4,12),
	xlim=c(-3,3))
points(fem.pheno.pca,col=alpha(fem.colors,0.5),cex=ptCex,pch=fem.pch)
mtext(paste0("PC1 (",round(fem.pheno.pc[1],2),"%)"),1,line=2)
mtext(paste0("PC2 (",round(fem.pheno.pc[2],2),"%)"),2,line=2.5)
legend("top",bty='n',c("Female Body Traits"),cex=1.5)

bp<-plot(band.pca,type="n",xlab="",ylab="",las=1,
         cex.axis=1.5,xlim=c(-2,2),ylim=c(-3,1))
points(band.pca,pch=fem.pch,col=alpha(fem.colors,0.5),cex=ptCex)
mtext(paste0("PC1 (",round(band.pc[1],2),"%)"),1,line=2)
mtext(paste0("PC2 (",round(band.pc[2],2),"%)"),2,line=2.5)
legend("top",bty='n',c("Female Band Traits"),cex=1.5)


plot(mp$sites[fw.mal.rows,],type="n",xlab="",ylab="",las=1,cex.axis=1.5)
abline(h=0,lty=3)
abline(v=0,lty=3)
points(mp$sites[fw.mal.rows,],xlim=c(-0.1,0.1),ylim=c(-.2,.2),
	col=alpha(mal.colors[fw.mal.rows],0.5),cex=ptCex,pch=mal.pch[fw.mal.rows])
mtext(paste0("PC1 (",round(mal.pheno.pc[1],2),"%)"),1,line=2)
mtext(paste0("PC2 (",round(mal.pheno.pc[2],2),"%)"),2,line=2.5)


plot(fp$sites[fw.fem.rows,],type="n",xlab="",ylab="",las=1,
	cex.axis=1.5,ylim=c(-4,12),xlim=c(-3,3))
abline(h=0,lty=3)
abline(v=0,lty=3)
points(fp$sites[fw.fem.rows,],
	col=alpha(fem.colors[fw.fem.rows],0.5),cex=ptCex,
	pch=fem.pch[fw.fem.rows])
mtext(paste0("PC1 (",round(fem.pheno.pc[1],2),"%)"),1,line=2)
mtext(paste0("PC2 (",round(fem.pheno.pc[2],2),"%)"),2,line=2.5)


plot(bp$sites[fw.fem.rows,],type="n",xlab="",ylab="",las=1,
	cex.axis=1.5,xlim=c(-2,2),ylim=c(-3,1))
points(bp$sites[fw.fem.rows,],
	pch=fem.pch[fw.fem.rows],col=alpha(fem.colors[fw.fem.rows],0.5),
	cex=ptCex)
mtext(paste0("PC1 (",round(band.pc[1],2),"%)"),1,line=2)
mtext(paste0("PC2 (",round(band.pc[2],2),"%)"),2,line=2.5)
abline(h=0,lty=3)
abline(v=0,lty=3)

par(fig = c(0, 1, 0, 1), oma=c(2,1,0,1), 
    mar = c(0, 0, 0, 0), new = TRUE, cex=1)
plot(0, 0, type = "n", bty = "n", xaxt = "n", yaxt = "n")
legend("top", legend=ppi$Pop, 
	col=as.character(ppi$col),
	pt.cex=ptCex,bty='n',pch=ppi$pch, ncol=8)
```




```{r readVCFs1, eval=FALSE}
## Table of summary statistics
pop_map<-read.delim("../fwsw_pops_map.txt",header = FALSE,stringsAsFactors = FALSE)
ful_vcf<-parse.vcf(
  "filter_rad_20191014@1654/14_filtered/radiator_data_20191014@1710.vcf")
colnames(ful_vcf)<-gsub("\\-","_",colnames(ful_vcf))
```
```{r readSubVCF,eval=FALSE}
sub_vcf<-parse.vcf("stacks/populations_subset75/batch_2.pruned.vcf")
sub_all_vcf<-parse.vcf("stacks/populations_subset75/all_pops_subset75/batch_2.vcf")
# combine the two
sub<-merge(sub_vcf,sub_all_vcf,by="ID",all = TRUE)
rmv<-grep(".y",colnames(sub))
sub<-sub[,-rmv]
colnames(sub)<-gsub(".x","",colnames(sub))
```

```{r popSummaries, eval=FALSE}
pop_summaries<-do.call(rbind,lapply(pop.list,function(pop,ful,sub){
  ful_dat<-ful[,c(1:9,grep(pop,colnames(ful)))]
  sub_dat<-sub[,c(1:9,grep(pop,colnames(sub)))]
  # calc observed het values
  ful_ho<-apply(ful_dat,1,calc.het)
  sub_ho<-apply(sub_dat,1,calc.het)
  # estimate allele freqs
  ful_afs<-do.call(rbind,apply(ful_dat,1,calc.afs.vcf))
  sub_afs<-do.call(rbind,apply(sub_dat,1,calc.afs.vcf))
  # save data frame
  dat<-data.frame(pop=pop,
                  preg_full=length(grep(paste0(pop,"P"),colnames(ful))),
                  preg_sub=length(grep(paste0(pop,"P"),colnames(sub))),
                  nonp_full=length(grep(paste0(pop,"NP"),colnames(ful))),
                  nonp_sub=length(grep(paste0(pop,"NP"),colnames(sub))),
                  nfem_full=length(grep(paste0(pop,"F"),colnames(ful))),
                  nfem_sub=length(grep(paste0(pop,"F"),colnames(sub))),
                  njuv_full=length(grep(paste0(pop,"J"),colnames(ful)))+
                    length(grep(paste0(pop,"DB"),colnames(ful))),
                  njuv_sub=length(grep(paste0(pop,"J"),colnames(sub))) + 
                    length(grep(paste0(pop,"DB"),colnames(sub))),
                  ho_full = mean(ful_ho,na.rm = TRUE),
                  hov_full = var(ful_ho,na.rm = TRUE),
                  ho_sub = mean(sub_ho,na.rm = TRUE),
                  hov_sub = var(sub_ho,na.rm = TRUE),
                  poly_ful = nrow(ful_afs[ful_afs$RefFreq<1,])/nrow(ful_afs)*100,
                  poly_sub = nrow(sub_afs[sub_afs$RefFreq<1,])/nrow(sub_afs)*100,
                  p_full = mean(ful_afs$RefFreq,na.rm=TRUE),
                  pv_full = var(ful_afs$RefFreq,na.rm=TRUE),
                  p_sub = mean(sub_afs$RefFreq,na.rm=TRUE),
                  pv_sub = var(sub_afs$RefFreq,na.rm=TRUE))
  return(dat)
},ful=ful_vcf,sub=sub))
write.csv(pop_summaries,"population_summaries.csv",row.names = FALSE,quote=FALSE)
```

 
```{r pop_env_summaries}
#We can merge the genetic info with the environmental info.
pop_summaries<-read.csv("population_summaries.csv")
env.data<-data.frame(t(read.csv("bayenv/env_data_raw.csv",row.names = 1)))
env.data$pop<-rownames(env.data)
pop_summaries<-merge(env.data,pop_summaries,by="pop")
```

```{r pretty_sum}
pretty_sum<-data.frame(Population = pop_summaries$pop,
                       Temperature = pop_summaries$temp,
                       Salinity = pop_summaries$salinity,
                       SeagrassDensity=pop_summaries$seagrass,
                       N_Pregnant = paste0(pop_summaries$preg_full,
                                           " (",pop_summaries$preg_sub,")"),
                       N_NonPregnant = paste0(pop_summaries$nonp_full,
                                              " (",pop_summaries$nonp_sub,")"),
                       N_Female = paste0(pop_summaries$nfem_full,
                                         " (",pop_summaries$nfem_sub,")"),
                       N_Juvenile = paste0(pop_summaries$njuv_full,
                                           " (",pop_summaries$njuv_sub,")"),
                       H_o = paste0(round(pop_summaries$ho_full,digits=3),
                                    "\u00B1",round(pop_summaries$hov_full,digits=3),
                                   " (",round(pop_summaries$ho_sub,digits=3),
                                   "\u00B1",round(pop_summaries$hov_sub,digits=3),")"),
                       MinorAlleleFrequency = paste0(
                         round(1-pop_summaries$p_full,digits=3),
                         "\u00B1",round(pop_summaries$pv_full,digits=3),
                         " (",round(1-pop_summaries$p_sub,digits=3),
                         "\u00B1",round(pop_summaries$pv_sub,digits = 3),")"),
                       PercentPolymorphicLoci = paste0(
                         round(pop_summaries$poly_ful,digits=1),
                         " (",round(pop_summaries$poly_sub,digits=1),")"),
                       stringsAsFactors = FALSE)
pretty_sum$Population[pretty_sum$Population=="FLLG"]<-"FLFW"
write.table(pretty_sum,"Table1_populationSummaries.txt",
            sep='\t',col.names = TRUE,quote=FALSE,row.names = FALSE)
```


## Minor allele frequencies

```{r calcAFS, eval=FALSE}
locus.info<-colnames(ful_vcf[1:9])
fw.afs<-lapply(fw.list,function(pop,vcf){
  this.vcf<-cbind(vcf[,locus.info],vcf[,grep(pop,colnames(vcf))])
  this.afs<-do.call(rbind,apply(this.vcf,1,calc.afs.vcf))
}, vcf=ful_vcf)
names(fw.afs)<-c("TXFW","LAFW","ALFW","FLFW")
sw.afs<-lapply(sw.list,function(pop,vcf){
  this.vcf<-cbind(vcf[,locus.info],vcf[,grep(pop,colnames(vcf))])
  this.afs<-do.call(rbind,apply(this.vcf,1,calc.afs.vcf))
},vcf=ful_vcf)
names(sw.afs)<-sw.list
all.afs<-c(fw.afs,sw.afs)
minAF<-lapply(all.afs,function(x){
  mins<-apply(x,1,function(row){ return(min(row[4],row[6])) } )
  return(as.numeric(mins))
})
names(minAF)<-names(all.afs)

```

```{r minorAFplot,fig.height=10,fig.width=8,dpi=300,fig.keep='last', fig.path="../figs/",eval=FALSE}

par(mfrow=c(4,4),mar=c(2,2,1,0),oma=c(2,3,0.5,0.5))
for(i in 1:length(pop.labs)){
  if(pop.labs[i] %in% names(fw.afs)){
    color<-"cornflowerblue"
  }else{
    color<-"black"
  }
  hist(minAF[[pop.labs[i]]],ylab="",xlab="",main="",
       xlim=c(0,0.5),ylim=c(0,10000),axes=F,col=color,
       breaks=seq(0,0.5,0.05))
  axis(1,pos=0,cex.axis=2)
  if(i %in% c(1,5,9,13)){
    axis(2,pos=0,las=1,cex.axis=2,labels = seq(0,10,2),at=seq(0,10000,2000))
  }else{
    axis(2,pos=0,las=1,labels = FALSE,cex.axis=2)
    }
  mtext(pop.labs[i],3,col=color,cex=2*0.75,line=-1)
}
mtext("Minor Allele Frequency",1,outer=TRUE,cex=1.75*0.75)
mtext("Number of SNPs (x 1000)",2,outer = TRUE,cex=1.75*0.75,line=1)

```

A useful summary of genetic variation within each population is the distribution of minor allele frequencies. We pruned the dataset to remove loci with a minor allele frequency less than 0.05, but the majority of these minor allele frequencies were still < 0.1 (Figure \@ref(fig:MAF)), with populations differing in the thickness of the tail of the distribution above 0.1. The freshwater population in Florida, FLFW, had the most extreme distribution, with almost no loci above 0.1.

```{r MAF, fig.cap="Minor allele frequency distributions of the full dataset (7433 SNPs) for each population. Freshwater populations are plotted in blue. The histograms show the number of SNPs with various frequencies of the reference alleles. All populations are skewed towards having small minor allele frequencies, but the TXFW and FLFW have additional reductions in genetic variation.", out.width="85%"}
knitr::include_graphics("../figs/minorAFplot-1.png")
```

# Population structure of all 16 populations  {-}

## FSTs

A straightforward way to summary population structure is through pairwise comparisons of differentiation. We plotted the pairwise $F_{ST}$ values for all 16 populations calculated by Stacks (Figure \@ref(fig:fstHeatmaps), also in Table 2 in main text), and clustering of nearby populations is obvious. The most differentiated populations are FLFW and TXFW. A similar pattern is seen using the covariances estimated by Treemix (an analysis described further below). The Treemix (co)variances also show that the FLFW population has a much larger within-population variance than the other populations (Figure \@ref(fig:fstHeatmaps)).


```{r pairwiseFstsCalc, eval=FALSE}
#This will calculate the pairwise $F_{ST}$s (but it's slow)

pop_map<-read.delim("../fwsw_pops_map.txt",header = FALSE,stringsAsFactors = FALSE)
fst_mat<-matrix(NA,
                nrow=length(unique(pop_map$V2)),ncol=length(unique(pop_map$V2)),
                dimnames = list(pop.list,pop.list))
vcf<-parse.vcf("filter_rad_20191014@1654/14_filtered/radiator_data_20191014@1710.vcf")
colnames(vcf)<-gsub("\\-","_",colnames(vcf)) # fix individual names
# loop through each population pair
for(i in 1:(nrow(fst_mat)-1)){
  for(j in (i+1):ncol(fst_mat)){
    
    if(rownames(fst_mat)[i] != colnames(fst_mat)[j]){ # sanity check
      map1<-pop_map[pop_map[,2]==rownames(fst_mat)[i],]
      map2<-pop_map[pop_map[,2]==colnames(fst_mat)[j],]
      pwfsts<-gwsca(vcf,colnames(vcf)[1:9],map1[,1],map2[,1])
      fst_mat[i,j]<-mean(pwfsts$Fst,na.rm = TRUE)
    }
  }
}
colnames(fst_mat)<-rownames(fst_mat)<-pop.labs
write.table(fst_mat,"pairwise_fsts_full.txt",sep='\t',
            col.names = TRUE,row.names=TRUE,quote=FALSE)
```

```{r readStacksFstSumm}
full_fsts<-read.delim("stacks/populations_whitelist/batch_2.fst_summary.tsv",
                      row.names = 1)
full_fsts<-rbind(full_fsts,TXSP=rep(NA,ncol(full_fsts))) #add the final row
Tfull_fsts<-t(full_fsts)
full_fsts[lower.tri(full_fsts)]<-Tfull_fsts[lower.tri(Tfull_fsts)] # now it's symmetric
full_fsts<-full_fsts[pop.list,pop.list]
colnames(full_fsts)<-rownames(full_fsts)<-pop.labs
fst_mat<-as.matrix(full_fsts)
```


```{r makefstHeatmaps,fig.width=8,fig.height=5,eval=FALSE}
library(lattice); library(grid); library(RColorBrewer)
poporder<-read.delim("treemix/poporder")
colors<-poporder$colors
poporder<-poporder$poporder

nr<-treemix.cov.plot("treemix/fwsw_k100b",poporder)
dimnames(nr)[[1]]<-dimnames(nr)[[2]]<-pop.labs
# colors
colors<-c("black","darkgrey","grey","lightgrey","cornflowerblue")
pal<-colorRampPalette(colors)
ncol=80
cols<-pal(ncol)
rev.colors<-c("cornflowerblue","lightgrey","grey","darkgrey","black")
rev.pal<-colorRampPalette(rev.colors)
rev.cols<-rev.pal(ncol)

hm.height<-list(x=2,units="in")#2.2/3.8
hm.width<-list(x=2.4,units="in")#2.4 in RStudio/3.9

heatmaps.name<-"../figs/fst_heatmaps.png"

png(heatmaps.name,height=5,width=8,units="in",res=300)

fst.lv<-levelplot(as.matrix(fst_mat),col.regions=cols,alpha.regions=0.7,
                  scales = list(x=list(rot=90),tck = 0),xlab="",ylab="")
print(fst.lv,split=c(1,1,2,1),more=TRUE,panel.width=hm.width,
      panel.height=hm.height,cex=2)
trellis.focus("legend", side="right", clipp.off=TRUE, highlight=FALSE)
grid.text(expression(italic(F)[ST]), 0.2, 0, hjust=0.5, vjust=1.2,gp=gpar(cex=0.75))
trellis.unfocus()

nr.lv<-levelplot(nr,col.regions=cols,alpha.regions=0.7,
                 scales = list(x=list(rot=90),tck = 0),xlab="",ylab="")
print(nr.lv,split=c(2,1,2,1),more=FALSE,newpage=FALSE,panel.width=hm.width,
      panel.height=hm.height,cex=2)
trellis.focus("legend", side="right", clipp.off=TRUE, highlight=FALSE)
grid.text("Treemix", 0.2, 0, hjust=0.5, vjust=1.2,gp=gpar(cex=0.75))
trellis.unfocus()

dev.off()

```


```{r fstHeatmaps, fig.cap="Heatmaps depicting population structure. In all graphs, dark colors depict similarity between populations and light grey and blue depict populations with high differentiation. The left panel shows pairwise FST values calculated by the populations module in Stacks (Catchen et al. 2013). The right panel shows covariances between populations as calculated by TreeMix (Pickrell and Pritchard 2012).", out.width="85%"}
knitr::include_graphics("../figs/fst_heatmaps.png")
```


## PCAdapt {-}

Principal comopnents analysis reduces many dimensions of variation to a few dimensions that preserve the majority of the variation, and has been shown to be useful in analyzing genomic data. We used PCAdapt [@luuPcadaptPackagePerform2017] to explore the axes of variation that best describe the genomic data from our 16 pipefish populations. 

```{r loadPCAdapt}
library(pcadapt)
```

```{r pcadaptChoose,fig.cap="Scree plot from PCAdapt, specifying keeping 20 PC axes."}
filename<-read.pcadapt("filter_rad_20191014@1654/14_filtered/radiator_data_20191014@1710.vcf",
                       type="vcf")
x<-pcadapt(filename, K=20)
plot(x,option="screeplot") #K=7
```

```{r pcadaptAnalyze}
pa<-pcadapt(filename,K=7)
saveRDS(pa,"fwsw_all_pcadapt.RDS")
pa.props<-round((pa$singular.values/sum(pa$singular.values))*100,2)
kable(pa.props,booktabs=TRUE,col.names = FALSE, row.names = FALSE,caption="Proportion of variation explained by all 7 of the retained PC axes in PCAdapt") %>%
  kable_styling(latex_options = "HOLD_position")
```

In our analysis, we decided to run PCAdapt specifying $K=7$ populations (Figure \@ref(fig:pcadaptChoose)), which results in 7 axes each explaining more than 5% of the variation (Table \@ref(tab:pcadaptAnalyze)). Visualizing the first six of the axes, we can see that the major axes of variation correspond to geographic distances first and foremost followed by within-region variation between freshwater and saltwater habitats (Figure \@ref(fig:plotPcadaptInitial)).


```{r pcadaptSummarize}
ind_dat<-read.table(
  "filter_rad_20191014@1654/14_filtered/individuals.qc.stats_20191014@1654.tsv",
  header=T, stringsAsFactors = F)
pops<-ind_dat$STRATA	
grp<-pops
grp[grp=="TXFW" | grp=="LAFW" | grp=="ALFW" | grp=="FLLG"]<-"freshwater"
grp[grp!="freshwater"]<-"saltwater"

#colors
pap<-data.frame(Pop=pops,cols=pops,pch=pops,grp=grp,stringsAsFactors = F)
pap$Pop[pap$Pop == "FLLG"]<-"FLFW"
for(i in 1:nrow(pap)){
  pap[i,"cols"]<-as.character(ppi[ppi$Pop %in% pap[i,"Pop"],"cols"])
}
for(i in 1:nrow(pap)){
  pap[i,"pch"]<-as.numeric(ppi[ppi$Pop %in% pap[i,"Pop"],"pch"])
}
write.table(pap,"pcadapt_colp.txt",col.names=TRUE,sep='\t',quote=F)

```

(ref:plotPcadaptInitial) Principal components analysis of genotypes in *S. scovelli* reveals population structure due to geographic distance and habitat type. The top set of panels show the results of the PCA with all 16 populations, color-coded by populations and point shape. The bottom set of panels show the same PCA results, but with different x- and y-axis scaling and without the saltwater populations plotted, to facilitate visualizing the differences among saltwater populations. The left panels show the first and second PC axes, which together account for 53.5% of the variation, the middle panels show the 3rd and 4th PC axes (another 26.8% of the variation), and the right panels the fifth and sixth axes (another % of variation).


```{r plotPcadaptInitial, fig.height=8,fig.width=10.5,dev='png',fig.dim="in",fig.cap='(ref:plotPcadaptInitial)'}

#plot
par(mfrow=c(2,3),oma=c(2,2,2,2),mar=c(2,2,2,2))
plot(pa$scores[,1],pa$scores[,2],col=alpha(pap$cols,0.5),bg=alpha(pap$cols,0.75),
     pch=as.numeric(pap$pch),	cex=1.5)
mtext(paste("PC1 (",pa.props[1],"%)",sep=""),1,line = 2,cex=0.75)
mtext(paste("PC2 (",pa.props[2],"%)",sep=""),2,line = 2,cex=0.75)
plot(pa$scores[,3],pa$scores[,4],col=alpha(pap$cols,0.5),
     bg=alpha(pap$cols,0.75),pch=as.numeric(pap$pch),cex=1.5)
mtext(paste("PC3 (",pa.props[3],"%)",sep=""),1,line = 2,cex=0.75)
mtext(paste("PC4 (",pa.props[4],"%)",sep=""),2,line = 2,cex=0.75)
plot(pa$scores[,5],pa$scores[,6],col=alpha(pap$cols,0.5),
     bg=alpha(pap$cols,0.75),pch=as.numeric(pap$pch),cex=1.5)
mtext(paste("PC5 (",pa.props[5],"%)",sep=""),1,line = 2,cex=0.75)
mtext(paste("PC6 (",pa.props[6],"%)",sep=""),2,line = 2,cex=0.75)
plot(pa$scores[grp=="freshwater",1],pa$scores[grp=="freshwater",2],
     col=alpha(pap$cols[pap$grp=="freshwater"],0.5),
     bg=alpha(pap$cols[pap$grp=="freshwater"],0.75),
     pch=as.numeric(pap$pch[pap$grp=="freshwater"]),
	cex=1.5)
mtext(paste("PC1 (",pa.props[1],"%)",sep=""),1,line = 2,cex=0.75)
mtext(paste("PC2 (",pa.props[2],"%)",sep=""),2,line = 2,cex=0.75)
plot(pa$scores[grp=="freshwater",3],pa$scores[grp=="freshwater",4],
     col=alpha(pap$cols[pap$grp=="freshwater"],0.5),
     bg=alpha(pap$cols[pap$grp=="freshwater"],0.75),
     pch=as.numeric(pap$pch[pap$grp=="freshwater"]),
	cex=1.5)
mtext(paste("PC3 (",pa.props[3],"%)",sep=""),1,line = 2,cex=0.75)
mtext(paste("PC4 (",pa.props[4],"%)",sep=""),2,line = 2,cex=0.75)
plot(pa$scores[grp=="freshwater",5],pa$scores[grp=="freshwater",6],
     col=alpha(pap$cols[pap$grp=="freshwater"],0.5),
     bg=alpha(pap$cols[pap$grp=="freshwater"],0.75),
     pch=as.numeric(pap$pch[pap$grp=="freshwater"]),
	cex=1.5)
mtext(paste("PC5 (",pa.props[5],"%)",sep=""),1,line = 2,cex=0.75)
mtext(paste("PC6 (",pa.props[6],"%)",sep=""),2,line = 2,cex=0.75)

par(fig = c(0, 1, 0, 1), oma=c(2,1,0,1), mar = c(0, 0, 0, 0), new = TRUE,
	cex=1)
plot(0, 0, type = "n", bty = "n", xaxt = "n", yaxt = "n")

legend("top", legend=ppi$Pop, pch=as.numeric(ppi$pch), pt.cex=1.5,cex=0.85,
       col=alpha(ppi$cols, 0.5),pt.bg=alpha(ppi$cols,0.25), ncol=8,bty='n')

```




## Admixture {-}

In addition to ordinational clustering, we can use model-based clustering approaches to estimate ancestry of individuals. We used ADMIXTURE [@alexanderFastModelbasedEstimation2009] for this analysis. The ADMIXTURE scree plot (Figure \@ref(fig:admixScree)) shows an 'elbow' around $K=5$ or $K=7$. To be thorough, we visualized $K=2$ through $K=7$ (Figures \@ref(fig:admixK2), \@ref(fig:admixK3), \@ref(fig:admixK4), \@ref(fig:admixk5), \@ref(fig:admixk6), \@ref(fig:admixk7))

```{r admixScree,fig.cap="Admixture screeplot for K=1 through K=16. The coefficient of variation (CV) is shown on the y-axis."}
admixK<-read.delim("admixture/K_CVs.txt",header = FALSE)
admixK$K<-as.numeric(gsub(".*\\(K=(\\d+)\\).*","\\1",admixK$V1))
admixK$CV<-as.numeric(gsub("^.*\\: (\\d+\\.\\d+)$","\\1",admixK$V1))

admixK<-admixK[order(admixK$K),]

plot(admixK$K,admixK$CV,pch=19,type = "b",lty=1,xlab = "K",ylab="CV",las=1,lwd=2)

```


```{r admixSetup}
library(RColorBrewer)
famfile<-"admixture/fwsw_all_filt.fam"

poporderFile<-"treemix/poplist"
poporderDF<-read.table(poporderFile,col.names = c("Pop"),stringsAsFactors = F)
poporderDF$orderNum<-1:nrow(poporderDF)
```

```{r plotAdmixFxn}
admixPlotting<-function(qfile,K,famfile="admixture/fwsw_all_filt.fam",
                        poporder=poporderDF){
  # read files in 
  famTable<- read.table(famfile, col.names = 
                        c("Pop","Ind","Father","Mother","Sex","phenotype"),
                      stringsAsFactors = F)[1:2]

  qtbl<-read.table(qfile,stringsAsFactors = F)
  
  # create useful tables
  mergedAdmixtureTable <- cbind(qtbl, famTable)
  mergedAdmixTabOrderNs <- merge(mergedAdmixtureTable,poporder,by="Pop")
  ordered <- mergedAdmixTabOrderNs[order(mergedAdmixTabOrderNs$orderNum),]
  
  plotting.structure(ordered[,1:(ncol(ordered)-2)],k = K,
                     pop.order = poporder$Pop,make.file = FALSE)
  admix<-ordered[,1:(ncol(ordered)-2)]
  return(admix)
}
```

```{r admixK2,fig.height=2,fig.width=8,fig.cap="Admixture plot for K=2. The colors represent different genetic populations."}
admixK2<-admixPlotting("admixture/fwsw_all_filt.2.Q",2)
```

```{r admixK3,fig.height=2,fig.width=8,fig.cap="Admixture plot for K=3. The colors represent different genetic populations."}
admixK3<-admixPlotting("admixture/fwsw_all_filt.3.Q",3)
```
```{r admixK4,fig.height=2,fig.width=8,fig.cap="Admixture plot for K=4. The colors represent different genetic populations."}
admixK4<-admixPlotting("admixture/fwsw_all_filt.4.Q",4)
```

```{r admixk5,fig.height=2,fig.width=8,fig.cap="Admixture plot for K=5. The colors represent different genetic populations."}
admixK5<-admixPlotting("admixture/fwsw_all_filt.5.Q",5)
write.table(admixK5,"admixture/admixK5.txt",sep = '\t',
            quote = FALSE,col.names = TRUE,row.names = FALSE)
```

```{r admixk6,fig.height=2,fig.width=8,fig.cap="Admixture plot for K=6. The colors represent different genetic populations."}
admixK6<-admixPlotting("admixture/fwsw_all_filt.6.Q",6)
```

```{r admixk7,fig.height=2,fig.width=8,fig.cap="Admixture plot for K=7. The colors represent different genetic populations."}
admixK7<-admixPlotting("admixture/fwsw_all_filt.7.Q",7)
write.table(admixK7,"admixture/admixK7.txt",sep = '\t',quote = FALSE,col.names = TRUE,row.names = FALSE)
```


## Treemix analysis {-}

Treemix infers patterns of population splits and mixtures in the history of populations and uses tree-based graphs with a variety of migration edges to describe these patterns [@pickrellInferencePopulationSplits2012]. We used this analysis to investigate the structure of the 16 pipefish populations. 

```{r treemixPoporder}
poporder<-c("TXSP","TXCC","TXFW","TXCB","LAFW","ALST",
            "ALFW","FLSG","FLKB","FLFD","FLSI","FLAB",
            "FLPB","FLHB","FLCC","FLLG")
colors<-poporder
colors[colors %in% "FLLG"]<-grp.colors[6]
colors[colors %in% c("FLPB","FLHB","FLCC")]<-grp.colors[6]
colors[colors %in% c("FLAB")]<-grp.colors[5]
colors[colors %in% c("FLSI","FLFD","FLKB","FLSG")]<-grp.colors[3]
colors[colors %in% c("ALST","ALFW","LAFW")]<-grp.colors[2]
colors[colors %in% c("TXSP","TXCC","TXFW","TXCB")]<-grp.colors[1]
write.table(cbind(poporder,colors),"poporder",quote=F,sep='\t')
```

### Tree with no migration edges and no root

First, we visualized the population tree without including any migration edges and without specifying a root (Figure \@ref(fig:treemixUnrooted)), which is useful in identifying a population we can use as the root and for comparisions down the line. 

```{r treemixPrep, eval=FALSE}
# unrooted tree
library(ape)
tre<-read.tree("treemix/unrooted_consensus.newick")
png("../figs/treemix_unrooted_consense.png",height=8,width=8,units="in",res=300)
plot(tre)
dev.off()
write.tree(tre,'treemix/unrooted_consensus.newick')
```

```{r treemixUnrooted, fig.cap="The consensus tree from running Treemix without any migration edges  and no root."}
knitr::include_graphics('../figs/treemix_unrooted_consense.png')
```


Based on the unrooted tree, we chose FLAB as the root and ran Treemix with 100 bootstrap replicates. We then used PHYLIP's consense program to build a consensus tree, assuming that it was a rooted tree (Figure \@ref(fig:treemixRooted)), re-saving it to file so it would be in one line and thus compatible with treemix. 

```{r rootedConsensus, eval=FALSE}
# rooted tree
tre<-read.tree("treemix/rooted_consensus.newick")
png("../../figs/treemix_rooted_consense.png",height=8,width=8,units="in",res=300)
plot(tre)
dev.off()
write.tree(tre,'treemix/rooted_consensus.newick')

```

```{r treemixRooted, fig.cap="The consensus tree from running Treemix without any migration edges and FLAB as root."}
knitr::include_graphics('../figs/treemix_unrooted_consense.png')
```


### Choosing the optimal number of migration edges

We also ran treemix to test the fit of the model with 0 through 5 migration edges (and with 100 bootstrap replicates). To choose the optimal number of migration edges, we used the R package optM [@fitakOptMPackageOptimize2019]. Comparing the likelihoods of the models using OptM clearly demonstrated that one migration edge was the appropriate number to use (Figures \@ref(fig:plotOptM), \@ref(fig:treemixLlik)). Provided in the Table (\@ref(tab:M1Starts)) are all of the nodes with possible migration edge starting locations and the number of bootstrap replicates in which that edge was supported. 


```{r plotOptM,message=FALSE,fig.show='true',fig.cap="Plot showing the comparison of Treemix number of migration edges using the Evanno method."}
library(OptM)
tmOpt<-optM("treemix/migrations/")
evanno_treemix(tmOpt)
```

```{r treemixLlik,fig.height=8,fig.width=6,dpi=300,fig.cap="Average log likelihoods of treemix bootstrap replicates with 0 through 5 migration edges. Shown are the means (of 100 bootstraps) and the standard error of the mean."}
lliks<-list.files(path="treemix/migrations/",pattern=".llik",full.names = TRUE)
likes<-data.frame(do.call(rbind,lapply(lliks,function(file){
  likdat<-read.delim(file,header=FALSE,row.names=1,sep=':')
  migs<-as.numeric(gsub(".*m(\\d).*","\\1",file))
  return(cbind(migs=migs,loglikelihood=likdat[2,]))
})))
rownames(likes)<-lliks

llikMean<-tapply(likes$loglikelihood,likes$migs,mean)
llikSEM<-tapply(likes$loglikelihood,likes$migs,function(x){
  return(sqrt(var(x)/length(x)))
})

plot(0:5,as.numeric(llikMean),pch=19,cex=2,
     xlab="Number of migration edges",
     ylab="Log likelihood",ylim=c(-8000,1200))
points(0:5,llikMean,lwd=2,type='l')
arrows(x0 = 0:5,y0=c(llikMean-llikSEM),
       x1=0:5,y1=c(llikMean+llikSEM),code=3,angle=0,lwd=2)
```

```{r treemixMigrationEdges,message=FALSE}
m1s<-list.files(pattern="m1.*treeout",path="treemix/migrations/",full.names = TRUE)
edges<-do.call(rbind,lapply(m1s,function(file){
  treeout<-scan(file,what="character",sep='\n')
  edge<-do.call(rbind,strsplit(treeout[2],' '))
  return(edge)
}))
rownames(edges)<-m1s
```

```{r M1Starts}
starts<-gsub("[[:digit:]]","\\1",edges[,5])
starts<-gsub(":","",starts)
starts<-gsub("\\.","",starts)
starts<-gsub("e-","",starts)
starts<-gsub(",",", ",starts)
starTab<-data.frame(tree=names(summary(as.factor(starts))),
                    counts=summary(as.factor(starts)))
rownames(starTab)<-NULL
kable(starTab,"latex",booktabs=TRUE,row.names=FALSE,longtable=TRUE,
      col.names = c("tree location","number of bootstraps"),
      caption="Number of bootstraps with the one migration edge beginning at each of these points on the population trees.") %>%
  kable_styling(latex_options=c("HOLD_position","repeat_header"))  %>%
  column_spec(1,width = "30em")
```

```{r M1Stops}
stops<-gsub("[[:digit:]]","\\1",edges[,6])
stops<-gsub(":","",stops)
stops<-gsub("\\.","",stops)
stops<-gsub("e-","",stops)
kable(summary(as.factor(stops)),"latex",booktabs=TRUE,
      col.names = c("number of bootstraps"),
      caption="Number of bootstraps with the one migration edge ending at each of these points on the population trees.")%>%
  kable_styling(latex_options=c("HOLD_position"))
```

The overwhelming majority of bootstrapped trees with one migration edge have that edge leading from the main branch of the tree to FLPB (Table \@ref(tab:M1Stops)). In the best-fitting tree (the one with the maximum log-likelihood), the migration edge is from FLAB to FLPB (Figure \@ref(fig:treemixCompare)).



```{r MaketreemixCompare,results='hide',eval=TRUE}
bestM1<-gsub("\\.llik","",
             rownames(likes[likes$migs==1,])[
               which.max(likes$loglikelihood[likes$migs==1])])
png("../figs/treemix_comparison.png",height = 4,width=8,units="in",res=300)
par(mfrow=c(1,2),mar=c(1,2,1,2),oma=c(1,6,1,2),xpd=TRUE)
t0<-plot_tree("treemix/migrations/fwsw_FLAB_m0",scale=T,mbar=F,cex = 1.5,
              lwd=2,disp=0.002,scadj=0.05)
# t1<-plot_tree("treemix/migrations/fwsw_FLAB_m1",scale=T,mbar=T,cex = 1.5,
#               lwd=2,mig_left=FALSE,disp=0.0002,scadj=0.05)
t2<-plot_tree(bestM1,scale=T,mbar=T,cex = 1.5,
              lwd=2,mig_left=FALSE,disp=0.0002,scadj=0.05)
dev.off()
```

```{r treemixCompare, out.width='90%',fig.cap="The plot of the tree with FLAB as root but no migration edges (left) compared to the best-fit tree with FLAB as root and one migration edge. The drift parameter is plotted on the x-axis, and migration edges are colored based on the migration weight."}
knitr::include_graphics('../figs/treemix_comparison.png')
```




### Threepop and fourpop analysis
 
We investigated the migration edge in the best Treemix model using threepop and fourpop analyses. In the threepop analysis, significantly negative f3 statistics mean that the first pop in the list (A in A;B,C) is admixed [@pickrellInferencePopulationSplits2012; @reichReconstructingIndianPopulation2009]. Therefore, with the threepop analysis we want to look for the tree (A;B,C) where A corresponds to the end of an arrow and (B,C) corresponds to where an arrow begins. In the fourpop analysis, a significantly non-zero value indicates gene flow in the tree [@pickrellInferencePopulationSplits2012; @reichReconstructingIndianPopulation2009]. 

```{r readf3f4}
threepop<-data.frame(do.call(rbind,
                             strsplit(grep(
                               ";",readLines("treemix/fwsw_threepop.txt"),
                               value = TRUE),' ')),
                     stringsAsFactors = FALSE)
colnames(threepop)<-c("pops","f3_stat","f3_se","f3_z")

fourpop<-data.frame(do.call(rbind,
                            strsplit(grep(";",
                                          readLines("treemix/fwsw_fourpop.txt"),
                                          value = TRUE),' ')),
                     stringsAsFactors = FALSE)
colnames(fourpop)<-c("pops","f4_stat","f4_se","f4_z")

```


The migration edge we investigated indicated potential migration from the ancestral Florida branch to the FLPB branch. We first investigated all of the three-population trees with FLPB and FLAB and found that the majority of these trees are positive, which suggests that FLPB is not admixed with the other Florida populations. Several trees are negative, but their standard errors overlap with zero (Figure \@ref(fig:f3Edge1)), which suggests that FLPB may experience some admixtre with those populations. Unsurprisingly, given the admixture and pcadapt results, these trees are those with other Atlantic Florida populations (FLHB, FLCC, and FLLG/FLFW). 

```{r f3Edge1,fig.pos='H',fig.width=9,fig.height=6,fig.cap="Plot of the f3 statistic for three-population trees including both FLPB and FLAB. Error bars show the standard errors generated from block jackknifes. Trees indicative of admixture in FLPB are those with significantly negative f3 statistics."}
FLPB_edge<-threepop[grep("FLPB;.*FLAB.*",threepop$pops),]
FLPB_edge$f3_stat<-as.numeric(FLPB_edge$f3_stat)
FLPB_edge$f3_se<-as.numeric(FLPB_edge$f3_se)
FLPB_edge$lowSE<-FLPB_edge$f3_stat-FLPB_edge$f3_se
FLPB_edge$uppSE<-FLPB_edge$f3_stat+FLPB_edge$f3_se
FLPB_edge$f3_z<-as.numeric(FLPB_edge$f3_z)

ymax<-max(abs(c(FLPB_edge$lowSE,FLPB_edge$uppSE)))+0.001

# all the relevant trees
plot(1:nrow(FLPB_edge),as.numeric(FLPB_edge$f3_stat),
     ylim=c(ymax*-1,ymax),axes=FALSE,
     xlab="",ylab="f3 statistic +/- SE")
abline(h=0,lty=2)
arrows(1:nrow(FLPB_edge),FLPB_edge$lowSE,
       1:nrow(FLPB_edge),FLPB_edge$uppSE,code=3,angle=0)
axis(2,at=seq(-0.05,0.05,0.01),las=1)
axis(1,pos=-0.01,at=1:nrow(FLPB_edge),
     labels = FLPB_edge$pops,las=2,cex.axis=0.75)


```

To investigate the results of the fourpop analysis for this migration edge, we focused on four-population trees including both FLAB and FLPB and other Florida populations. All of these four population trees show evidence of admixture (Table \@ref(tab:f4Edge1), Figure \@ref(fig:f4Edge1Fig)), which is unsurprising given that these trees include populations that are in the same population clusters in the admixture and pcadapt results.

```{r f4Edge1,fig.pos='H'}
f4s<-fourpop[c(grep("FLPB,FL.*;FLAB,FL.*",fourpop$pops),
               grep("FL.*,FLPB;FLAB,FL.*",fourpop$pops),
               grep("FLPB,FL.*;FL.*,FLAB",fourpop$pops),
               grep("FL.*,FLPB;FL.*,FLAB",fourpop$pops)),]
kable(f4s,"latex",booktabs=TRUE,longtable=TRUE,
      caption = "Four-population trees with FLPB and FLAB and their f4 statistic, standard error, z-score, and p-value." )%>%
  kable_styling(latex_options=c("HOLD_position","repeat_header"))
```

```{r f4Edge1Fig,fig.pos='H',fig.width=8,fig.height=6,fig.cap="Plot of the f4 statistic for four-population trees including both FLPB and FLAB and other Florida populations. Error bars show the standard errors generated from block jackknifes. Trees indicative of admixture in the tree are those with significantly non-zero f4 statistics."}
f4s$lowSE<-as.numeric(f4s$f4_stat)-as.numeric(f4s$f4_se)
f4s$uppSE<-as.numeric(f4s$f4_stat)+as.numeric(f4s$f4_se)
ymax<-max(abs(c(f4s$lowSE,FLPB_edge$uppSE)))+0.001

# all the relevant trees
plot(1:nrow(f4s),as.numeric(f4s$f4_stat),
     ylim=c(ymax*-1,ymax),axes=FALSE,
     xlab="",ylab="f4 statistic +/- SE")
abline(h=0,lty=2)
arrows(1:nrow(f4s),f4s$lowSE,
       1:nrow(f4s),f4s$uppSE,code=3,angle=0)
axis(2,at=seq(-0.05,0.05,0.01),las=1)
axis(1,pos=-0.01,at=1:nrow(f4s),
     labels = f4s$pops,las=2,cex.axis=0.75)

```


## Make figure

For the main text, we summarized these results in a multi-panel figure (Figure 1), where we put together the geographic data, ordination results, ADMIXTURE results, and the best-fitting Treemix model. See the main text for these combined results.

```{r defineColors}
#grp.colors<-c('#762a83','#af8dc3','#e7d4e8','#d9f0d3','#7fbf7b','#1b7837') 
grp7colors<-c('#762a83','#9970ab','#c2a5cf','#d9f0d3','#a6dba0','#5aae61','#1b7837')
grp5colors<-c('#762a83','#c2a5cf','#a6dba0','#5aae61','#1b7837')
```

```{r NewPopStructurePrep,eval=TRUE,results='hide'}
#admixture 
admixK5<-read.delim("admixture/admixK5.txt",header = TRUE,stringsAsFactors = FALSE)
admixK5$Pop[admixK5$Pop=="FLLG"]<-"FLFW"
admixK7<-read.delim("admixture/admixK7.txt",header = TRUE,stringsAsFactors = FALSE)
admixK7$Pop[admixK7$Pop=="FLLG"]<-"FLFW"
#pcadapt
pa<-readRDS("fwsw_all_pcadapt.RDS")
pa.props<-round((pa$singular.values/sum(pa$singular.values))*100,2)
pap<-read.delim("pcadapt_colp.txt",sep='\t')
# map
library(jpeg)
img<-readJPEG("all_sites_map.jpeg")

# stuff for treemix
source("../R/203_treemix_plotting_funcs.R") #I've modified the functions from treemix
library(lattice); library(grid); library(RColorBrewer)
poporder<-read.delim("treemix/poporder")
colors<-poporder$colors
poporder<-poporder$poporder

d <- read.table("treemix/migrations/fwsw_FLAB_m1.vertices.gz", 
                as.is  = T, comment.char = "", quote = "")
branch.cols<-rep("black",nrow(d))
branch.cols[d[,2] %in% c("TXFW","ALFW","LAFW","FLLG")]<-"cornflowerblue"

tip.names<-as.vector(d[d[,5] == "TIP",2])
tip.names<-data.frame(Original=tip.names,Replacement=tip.names,stringsAsFactors = FALSE)
tip.names$Replacement[tip.names$Replacement=="FLLG"]<-"FLFW"


col_vector<-c(TXSP=grp7colors[1],TXCC=grp7colors[1],TXFW="#2166ac",TXCB=grp7colors[1],
              LAFW="#2166ac",ALST=grp7colors[3],ALFW="#2166ac",
              FLSG=grp7colors[5],FLKB=grp7colors[5],FLFD=grp7colors[5],
              FLSI=grp7colors[5],FLAB=grp7colors[5],
              FLPB=grp7colors[6],FLHB=grp7colors[6],FLCC=grp7colors[6],FLFW="#2166ac")
```


```{r NewPopStructureV2,eval=TRUE,results='hide'}
npop<-length(pop.list)
pseq<-1:npop
m<-matrix(c(rep(1,16),rep(2,6),
            3:18,rep(2,6),
            19:34,rep(2,6),
            rep(35,8),rep(36,8),rep(37,6)),
          nrow=4,ncol=npop+6,byrow = T)
jpeg("../figs/NewPopStructure_v1.jpeg",res=300,height=8,width=10,units="in")
#set the layout
layout(mat=m,heights=c(6,1,1,6))
#MAP
#open an empty plot window with coordinates
par(oma=c(1.5,3.5,1,2),mar=c(0,0,0,0),xpd=NA)
plot(1:14,ty="n",axes=FALSE,xlab="",ylab="",xpd=TRUE)
#specify the position of the image through bottom-left and top-right coords
rasterImage(img,1,1,14,14,xpd=TRUE)
text(x = 1.5,y=11.5,"A",cex = 2,font =2)
text(x = 0.5,y=1.2,"C",cex = 2,font =2)

#Treemix
par(mar=c(0,0,0,1))
t2<-plot_tree("treemix/migrations/fwsw_FLAB_m1",scale=T,mbar=T,cex = 1.5,
              lwd=2,mig_left=FALSE,disp=0.0002,scadj=0.05,
              tip.order=tip.names,branch.cols = branch.cols,
              tip.col=col_vector[tip.names$Replacement])
text(x = 0.035,y=0.9,"B",cex = 2,font =2)
#STRUCTURE
par(mar=c(1,0,0,0))
poporder<-as.character(poporder)
poporder[poporder=="FLLG"]<-"FLFW"
plotting.structure(admixK5,5,pop.order = poporder, pop.list, make.file=FALSE, 
                   xlabcol = all.colors,plot.new=FALSE,
                   colors=grp5colors[c(3,5,4,1,2)],xlabel=FALSE,
                   ylabel=expression(atop(italic(K)==5)),lab.cex=0.85)
plotting.structure(admixK7,7,pop.order = poporder,pop.labs, make.file=FALSE,
                   plot.new=FALSE,colors=grp7colors[c(6,7,1,2,5,3,4)],xlabel=TRUE,
                   xlabcol = all.colors,
                   ylabel=expression(atop(italic(K)==7)),lab.cex=0.85)

#PCADAPT
par(mar=c(2,2,2,2))
plot(pa$scores[,1],pa$scores[,2],col=alpha(pap$cols,0.5),bg=alpha(pap$cols,0.75),
     pch=as.numeric(pap$pch),	cex=3,bty="L",xlab="",ylab="",cex.axis=1.5)

mtext(paste("PC1 (",pa.props[1],"%)",sep=""),1,line = 2.5,cex=1)
mtext(paste("PC2 (",pa.props[2],"%)",sep=""),2,line = 2.5,cex=1)
text(x = -0.07,y=0.1,"D",cex = 2,font =2)

plot(pa$scores[,3],pa$scores[,4],col=alpha(pap$cols,0.5),bg=alpha(pap$cols,0.75),
     pch=as.numeric(pap$pch),
     cex=3,	bty="L",xlab="",ylab="",cex.axis=1.5)

mtext(paste("PC3 (",pa.props[3],"%)",sep=""),1,line = 2.5,cex=1)
mtext(paste("PC4 (",pa.props[4],"%)",sep=""),2,line = 2.5,cex=1)

plot(1:10,ty="n",axes=FALSE,xlab="",ylab="",xpd=TRUE)
legend("bottom", legend=ppi$Pop, pch=as.numeric(ppi$pch), pt.cex=3,cex=1.5,
       col=alpha(ppi$cols, 0.5),pt.bg=alpha(ppi$cols,0.25), ncol=2,bty='n')
dev.off()
```



## Make table

The main document also contains a color-coded table that summarizes the pairwise Fst values from Stacks as well as the covariances estimated by Treemix (the unrooted model). See Table 2 in the main text for those results.

```{r fstMatrix}
full_fsts<-read.delim("stacks/populations_whitelist/batch_2.fst_summary.tsv",
                      row.names = 1)
full_fsts<-rbind(full_fsts,TXSP=rep(NA,ncol(full_fsts))) #add the final row
Tfull_fsts<-t(full_fsts)
full_fsts[lower.tri(full_fsts)]<-Tfull_fsts[lower.tri(Tfull_fsts)] # now it's symmetric
full_fsts<-full_fsts[pop.list,pop.list]
colnames(full_fsts)<-rownames(full_fsts)<-pop.labs
fst_mat<-as.matrix(full_fsts)
```

```{r covPlot,results='hide',fig.show='true'}
cov<-read.table(gzfile("treemix/unrooted/fwsw_ML_consensus.cov.gz"), as.is = T, head = T, quote = "", 
                comment.char = "")
#reorder
covplot <- data.frame(matrix(nrow = nrow(cov), ncol = ncol(cov)))
for(i in 1:length(pop.list)){
  for( j in 1:length(pop.list)){
    
    covplot[i, j] = cov[which(names(cov)==pop.list[i]), which(names(cov)==pop.list[j])]
    rownames(covplot)[i]<-pop.list[i]
    colnames(covplot)[j]<-pop.list[j]
  }
}
covplot<-as.matrix(covplot)


```
```{r createFstExcel,eval=FALSE}
library(xlsx); library(RColorBrewer); library(scales)

table2<-fst_mat
table2[lower.tri(table2)]<-covplot[lower.tri(covplot)]
diag(table2)<-diag(covplot)
table2<-round(table2,digits = 4)

# first export the data
sheetName <- "FstCov"
file<-"table2_fst_cov.xlsx"
write.xlsx(table2,file,sheetName = sheetName)

wb<-loadWorkbook(file)
sheets <- getSheets(wb)               
sheet <- sheets[[sheetName]]          
rows <- getRows(sheet, rowIndex=2:(nrow(table2)+1)) # 1st row is headers
cells <- getCells(rows, colIndex = 2:(ncol(table2)+1)) # 1st col is rownames         
values<-lapply(cells,getCellValue)

# set the colors
pal<-colorRampPalette(c("#deebf7","#3182bd"))
cols<-matrix(nrow = nrow(table2),ncol=nrow(table2))
cols[upper.tri(cols)]<-pal(10)[as.numeric(cut(table2[upper.tri(table2)],breaks = 10))]
pal<-colorRampPalette(c("#78c679","#f7fcb9"))
cols[lower.tri(cols)]<-pal(10)[as.numeric(cut(table2[lower.tri(table2)],breaks = 10))]
pal<-colorRampPalette(c("#f7f7f7","#969696"))
diag(cols)<-pal(10)[as.numeric(cut(diag(table2),breaks = 10))]

for(i in 1:nrow(table2)){
  for(j in 1:ncol(table2)){
    csij<-CellStyle(wb,fill=Fill(foregroundColor = alpha(cols[i,j])))
    setCellStyle(cells[[paste(i+1,j+1,sep=".")]],cellStyle = csij)
  }
}

saveWorkbook(wb, file)
```



```{r createFWSNPinfo, eval=FALSE}
permuted_fsts<-readRDS("permuted_fsts.RDS")

perm_dat<-do.call(cbind,permuted_fsts)
colnames(perm_dat)[colnames(perm_dat) %in% "act_in_perm"]<-c("perm_TX","perm_FL","perm_AL","perm_LA")
perm_dat<-perm_dat[,c("Chrom","Pos","perm_TX","perm_FL","perm_AL","perm_LA")]
perm_dat$Pos<-as.numeric(perm_dat$Pos)

vcf<-parse.vcf("converted_subset.vcf")
fw_SNPinfo<-data.frame(ID=vcf$ID,Chrom=vcf$`#CHROM`,Pos=vcf$POS,BP=vcf$POS-1,
                       REF=vcf$REF,ALT=vcf$ALT,
                       perm_TX=permuted_fsts[[1]]$act_in_perm,
                       perm_FL=permuted_fsts[[2]]$act_in_perm,
                       perm_AL=permuted_fsts[[3]]$act_in_perm,
                       perm_LA=permuted_fsts[[4]]$act_in_perm,
                       stringsAsFactors = FALSE)
```


```{r add2SnpInfo, eval=FALSE}
fwsw.al<-read.delim("stacks/populations_subset75/converted.fst_ALFW-ALST.txt")
fwsw.la<-read.delim("stacks/populations_subset75/converted.fst_ALST-LAFW.txt")
fwsw.tx<-read.delim("stacks/populations_subset75/converted.fst_TXCC-TXFW.txt")
fwsw.fl<-read.delim("stacks/populations_subset75/converted.fst_FLCC-FLFW.txt")

# add Fsts
fw_SNPinfo<-merge(fw_SNPinfo,fwsw.al,by.x=c("Chrom","BP"),by.y=c("Chr","BP"),
                  all.x=TRUE,all.y = FALSE)[,c(colnames(fw_SNPinfo),
                                               "Corrected.AMOVA.Fst")] 
colnames(fw_SNPinfo)[ncol(fw_SNPinfo)]<-"stacks_AL"
fw_SNPinfo<-merge(fw_SNPinfo,fwsw.la,by.x=c("Chrom","BP"),by.y=c("Chr","BP"),
                  all.x=TRUE,all.y = FALSE)[,c(colnames(fw_SNPinfo),
                                               "Corrected.AMOVA.Fst")] 
colnames(fw_SNPinfo)[ncol(fw_SNPinfo)]<-"stacks_LA"
fw_SNPinfo<-merge(fw_SNPinfo,fwsw.tx,by.x=c("Chrom","BP"),by.y=c("Chr","BP"),
                  all.x=TRUE,all.y = FALSE)[,c(colnames(fw_SNPinfo),
                                               "Corrected.AMOVA.Fst")] 
colnames(fw_SNPinfo)[ncol(fw_SNPinfo)]<-"stacks_TX"
fw_SNPinfo<-merge(fw_SNPinfo,fwsw.fl,by.x=c("Chrom","BP"),by.y=c("Chr","BP"),
                  all.x=TRUE,all.y = FALSE)[,c(colnames(fw_SNPinfo),
                                               "Corrected.AMOVA.Fst")] 
colnames(fw_SNPinfo)[ncol(fw_SNPinfo)]<-"stacks_FL"
# add p-values
fw_SNPinfo<-merge(fw_SNPinfo,fwsw.al,by.x=c("Chrom","BP"),by.y=c("Chr","BP"),
                  all.x=TRUE,all.y = FALSE)[,c(colnames(fw_SNPinfo),"Fisher.s.P")] 
colnames(fw_SNPinfo)[ncol(fw_SNPinfo)]<-"stacks_AL_P"
fw_SNPinfo<-merge(fw_SNPinfo,fwsw.la,by.x=c("Chrom","BP"),by.y=c("Chr","BP"),
                  all.x=TRUE,all.y = FALSE)[,c(colnames(fw_SNPinfo),"Fisher.s.P")] 
colnames(fw_SNPinfo)[ncol(fw_SNPinfo)]<-"stacks_LA_P"
fw_SNPinfo<-merge(fw_SNPinfo,fwsw.tx,by.x=c("Chrom","BP"),by.y=c("Chr","BP"),
                  all.x=TRUE,all.y = FALSE)[,c(colnames(fw_SNPinfo),"Fisher.s.P")] 
colnames(fw_SNPinfo)[ncol(fw_SNPinfo)]<-"stacks_TX_P"
fw_SNPinfo<-merge(fw_SNPinfo,fwsw.fl,by.x=c("Chrom","BP"),by.y=c("Chr","BP"),
                  all.x=TRUE,all.y = FALSE)[,c(colnames(fw_SNPinfo),"Fisher.s.P")] 
colnames(fw_SNPinfo)[ncol(fw_SNPinfo)]<-"stacks_FL_P"
saveRDS(fw_SNPinfo,"fw_SNPinfo.RDS")
```


```{r annotateSNPs}
annotate_snps<-function(snpDF,gff,genome.blast,ID="Locus.ID",
                        chrom="Chr",bp="BP",pos="Column")
{
  fw.sig.reg<-do.call(rbind,apply(snpDF,1,function(sig){
    this.gff<-gff[as.character(gff$seqname) %in% 
                    as.character(unlist(sig[chrom])),]
    description<-NA
    SSCID<-NA
    if(nrow(this.gff)>0){
      
      this.reg<-this.gff[which(this.gff$start <= as.numeric(sig[bp]) & 
                           this.gff$end >= as.numeric(sig[bp])),]
      if(nrow(this.reg) == 0){
        if(as.numeric(sig[bp]) > max(as.numeric(this.gff$end))){
          region<-"beyond.last.contig"
        }else{
          region<-NA
        }
      }else{
        if(length(grep("SSCG\\d+",this.reg$attribute))>0){
          geneID<-unique(gsub(".*(SSCG\\d+).*",
                              "\\1",
                              this.reg$attribute[grep("SSCG\\d+",
                                                      this.reg$attribute)]))
          gene<-genome.blast[genome.blast$sscv4_gene_ID %in% geneID,
                             "blastp_hit_description"]
        }else{
          geneID<-NA
          gene<-NA
        }
        # if there are multiples they'll be in separated by a semi-colon
        region<-paste(this.reg$feature,collapse = ";")
        description<-paste(gene,collapse=";")
        SSCID<-paste(geneID,collapse=";")
      }
    }else{
      region<-"scaffNotFound"
    }
    return(data.frame(Locus=sig[[ID]],Chr=sig[chrom],BP=sig[bp],SNPCol=sig[pos],
                      region=region, description=description,SSCID=SSCID,
                      row.names=NULL))
  }))
}
```

```{r getGFF, eval=FALSE}
gff.name<-"ssc_2016_12_20_chromlevel.gff.gz"
if(length(grep("gz",gff.name))>0){
  gff<-read.delim(gzfile(paste("../../scovelli_genome/",gff.name,sep="")),header=F)
} else{
  gff<-read.delim(paste("../../scovelli_genome/",gff.name,sep=""),header=F)
}
colnames(gff)<-c("seqname","source","feature","start","end","score",
                 "strand","frame","attribute")
genome.blast<-read.csv("../../scovelli_genome/ssc_2016_12_20_cds_nr_blast_results.csv",
                       skip=1,header=T)#I saved it as a csv
```
```{r annotate_snpinfo, eval=FALSE}
fw_SNPinfo<-readRDS("fw_SNPinfo.RDS")

snp_annotate<-annotate_snps(fw_SNPinfo,gff,genome.blast,ID="ID",
                            chrom="Chrom",bp="BP",pos = "Pos")
snp_annotate$Locus<-as.character(snp_annotate$Locus)
fw_SNPinfo$ID<-as.character(fw_SNPinfo$ID)
fw_SNPinfo<-merge(fw_SNPinfo,snp_annotate[,-c(2,3)],
                  by.x="ID",by.y="Locus",all.x=TRUE)

saveRDS(fw_SNPinfo,"fw_SNPinfo.RDS")
```


```{r rearrangePutatives,eval=FALSE}
s<-strsplit(put_genes$Scovelli_geneID,",")
genes<-data.frame(Gene=rep(put_genes$Gene,sapply(s,length)),
                  SSCID=unlist(s),stringsAsFactors = FALSE)
dat<-do.call(rbind,apply(genes,1,function(gene,snpinfo){
  if(length(grep(gene["SSCID"],snpinfo$SSCID))>0){
    ID<-cbind(snpinfo$ID[grep(gene["SSCID"],snpinfo$SSCID)])
    out<-data.frame(ID,rbind(gene),row.names = NULL)
    return(out)
  }
},snpinfo=fw_SNPinfo))

info<-merge(fw_SNPinfo,dat,by="ID",all.x=TRUE)
fw_SNPinfo<-info[unique(info$ID),]
colnames(fw_SNPinfo)[colnames(fw_SNPinfo)=="SSCID.x"]<-"SSCID"
saveRDS(fw_SNPinfo,"fw_SNPinfo.RDS")
```


# References {-}


