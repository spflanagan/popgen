---
title: Supplemental Material for "Multiple colonizations of freshwater by the Gulf pipefish reveal a shared genomic signature of adaptation"
preprint: false
author: 
  - name: Sarah P. Flanagan
    affilnum: 1
    corresponding: true
    email: spflanagan.phd@gmail.com
  - name: Emily Rose
    affilnum: 2
  - name: Adam Jones
    affilnum: 3
affiliation:
  - affilnum: 1
    affil: School of Biological Sciences, University of Canterbury, 4800 Private Bag, Christchurch 8140 New Zealand
  - affilnum: 2
    affil: Department of Biology, The University of Tampa, Tampa, FL 33606 USA
  - affilnum: 3
    affil: Department of Biological Sciences, University of Idaho, Moscow, ID 83844 USA
abstract: >
  This document includes supplementary material for the paper. 
  In this document, we walk through the generation of each of the figures in the manuscript, including all of the additional analyses that were used to decide on the final presentation of results.
  This document shows the population structure analyses (Fsts, PCAdapt, Admixture, and Treemix), which were used to generate Figure 1.
  The second major section of this document deals with the identification of outliers and the interpretation of outliers from multiple analyses.
  These analyses combined to create Figure 2 and Figure 3. 
header-includes: >
  \usepackage{lipsum}
  \usepackage{float}
  \floatplacement{figure}{H}
bibliography: programs.bib
output:
  pdf_document:
    toc: true
    toc_depth: 2
    fig_caption: yes
    keep_tex: yes
    number_sections: no
    template: manuscript.latex
  html_document: null
  word_document: null
fontsize: 11pt
capsize: normalsize
csl: molecular-ecology.csl
documentclass: article
spacing: singlespacing
---

# Overview of the study {-}

The initial analyses are in `200_fwsw_analysis.Rmd` and conducted the analyses on a dataset generated from comparing lumped 'freshwater' and 'saltwater' populations, containing SNPs found in 50% of individuals and with a minor allele frequency of at least 5%. The revised paper will instead focus on two datasets:

1. A dataset with all 16 populations, generated from all pairwise comparisons of populations, containing SNPs found in every population, in 75% of individuals, and with a minor allele frequency of at least 5%.

2. A dataset containing only the 4 freshwater populations (TXFW, LAFW, ALFW, FLFW) and their nearest saltwater populations (TXCC, ALST, FLCC -- note ALST is the nearest neighbor to both ALFW and LAFW). This dataset also contains SNPs found in 75% of individuals with a minor allele frequency of at least 5%. 


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,out.extra='',fig.pos="H",
                      warning = FALSE,message = FALSE,
                      dev='png',dpi=300)
knitr::opts_knit$set(root.dir='../fwsw_results/')
```
```{r source}
source("../../gwscaR/R/gwscaR.R")
source("../../gwscaR/R/gwscaR_plot.R")
source("../../gwscaR/R/gwscaR_utility.R")
source("../../gwscaR/R/gwscaR_fsts.R")
source("../../gwscaR/R/gwscaR_popgen.R")
source("../../gwscaR/R/vcf2dadi.R")
source("../R/203_treemix_plotting_funcs.R")#I've modified these functions
library(knitr)
library(scales)
library(kableExtra)
library(vegan)
```

```{r popSetup}
pop.list<-c("TXSP","TXCC","TXFW","TXCB","LAFW","ALST","ALFW","FLSG","FLKB",
	"FLFD","FLSI","FLAB","FLPB","FLHB","FLCC","FLLG")
pop.labs<-c("TXSP","TXCC","TXFW","TXCB","LAFW","ALST","ALFW","FLSG","FLKB",
            "FLFD","FLSI","FLAB","FLPB","FLHB","FLCC","FLFW")
fw.list<-c("TXFW","LAFW","ALFW","FLLG")
sw.list<-c("TXSP","TXCC","TXCB","ALST","FLSG","FLKB",
	"FLFD","FLSI","FLAB","FLPB","FLHB","FLCC")
lgs<-c("LG1","LG2","LG3","LG4","LG5","LG6","LG7","LG8","LG9","LG10","LG11",
	"LG12","LG13","LG14","LG15","LG16","LG17","LG18","LG19","LG20","LG21",
	"LG22")
lgn<-seq(1,22)
all.colors<-c(rep("black",2),"#2166ac","black","#2166ac","black","#2166ac",
        rep("black",8),"#2166ac")
#grp.colors<-c('#e41a1c','#377eb8','#4daf4a','#984ea3','#ffff33','#f781bf')
grp.colors<-c('#762a83','#af8dc3','#e7d4e8','#d9f0d3','#7fbf7b','#1b7837')
col_vector<-c(red='#e6194b', green='#3cb44b', blue='#4363d8',yellow='#ffe119', 
              cyan='#46f0f0',orange='#f58231', teal='#008080', purple='#911eb4',  
              magenta='#f032e6', lime='#bcf60c', pink='#fabebe',  lavendar='#e6beff', 
              brown='#9a6324', olive='#808000', apricot='#ffd8b1',maroon='#800000', 
              mint='#aaffc3', navy='#000075', beige='#fffac8', grey='#808080', 
              white='#ffffff', black='#000000')

col_vector<-c('#762a83','#762a83',"#2166ac",'#762a83',"#2166ac",'#af8dc3',
              "#2166ac",'#e7d4e8','#e7d4e8','#e7d4e8','#e7d4e8','#7fbf7b',
              '#1b7837','#1b7837','#1b7837',"#2166ac")

ppi<-data.frame(Pop=pop.labs,cols = col_vector,
                pch=rep(c(15,16,17,18),4))
ppi$pch[grep("FW",ppi$Pop)]<-c(15,16,17,18)
```



## Map of the populations

First, we'll plot these populations on a map

```{r map_setup, eval=FALSE}
library(maps);library(gplots);library(mapdata)
mar.coor<-read.csv("marine_coordinates_revised.csv", header=T)
fw.coor<-read.csv("fw_coordinates.csv", header=T)

```
```{r map, eval=FALSE}
jpeg("all_sites_map.jpeg", res=300, height=7,width=14, units="in")
#pdf("all_sites_map.pdf",height=7,width=14)
par(oma=c(0,0,0,0),mar=c(0,0,0,0),pin=c(7,7))
map("worldHires", "usa",xlim=c(-100,-76), ylim=c(24,32), 
	col="gray90", mar=c(0,0,0,0),fill=TRUE, res=300,myborder=0)
map("worldHires", "mexico",xlim=c(-100,-76), ylim=c(24,32), 
	col="gray95", fill=TRUE, add=TRUE)
points(mar.coor$lon, mar.coor$lat,  col="black", cex=2, pch=19)
points(-1*fw.coor$lon, fw.coor$lat,  col="cornflowerblue", cex=2, pch=18)
abline(h=c(25,30,35),lty=3)
abline(v=c(-80,-85,-90,-95),lty=3)
text(x=c(-99.5,-99.5),y=c(25,30),c("25N","30N"),cex=1.75)
text(x=c(-80,-85,-90,-95),y=rep(31.8,4),c("80W","85W","90W","95W"),cex=1.75)
text(y=26,x=-90,"Gulf of Mexico",cex=1.75)
text(y=25.5,x=-98.5,"Mexico",cex=1.75)
text(x=-91,y=31,"USA",cex=1.75)
text(x=-78,y=29.5,"Atlantic Ocean",cex=1.75)
text(x=-96.4,y=26,"TXSP",font=2,cex=1.75)
text(x=-96.6,y=27.2,"TXCC",font=2,cex=1.75)
text(x=-95.6,y=28.3,"TXFW",font=2,col="cornflowerblue",cex=1.75)
text(x=-94.4,y=29,"TXCB",font=2,cex=1.75)
text(x=-90.5,y=29.8,"LAFW",font=2,col="cornflowerblue",cex=1.75)
text(x=-88,y=30,"ALST",font=2,cex=1.75)
text(x=-87,y=30.75,"ALFW",font=2,col="cornflowerblue",cex=1.75)
text(x=-85,y=29.4,"FLSG",font=2,cex=1.75)
text(x=-83.7,y=29,"FLKB",font=2,cex=1.75)
text(x=-83.4,y=27.6,"FLFD",font=2,cex=1.75)
text(x=-82.4,y=26,"FLSI",font=2,cex=1.75)
text(x=-79.9,y=24.8,"FLAB",font=2,cex=1.75)
text(x=-79.2,y=26.8,"FLPB",font=2,cex=1.75)
text(x=-79.4,y=27.2,"FLHB",font=2,cex=1.75)
text(x=-79.9,y=28.5,"FLCC",font=2,cex=1.75)
text(x=-80.9,y=29.5,"FLFW",font=2,col="cornflowerblue",cex=1.75)
dev.off()

```

## Phenotypic variation


```{r organizeData, eval=FALSE}
raw.pheno<-read.table("../sw_results/popgen.pheno.txt", sep="\t", header=T)
	raw.pheno$PopID<-gsub("(\\w{4})\\w+","\\1",raw.pheno$ID)
	raw.pheno<-raw.pheno[raw.pheno$PopID %in% pop.list,]
	raw.pheno$sex<-gsub("\\w{4}(\\w)\\w+","\\1",raw.pheno$ID)
	raw.pheno$TailLength<-raw.pheno$std.length-raw.pheno$SVL
	raw.pheno$HeadLength<-raw.pheno$HeadLength-raw.pheno$SnoutLength

fem.pheno<-raw.pheno[raw.pheno$sex %in% c("F","D"),-8]
	fem.pheno<-fem.pheno[,c(11,1,10,2,12,4,5,6,7,8,9)]
	fem.pheno<-fem.pheno[order(match(fem.pheno$PopID,pop.list)),]
	write.table(fem.pheno,"fem.pheno.txt",sep='\t',row.names=F,col.names=T,
		quote=F)
	
mal.pheno<-raw.pheno[raw.pheno$sex %in% c("P","N"),-8]
	mal.pheno<-mal.pheno[,c(11,1,10,2,12,4,5,6,7)]
	mal.pheno<-mal.pheno[order(match(mal.pheno$PopID,pop.list)),]
	write.table(mal.pheno,"mal.pheno.txt",sep='\t',row.names=F,col.names=T,
		quote=F)
```
```{r readMalFem}
fem.pheno<-read.table("fem.pheno.txt",header=T)
	fem.pheno<-fem.pheno[!is.na(fem.pheno$BandNum),]
mal.pheno<-read.table("mal.pheno.txt",header=T)
```

```{r PCA}
fem.pheno$PopID<-factor(fem.pheno$PopID)
fem.pheno<-fem.pheno[!is.na(fem.pheno$BandNum),]
mal.pheno$PopID<-factor(mal.pheno$PopID)
bands.pcdat<-fem.pheno[!is.na(fem.pheno$BandNum),
	c("PopID","ID","MBandArea","BandNum")]
# run pcas
band.pca<-rda(bands.pcdat[,3:4])
fem.pheno.pca<-rda(fem.pheno[,4:9])
mal.pheno.pca<-rda(mal.pheno[,4:9])

```
```{r extractEigenvalue}
####extract eigenvalue
band.eig<-band.pca$CA$eig
band.pc<-band.eig/sum(band.eig)*100

#extract PC scores
band.u<-data.frame(bands.pcdat[,1:2],
                   "BandPC1"=band.pca$CA$u[,1],stringsAsFactors=F)
band.u.sep<-split(band.u, band.u[,1])
band.u.new<-rbind(band.u.sep$TXSP,band.u.sep$TXCC,band.u.sep$TXCB,
	band.u.sep$ALST,band.u.sep$FLSG,band.u.sep$FLKB,
	band.u.sep$FLFD,band.u.sep$FLSI,band.u.sep$FLAB,
	band.u.sep$FLPB,band.u.sep$FLHB,band.u.sep$FLCC)

fem.pheno.eig<-fem.pheno.pca$CA$eig
fem.pheno.pc<-fem.pheno.eig/sum(fem.pheno.eig)*100

#extract PC scores
fem.pheno.u<-data.frame(fem.pheno[,1:2],
	"FemBodyPC1"=fem.pheno.pca$CA$u[,1],stringsAsFactors=F)
fem.u.sep<-split(fem.pheno.u, fem.pheno.u[,1])
fem.u.new<-rbind(fem.u.sep$TXSP,fem.u.sep$TXCC,fem.u.sep$TXCB,
	fem.u.sep$ALST,fem.u.sep$FLSG,fem.u.sep$FLKB,
	fem.u.sep$FLFD,fem.u.sep$FLSI,fem.u.sep$FLAB,
	fem.u.sep$FLPB,fem.u.sep$FLHB,fem.u.sep$FLCC)

mal.pheno.eig<-mal.pheno.pca$CA$eig
mal.pheno.pc<-mal.pheno.eig/sum(mal.pheno.eig)*100

#extract PC scores
mal.u<-data.frame(mal.pheno[,1:2],"MalBodyPC1"=mal.pheno.pca$CA$u[,1],
	stringsAsFactors=F)
mal.u.sep<-split(mal.u, mal.u[,1])
mal.u.new<-rbind(mal.u.sep$TXSP,mal.u.sep$TXCC,mal.u.sep$TXCB,
	mal.u.sep$ALST,mal.u.sep$FLSG,mal.u.sep$FLKB,
	mal.u.sep$FLFD,mal.u.sep$FLSI,mal.u.sep$FLAB,
	mal.u.sep$FLPB,mal.u.sep$FLHB,mal.u.sep$FLCC)

```

```{r PCAplotSetup}
# females
fem.pop<-as.character(bands.pcdat$PopID)
fem.pop[fem.pop=="FLLG"]<-"FLFW"
fem.colors<-as.character(fem.pop)
fem.pch<-as.character(fem.pop)
fw.fem.col<-as.character(fem.pop[fem.pop %in% fw.list])
for(i in 1:length(fem.pop)){
  fem.colors[i]<-as.character(ppi[ppi$Pop %in% fem.pop[i],"cols"])
  fem.pch[i]<-as.numeric(as.character(ppi[ppi$Pop %in% fem.pop[i],"pch"]))
}
fem.pch<-as.numeric(fem.pch)

# males
mal.pop<-as.character(mal.pheno$PopID)
mal.pop[mal.pop=="FLLG"]<-"FLFW"
mal.colors<-as.character(mal.pop)
mal.pch<-as.character(mal.pop)
fw.mal.col<-as.character(mal.pop[mal.pop %in% fw.list])
for(i in 1:length(mal.pop)){
  mal.colors[i]<-as.character(ppi[ppi$Pop %in% mal.pop[i],"cols"])
  mal.pch[i]<-as.character(ppi[ppi$Pop %in% mal.pop[i],"pch"])
}
mal.pch<-as.numeric(mal.pch)


fw.fem.rows<-which(fem.pheno$PopID %in% fw.list)
fw.mal.rows<-which(mal.pheno$PopID %in% fw.list)

```


```{r plotPCA,fig.height=8,fig.width=10,fig.keep='last',fig.path="../figs/",fig.cap="Principal components analysis of morphological traits in S. scovelli reveals that phenotypic variation among populations is not based on habitat type. The top set of panels show the results of the PCA with all 16 populations, color-coded by populations and point shape. The bottom set of panels show the same PCA results, but with different x- and y-axis scaling and without the saltwater populations plotted, to facilitate visualizing the differences among saltwater populations. The left panels show male body traits (SVL, tail length, trunk depth, head length, snout length, and snout depth), the middle panels show those same traits in females, and the right panels show the female band traits (band number and band area)."}
ptCex<-2

par(mfrow=c(2,3),oma=c(2,2,2,2),mar=c(2,2,2,2),lwd=1.3)
mp<-plot(mal.pheno.pca,type="n",xlim=c(-3,3),ylim=c(-8.2,4)
	,xlab="",ylab="",las=1,cex.axis=1.5)
points(mal.pheno.pca,col=alpha(mal.colors,0.5),cex=ptCex,pch=mal.pch)
mtext(paste0("PC1 (",round(mal.pheno.pc[1],2),"%)"),1,line=2)
mtext(paste0("PC2 (",round(mal.pheno.pc[2],2),"%)"),2,line=2.5)
legend("top",bty='n',c("Male Body Traits"),cex=1.5)

fp<-plot(fem.pheno.pca,type="n",xlab="",ylab="",las=1,cex.axis=1.5,ylim=c(-4,12),
	xlim=c(-3,3))
points(fem.pheno.pca,col=alpha(fem.colors,0.5),cex=ptCex,pch=fem.pch)
mtext(paste0("PC1 (",round(fem.pheno.pc[1],2),"%)"),1,line=2)
mtext(paste0("PC2 (",round(fem.pheno.pc[2],2),"%)"),2,line=2.5)
legend("top",bty='n',c("Female Body Traits"),cex=1.5)

bp<-plot(band.pca,type="n",xlab="",ylab="",las=1,
         cex.axis=1.5,xlim=c(-2,2),ylim=c(-3,1))
points(band.pca,pch=fem.pch,col=alpha(fem.colors,0.5),cex=ptCex)
mtext(paste0("PC1 (",round(band.pc[1],2),"%)"),1,line=2)
mtext(paste0("PC2 (",round(band.pc[2],2),"%)"),2,line=2.5)
legend("top",bty='n',c("Female Band Traits"),cex=1.5)


plot(mp$sites[fw.mal.rows,],type="n",xlab="",ylab="",las=1,cex.axis=1.5)
abline(h=0,lty=3)
abline(v=0,lty=3)
points(mp$sites[fw.mal.rows,],xlim=c(-0.1,0.1),ylim=c(-.2,.2),
	col=alpha(mal.colors[fw.mal.rows],0.5),cex=ptCex,pch=mal.pch[fw.mal.rows])
mtext(paste0("PC1 (",round(mal.pheno.pc[1],2),"%)"),1,line=2)
mtext(paste0("PC2 (",round(mal.pheno.pc[2],2),"%)"),2,line=2.5)


plot(fp$sites[fw.fem.rows,],type="n",xlab="",ylab="",las=1,
	cex.axis=1.5,ylim=c(-4,12),xlim=c(-3,3))
abline(h=0,lty=3)
abline(v=0,lty=3)
points(fp$sites[fw.fem.rows,],
	col=alpha(fem.colors[fw.fem.rows],0.5),cex=ptCex,
	pch=fem.pch[fw.fem.rows])
mtext(paste0("PC1 (",round(fem.pheno.pc[1],2),"%)"),1,line=2)
mtext(paste0("PC2 (",round(fem.pheno.pc[2],2),"%)"),2,line=2.5)


plot(bp$sites[fw.fem.rows,],type="n",xlab="",ylab="",las=1,
	cex.axis=1.5,xlim=c(-2,2),ylim=c(-3,1))
points(bp$sites[fw.fem.rows,],
	pch=fem.pch[fw.fem.rows],col=alpha(fem.colors[fw.fem.rows],0.5),
	cex=ptCex)
mtext(paste0("PC1 (",round(band.pc[1],2),"%)"),1,line=2)
mtext(paste0("PC2 (",round(band.pc[2],2),"%)"),2,line=2.5)
abline(h=0,lty=3)
abline(v=0,lty=3)

par(fig = c(0, 1, 0, 1), oma=c(2,1,0,1), 
    mar = c(0, 0, 0, 0), new = TRUE, cex=1)
plot(0, 0, type = "n", bty = "n", xaxt = "n", yaxt = "n")
legend("top", legend=ppi$Pop, 
	col=as.character(ppi$col),
	pt.cex=ptCex,bty='n',pch=ppi$pch, ncol=8)
```

## Table of summary statistics


```{r readVCFs1, eval=FALSE}
pop_map<-read.delim("../fwsw_pops_map.txt",header = FALSE,stringsAsFactors = FALSE)
ful_vcf<-parse.vcf(
  "filter_rad_20191014@1654/14_filtered/radiator_data_20191014@1710.vcf")
colnames(ful_vcf)<-gsub("\\-","_",colnames(ful_vcf))
```
```{r readSubVCF,eval=FALSE}
sub_vcf<-parse.vcf("stacks/populations_subset75/batch_2.pruned.vcf")
sub_all_vcf<-parse.vcf("stacks/populations_subset75/all_pops_subset75/batch_2.vcf")
# combine the two
sub<-merge(sub_vcf,sub_all_vcf,by="ID",all = TRUE)
rmv<-grep(".y",colnames(sub))
sub<-sub[,-rmv]
colnames(sub)<-gsub(".x","",colnames(sub))
```

```{r popSummaries, eval=FALSE}
pop_summaries<-do.call(rbind,lapply(pop.list,function(pop,ful,sub){
  ful_dat<-ful[,c(1:9,grep(pop,colnames(ful)))]
  sub_dat<-sub[,c(1:9,grep(pop,colnames(sub)))]
  # calc observed het values
  ful_ho<-apply(ful_dat,1,calc.het)
  sub_ho<-apply(sub_dat,1,calc.het)
  # estimate allele freqs
  ful_afs<-do.call(rbind,apply(ful_dat,1,calc.afs.vcf))
  sub_afs<-do.call(rbind,apply(sub_dat,1,calc.afs.vcf))
  # save data frame
  dat<-data.frame(pop=pop,
                  preg_full=length(grep(paste0(pop,"P"),colnames(ful))),
                  preg_sub=length(grep(paste0(pop,"P"),colnames(sub))),
                  nonp_full=length(grep(paste0(pop,"NP"),colnames(ful))),
                  nonp_sub=length(grep(paste0(pop,"NP"),colnames(sub))),
                  nfem_full=length(grep(paste0(pop,"F"),colnames(ful))),
                  nfem_sub=length(grep(paste0(pop,"F"),colnames(sub))),
                  njuv_full=length(grep(paste0(pop,"J"),colnames(ful)))+
                    length(grep(paste0(pop,"DB"),colnames(ful))),
                  njuv_sub=length(grep(paste0(pop,"J"),colnames(sub))) + 
                    length(grep(paste0(pop,"DB"),colnames(sub))),
                  ho_full = mean(ful_ho,na.rm = TRUE),
                  hov_full = var(ful_ho,na.rm = TRUE),
                  ho_sub = mean(sub_ho,na.rm = TRUE),
                  hov_sub = var(sub_ho,na.rm = TRUE),
                  poly_ful = nrow(ful_afs[ful_afs$RefFreq<1,])/nrow(ful_afs)*100,
                  poly_sub = nrow(sub_afs[sub_afs$RefFreq<1,])/nrow(sub_afs)*100,
                  p_full = mean(ful_afs$RefFreq,na.rm=TRUE),
                  pv_full = var(ful_afs$RefFreq,na.rm=TRUE),
                  p_sub = mean(sub_afs$RefFreq,na.rm=TRUE),
                  pv_sub = var(sub_afs$RefFreq,na.rm=TRUE))
  return(dat)
},ful=ful_vcf,sub=sub))
write.csv(pop_summaries,"population_summaries.csv",row.names = FALSE,quote=FALSE)
```

We can merge the genetic info with the environmental info. 
```{r pop_env_summaries}
pop_summaries<-read.csv("population_summaries.csv")
env.data<-data.frame(t(read.csv("bayenv/env_data_raw.csv",row.names = 1)))
env.data$pop<-rownames(env.data)
pop_summaries<-merge(env.data,pop_summaries,by="pop")
```

```{r pretty_sum}
pretty_sum<-data.frame(Population = pop_summaries$pop,
                       Temperature = pop_summaries$temp,
                       Salinity = pop_summaries$salinity,
                       SeagrassDensity=pop_summaries$seagrass,
                       N_Pregnant = paste0(pop_summaries$preg_full,
                                           " (",pop_summaries$preg_sub,")"),
                       N_NonPregnant = paste0(pop_summaries$nonp_full,
                                              " (",pop_summaries$nonp_sub,")"),
                       N_Female = paste0(pop_summaries$nfem_full,
                                         " (",pop_summaries$nfem_sub,")"),
                       N_Juvenile = paste0(pop_summaries$njuv_full,
                                           " (",pop_summaries$njuv_sub,")"),
                       H_o = paste0(round(pop_summaries$ho_full,digits=3),
                                    "\u00B1",round(pop_summaries$hov_full,digits=3),
                                   " (",round(pop_summaries$ho_sub,digits=3),
                                   "\u00B1",round(pop_summaries$hov_sub,digits=3),")"),
                       MinorAlleleFrequency = paste0(
                         round(1-pop_summaries$p_full,digits=3),
                         "\u00B1",round(pop_summaries$pv_full,digits=3),
                         " (",round(1-pop_summaries$p_sub,digits=3),
                         "\u00B1",round(pop_summaries$pv_sub,digits = 3),")"),
                       PercentPolymorphicLoci = paste0(
                         round(pop_summaries$poly_ful,digits=1),
                         " (",round(pop_summaries$poly_sub,digits=1),")"),
                       stringsAsFactors = FALSE)
pretty_sum$Population[pretty_sum$Population=="FLLG"]<-"FLFW"
write.table(pretty_sum,"Table1_populationSummaries.txt",
            sep='\t',col.names = TRUE,quote=FALSE,row.names = FALSE)
```


## Minor allele frequencies

```{r calcAFS, eval=FALSE}
locus.info<-colnames(ful_vcf[1:9])
fw.afs<-lapply(fw.list,function(pop,vcf){
  this.vcf<-cbind(vcf[,locus.info],vcf[,grep(pop,colnames(vcf))])
  this.afs<-do.call(rbind,apply(this.vcf,1,calc.afs.vcf))
}, vcf=ful_vcf)
names(fw.afs)<-c("TXFW","LAFW","ALFW","FLFW")
sw.afs<-lapply(sw.list,function(pop,vcf){
  this.vcf<-cbind(vcf[,locus.info],vcf[,grep(pop,colnames(vcf))])
  this.afs<-do.call(rbind,apply(this.vcf,1,calc.afs.vcf))
},vcf=ful_vcf)
names(sw.afs)<-sw.list
all.afs<-c(fw.afs,sw.afs)
minAF<-lapply(all.afs,function(x){
  mins<-apply(x,1,function(row){ return(min(row[4],row[6])) } )
  return(as.numeric(mins))
})
names(minAF)<-names(all.afs)

```

```{r minorAFplot,fig.height=10,fig.width=8,dpi=300,fig.keep='last', fig.path="../figs/",eval=FALSE}

par(mfrow=c(4,4),mar=c(2,2,1,0),oma=c(2,3,0.5,0.5))
for(i in 1:length(pop.labs)){
  if(pop.labs[i] %in% names(fw.afs)){
    color<-"cornflowerblue"
  }else{
    color<-"black"
  }
  hist(minAF[[pop.labs[i]]],ylab="",xlab="",main="",
       xlim=c(0,0.5),ylim=c(0,10000),axes=F,col=color,
       breaks=seq(0,0.5,0.05))
  axis(1,pos=0,cex.axis=2)
  if(i %in% c(1,5,9,13)){
    axis(2,pos=0,las=1,cex.axis=2,labels = seq(0,10,2),at=seq(0,10000,2000))
  }else{
    axis(2,pos=0,las=1,labels = FALSE,cex.axis=2)
    }
  mtext(pop.labs[i],3,col=color,cex=2*0.75,line=-1)
}
mtext("Minor Allele Frequency",1,outer=TRUE,cex=1.75*0.75)
mtext("Number of SNPs (x 1000)",2,outer = TRUE,cex=1.75*0.75,line=1)

```

![Minor allele frequency distributions of the full dataset (7433 SNPs) for each population. Freshwater populations are plotted in blue. The histograms show the number of SNPs with various frequencies of the reference alleles. All populations are skewed towards having small minor allele frequencies, but the TXFW and FLFW have additional reductions in genetic variation.](../figs/minorAFplot-1.png)


# Population structure of all 16 populations  {-}

## FSTs

This will calculate the pairwise $F_{ST}$s (but it's slow)

```{r pairwiseFstsCalc, eval=FALSE}
pop_map<-read.delim("../fwsw_pops_map.txt",header = FALSE,stringsAsFactors = FALSE)
fst_mat<-matrix(NA,
                nrow=length(unique(pop_map$V2)),ncol=length(unique(pop_map$V2)),
                dimnames = list(pop.list,pop.list))
vcf<-parse.vcf("filter_rad_20191014@1654/14_filtered/radiator_data_20191014@1710.vcf")
colnames(vcf)<-gsub("\\-","_",colnames(vcf)) # fix individual names
# loop through each population pair
for(i in 1:(nrow(fst_mat)-1)){
  for(j in (i+1):ncol(fst_mat)){
    
    if(rownames(fst_mat)[i] != colnames(fst_mat)[j]){ # sanity check
      map1<-pop_map[pop_map[,2]==rownames(fst_mat)[i],]
      map2<-pop_map[pop_map[,2]==colnames(fst_mat)[j],]
      pwfsts<-gwsca(vcf,colnames(vcf)[1:9],map1[,1],map2[,1])
      fst_mat[i,j]<-mean(pwfsts$Fst,na.rm = TRUE)
    }
  }
}
colnames(fst_mat)<-rownames(fst_mat)<-pop.labs
write.table(fst_mat,"pairwise_fsts_full.txt",sep='\t',
            col.names = TRUE,row.names=TRUE,quote=FALSE)
```

```{r readStacksFstSumm}
full_fsts<-read.delim("stacks/populations_whitelist/batch_2.fst_summary.tsv",
                      row.names = 1)
full_fsts<-rbind(full_fsts,TXSP=rep(NA,ncol(full_fsts))) #add the final row
Tfull_fsts<-t(full_fsts)
full_fsts[lower.tri(full_fsts)]<-Tfull_fsts[lower.tri(Tfull_fsts)] # now it's symmetric
full_fsts<-full_fsts[pop.list,pop.list]
colnames(full_fsts)<-rownames(full_fsts)<-pop.labs
fst_mat<-as.matrix(full_fsts)
```


```{r fst_heatmaps,fig.width=8,fig.height=5,eval=FALSE}
library(lattice); library(grid); library(RColorBrewer)
poporder<-read.delim("treemix/poporder")
colors<-poporder$colors
poporder<-poporder$poporder

nr<-treemix.cov.plot("treemix/fwsw_k100b",poporder)
dimnames(nr)[[1]]<-dimnames(nr)[[2]]<-pop.labs
# colors
colors<-c("black","darkgrey","grey","lightgrey","cornflowerblue")
pal<-colorRampPalette(colors)
ncol=80
cols<-pal(ncol)
rev.colors<-c("cornflowerblue","lightgrey","grey","darkgrey","black")
rev.pal<-colorRampPalette(rev.colors)
rev.cols<-rev.pal(ncol)

hm.height<-list(x=2,units="in")#2.2/3.8
hm.width<-list(x=2.4,units="in")#2.4 in RStudio/3.9

heatmaps.name<-"../figs/fst_heatmaps.png"

png(heatmaps.name,height=5,width=8,units="in",res=300)

fst.lv<-levelplot(as.matrix(fst_mat),col.regions=cols,alpha.regions=0.7,
                  scales = list(x=list(rot=90),tck = 0),xlab="",ylab="")
print(fst.lv,split=c(1,1,2,1),more=TRUE,panel.width=hm.width,
      panel.height=hm.height,cex=2)
trellis.focus("legend", side="right", clipp.off=TRUE, highlight=FALSE)
grid.text(expression(italic(F)[ST]), 0.2, 0, hjust=0.5, vjust=1.2,gp=gpar(cex=0.75))
trellis.unfocus()

nr.lv<-levelplot(nr,col.regions=cols,alpha.regions=0.7,
                 scales = list(x=list(rot=90),tck = 0),xlab="",ylab="")
print(nr.lv,split=c(2,1,2,1),more=FALSE,newpage=FALSE,panel.width=hm.width,
      panel.height=hm.height,cex=2)
trellis.focus("legend", side="right", clipp.off=TRUE, highlight=FALSE)
grid.text("Treemix", 0.2, 0, hjust=0.5, vjust=1.2,gp=gpar(cex=0.75))
trellis.unfocus()

dev.off()

```

![Heatmaps depicting population structure. In all graphs, dark colors depict similarity between populations and light grey and blue depict populations with high differentiation. The left panel shows pairwise FST values calculated by the populations module in Stacks (Catchen et al. 2013). The right panel shows covariances between populations as calculated by TreeMix (Pickrell and Pritchard 2012).](../figs/fst_heatmaps.png)


## PCAdapt {-}


```{r loadPCAdapt}
library(pcadapt)
```

````{r pcadapt_choose,fig.cap="Scree plot from PCAdapt, specifying keeping 20 PC axes."}
filename<-read.pcadapt("filter_rad_20191014@1654/14_filtered/radiator_data_20191014@1710.vcf",
                       type="vcf")
x<-pcadapt(filename, K=20)
plot(x,option="screeplot") #K=7
```

```{r pcadapt_analyze}
pa<-pcadapt(filename,K=7)
saveRDS(pa,"fwsw_all_pcadapt.RDS")
pa.props<-round((pa$singular.values/sum(pa$singular.values))*100,2)
kable(pa.props,caption="Proportion of variation explained by all 7 of the retained PC axes in PCAdapt")
```
```{r pcadaptSummarize}
ind_dat<-read.table(
  "filter_rad_20191014@1654/14_filtered/individuals.qc.stats_20191014@1654.tsv",
  header=T, stringsAsFactors = F)
pops<-ind_dat$STRATA	
grp<-pops
grp[grp=="TXFW" | grp=="LAFW" | grp=="ALFW" | grp=="FLLG"]<-"freshwater"
grp[grp!="freshwater"]<-"saltwater"

#colors
pap<-data.frame(Pop=pops,cols=pops,pch=pops,grp=grp,stringsAsFactors = F)
pap$Pop[pap$Pop == "FLLG"]<-"FLFW"
for(i in 1:nrow(pap)){
  pap[i,"cols"]<-as.character(ppi[ppi$Pop %in% pap[i,"Pop"],"cols"])
}
for(i in 1:nrow(pap)){
  pap[i,"pch"]<-as.numeric(ppi[ppi$Pop %in% pap[i,"Pop"],"pch"])
}
write.table(pap,"pcadapt_colp.txt",col.names=TRUE,sep='\t',quote=F)

```


```{r plot_pcadapt_initial, fig.height=8,fig.width=10.5,dev='png',fig.dim="in",fig.cap="Principal components analysis of genotypes in S. scovelli reveals population structure due to geographic distance and habitat type. The top set of panels show the results of the PCA with all 16 populations, color-coded by populations and point shape. The bottom set of panels show the same PCA results, but with different x- and y-axis scaling and without the saltwater populations plotted, to facilitate visualizing the differences among saltwater populations. The left panels show the first and second PC axes, whcih together account for 53.5% of the varation, the middle panels show the 3rd and 4th PC axes (another 26.8% of the variation), and the right panels the fifth and sixth axes (another % of variation)."}

#plot
par(mfrow=c(2,3),oma=c(2,2,2,2),mar=c(2,2,2,2))
plot(pa$scores[,1],pa$scores[,2],col=alpha(pap$cols,0.5),bg=alpha(pap$cols,0.75),
     pch=as.numeric(pap$pch),	cex=1.5)
mtext(paste("PC1 (",pa.props[1],"%)",sep=""),1,line = 2,cex=0.75)
mtext(paste("PC2 (",pa.props[2],"%)",sep=""),2,line = 2,cex=0.75)
plot(pa$scores[,3],pa$scores[,4],col=alpha(pap$cols,0.5),
     bg=alpha(pap$cols,0.75),pch=as.numeric(pap$pch),cex=1.5)
mtext(paste("PC3 (",pa.props[3],"%)",sep=""),1,line = 2,cex=0.75)
mtext(paste("PC4 (",pa.props[4],"%)",sep=""),2,line = 2,cex=0.75)
plot(pa$scores[,5],pa$scores[,6],col=alpha(pap$cols,0.5),
     bg=alpha(pap$cols,0.75),pch=as.numeric(pap$pch),cex=1.5)
mtext(paste("PC5 (",pa.props[5],"%)",sep=""),1,line = 2,cex=0.75)
mtext(paste("PC6 (",pa.props[6],"%)",sep=""),2,line = 2,cex=0.75)
plot(pa$scores[grp=="freshwater",1],pa$scores[grp=="freshwater",2],
     col=alpha(pap$cols[pap$grp=="freshwater"],0.5),
     bg=alpha(pap$cols[pap$grp=="freshwater"],0.75),
     pch=as.numeric(pap$pch[pap$grp=="freshwater"]),
	cex=1.5)
mtext(paste("PC1 (",pa.props[1],"%)",sep=""),1,line = 2,cex=0.75)
mtext(paste("PC2 (",pa.props[2],"%)",sep=""),2,line = 2,cex=0.75)
plot(pa$scores[grp=="freshwater",3],pa$scores[grp=="freshwater",4],
     col=alpha(pap$cols[pap$grp=="freshwater"],0.5),
     bg=alpha(pap$cols[pap$grp=="freshwater"],0.75),
     pch=as.numeric(pap$pch[pap$grp=="freshwater"]),
	cex=1.5)
mtext(paste("PC3 (",pa.props[3],"%)",sep=""),1,line = 2,cex=0.75)
mtext(paste("PC4 (",pa.props[4],"%)",sep=""),2,line = 2,cex=0.75)
plot(pa$scores[grp=="freshwater",5],pa$scores[grp=="freshwater",6],
     col=alpha(pap$cols[pap$grp=="freshwater"],0.5),
     bg=alpha(pap$cols[pap$grp=="freshwater"],0.75),
     pch=as.numeric(pap$pch[pap$grp=="freshwater"]),
	cex=1.5)
mtext(paste("PC5 (",pa.props[5],"%)",sep=""),1,line = 2,cex=0.75)
mtext(paste("PC6 (",pa.props[6],"%)",sep=""),2,line = 2,cex=0.75)

par(fig = c(0, 1, 0, 1), oma=c(2,1,0,1), mar = c(0, 0, 0, 0), new = TRUE,
	cex=1)
plot(0, 0, type = "n", bty = "n", xaxt = "n", yaxt = "n")

legend("top", legend=ppi$Pop, pch=as.numeric(ppi$pch), pt.cex=1.5,cex=0.85,
       col=alpha(ppi$cols, 0.5),pt.bg=alpha(ppi$cols,0.25), ncol=8,bty='n')

```




## Admixture scree plots {-}


```{r admixScree,fig.cap="Admixture screeplot for K=1 through K=16. The coefficient of variation (CV) is shown on the y-axis."}
admixK<-read.delim("admixture/K_CVs.txt",header = FALSE)
admixK$K<-as.numeric(gsub(".*\\(K=(\\d+)\\).*","\\1",admixK$V1))
admixK$CV<-as.numeric(gsub("^.*\\: (\\d+\\.\\d+)$","\\1",admixK$V1))

admixK<-admixK[order(admixK$K),]

plot(admixK$K,admixK$CV,pch=19,type = "b",lty=1,xlab = "K",ylab="CV",las=1,lwd=2)

```

Looks like $K=5$ or $K=7$ are the best, let's look at all of the $K=2$ through $K=7$.

```{r admixSetup}
library(RColorBrewer)
famfile<-"admixture/fwsw_all_filt.fam"

poporderFile<-"treemix/poplist"
poporderDF<-read.table(poporderFile,col.names = c("Pop"),stringsAsFactors = F)
poporderDF$orderNum<-1:nrow(poporderDF)
```

```{r plotAdmixFxn}
admixPlotting<-function(qfile,K,famfile="admixture/fwsw_all_filt.fam",
                        poporder=poporderDF){
  # read files in 
  famTable<- read.table(famfile, col.names = 
                        c("Pop","Ind","Father","Mother","Sex","phenotype"),
                      stringsAsFactors = F)[1:2]

  qtbl<-read.table(qfile,stringsAsFactors = F)
  
  # create useful tables
  mergedAdmixtureTable <- cbind(qtbl, famTable)
  mergedAdmixTabOrderNs <- merge(mergedAdmixtureTable,poporder,by="Pop")
  ordered <- mergedAdmixTabOrderNs[order(mergedAdmixTabOrderNs$orderNum),]
  
  plotting.structure(ordered[,1:(ncol(ordered)-2)],k = K,
                     pop.order = poporder$Pop,make.file = FALSE)
  admix<-ordered[,1:(ncol(ordered)-2)]
  return(admix)
}
```

```{r admix_K2,fig.height=2,fig.width=8,fig.cap="Admixture plot for K=2. The colors represent different genetic populations."}
admixK2<-admixPlotting("admixture/fwsw_all_filt.2.Q",2)
```

```{r admix_K3,fig.height=2,fig.width=8,fig.cap="Admixture plot for K=3. The colors represent different genetic populations."}
admixK3<-admixPlotting("admixture/fwsw_all_filt.3.Q",3)
```
```{r admix_K4,fig.height=2,fig.width=8,fig.cap="Admixture plot for K=4. The colors represent different genetic populations."}
admixK4<-admixPlotting("admixture/fwsw_all_filt.4.Q",4)
```

```{r admix_k5,fig.height=2,fig.width=8,fig.cap="Admixture plot for K=5. The colors represent different genetic populations."}
admixK5<-admixPlotting("admixture/fwsw_all_filt.5.Q",5)
write.table(admixK5,"admixture/admixK5.txt",sep = '\t',
            quote = FALSE,col.names = TRUE,row.names = FALSE)
```

```{r admixk6,fig.height=2,fig.width=8,fig.cap="Admixture plot for K=6. The colors represent different genetic populations."}
admixK6<-admixPlotting("admixture/fwsw_all_filt.6.Q",6)
```

```{r admixk7,fig.height=2,fig.width=8,fig.cap="Admixture plot for K=7. The colors represent different genetic populations."}
admixK7<-admixPlotting("admixture/fwsw_all_filt.7.Q",7)
write.table(admixK7,"admixture/admixK7.txt",sep = '\t',quote = FALSE,col.names = TRUE,row.names = FALSE)
```


## Treemix analysis {-}


```{r treemixPoporder}
poporder<-c("TXSP","TXCC","TXFW","TXCB","LAFW","ALST",
            "ALFW","FLSG","FLKB","FLFD","FLSI","FLAB",
            "FLPB","FLHB","FLCC","FLLG")
colors<-poporder
colors[colors %in% "FLLG"]<-grp.colors[6]
colors[colors %in% c("FLPB","FLHB","FLCC")]<-grp.colors[6]
colors[colors %in% c("FLAB")]<-grp.colors[5]
colors[colors %in% c("FLSI","FLFD","FLKB","FLSG")]<-grp.colors[3]
colors[colors %in% c("ALST","ALFW","LAFW")]<-grp.colors[2]
colors[colors %in% c("TXSP","TXCC","TXFW","TXCB")]<-grp.colors[1]
write.table(cbind(poporder,colors),"poporder",quote=F,sep='\t')
```

### Tree with no migration edges and no root

It's informative to plot the treemix tree that does not have any migration edges added for comparison later.

```{r treemixPrep, results='hide', fig.show='true',fig.cap="The population tree from running Treemix without any migration edges (left) and the resulting residuals (right). No populations were specified as root in this analysis."}
source("../R/203_treemix_plotting_funcs.R") #I've modified the functions from treemix
library(lattice); library(grid); library(RColorBrewer)
poporder<-read.delim("treemix/poporder")
colors<-poporder$colors
poporder<-poporder$poporder
par(mfrow=c(1,2),oma=c(2,2,2,2),mar=c(2,2,2,2))
tree<-plot_tree("treemix/fwsw_k100b",plotmig=F,scale=F,mbar=F,plus=0.05)
mtext("Drift parameter",1,line=2)
resid<-plot_resid("treemix/fwsw_k100b","treemix/poporder",wcols="rb")

```

### Tree with FLPB as root

We ran Treemix assuming the FLPB was the root with 0 through 5 migration edges. We can compare the residuals, trees, and migration edges, with the root-free, no-migration tree included for comparison. 

```{r treemixCovPlots,eval=FALSE,echo=FALSE,fig.cap="The Treemix covariance plots."}
nr<-treemix.cov.plot("treemix/fwsw_k100b",poporder)
m0<-treemix.cov.plot("treemix/fwsw_k100bFLPBr",poporder,split=c(1,1,3,2),more=TRUE)
m1<-treemix.cov.plot("treemix/fwsw_k100bFLPBrm1",poporder,split=c(2,1,3,2),more=TRUE)
m2<-treemix.cov.plot("treemix/fwsw_k100bFLPBrm2",poporder,split=c(3,1,3,2),more=TRUE)
m3<-treemix.cov.plot("treemix/fwsw_k100bFLPBrm3",poporder,split=c(1,2,3,2),more=TRUE)
m4<-treemix.cov.plot("treemix/fwsw_k100bFLPBrm4",poporder,split=c(2,2,3,2),more=TRUE)
m5<-treemix.cov.plot("treemix/fwsw_k100bFLPBrm5",poporder,split=c(3,2,3,2),more=FALSE)
```



```{r TreemixPlotResids, results='hide', fig.show='true',fig.height=7,fig.width=7,fig.cap="The Treemix residual plots. Shown are the tree with no root and no migration edges (top left), the tree with FLPB as root but no migration edges (top center), the tree with FLPB as root and one migration edge (top right), the tree with FLPB as root and two migration edges (middle left), the tree with FLPB as root and three migration edges (middle center), the tree with FLPB as root and four migration edges (middle right), and the tree with FLPB as root and five migration edges (bottom left)."}
# visualize residuals
#png("treemix/treemix-residuals_FLPB.png",height=8,width=8,units="in",res=300)
par(mfrow=c(3,3),mar=c(2,3,1,1),oma=c(1.5,1.5,1,1))
t0<-plot_resid("treemix/fwsw_k100b",  "treemix/poplist")
r0<-plot_resid("treemix/fwsw_k100bFLPBr",  "treemix/poplist")
r1<-plot_resid("treemix/fwsw_k100bFLPBrm1","treemix/poplist")
r2<-plot_resid("treemix/fwsw_k100bFLPBrm2","treemix/poplist")
r3<-plot_resid("treemix/fwsw_k100bFLPBrm3","treemix/poplist")
r4<-plot_resid("treemix/fwsw_k100bFLPBrm4","treemix/poplist")
r5<-plot_resid("treemix/fwsw_k100bFLPBrm5","treemix/poplist")
#dev.off()
```



```{r plotTreemixTrees, results='hide', fig.show='true',fig.height=8,fig.cap="The Treemix trees for each model. Shown are the tree with no root and no migration edges (top left), the tree with FLPB as root but no migration edges (top center), the tree with FLPB as root and one migration edge (top right), the tree with FLPB as root and two migration edges (middle left), the tree with FLPB as root and three migration edges (middle center), the tree with FLPB as root and four migration edges (middle right), and the tree with FLPB as root and five migration edges (bottom left). The drift parameters are shown on the x-axis, and the migration weight bar is included in the top center plot."}
# look at the trees
#png("treemix/migration_trees_treemix_FLPB.png",height=6,width=11,units="in",res=300)
par(mfrow=c(3,3),mar=c(1,1,1,1),oma=c(1,1,1,1))
r0<-plot_tree("treemix/fwsw_k100b",plus=0.05,plotmig = F,scale=T,mbar=F)
t0<-plot_tree("treemix/fwsw_k100bFLPBr",plotmig = F,plus=0.05,scale=T,mbar=T)
t1<-plot_tree("treemix/fwsw_k100bFLPBrm1",plus=0.05,scale=F,mbar=F)
t2<-plot_tree("treemix/fwsw_k100bFLPBrm2",plus=0.05,scale=F,mbar=F)
t3<-plot_tree("treemix/fwsw_k100bFLPBrm3",plus=0.05,scale=F,mbar=F)
t4<-plot_tree("treemix/fwsw_k100bFLPBrm4",plus=0.05,scale=F,mbar=F)
t5<-plot_tree("treemix/fwsw_k100bFLPBrm5",plus=0.05,scale=F,mbar=F)
#dev.off()
```
```{r migrationPvalues, results='hide', fig.show='true'}
# Evaluate migration p-values
nort0<-read.table(gzfile("treemix/fwsw_k100b.treeout.gz"), 
                  as.is  = T, comment.char = "", quote = "")
tree0<-read.table(gzfile("treemix/fwsw_k100bFLPBr.treeout.gz"), 
                  as.is  = T, comment.char = "", quote = "")
tree1<-read.table(gzfile("treemix/fwsw_k100bFLPBrm1.treeout.gz"), 
                  as.is  = T, comment.char = "", quote = "",skip=1)
tree2<-read.table(gzfile("treemix/fwsw_k100bFLPBrm2.treeout.gz"), 
                  as.is  = T, comment.char = "", quote = "",skip=1)
tree3<-read.table(gzfile("treemix/fwsw_k100bFLPBrm3.treeout.gz"), 
                  as.is  = T, comment.char = "", quote = "",skip=1)
tree4<-read.table(gzfile("treemix/fwsw_k100bFLPBrm4.treeout.gz"), 
                  as.is  = T, comment.char = "", quote = "",skip=1)
tree5<-read.table(gzfile("treemix/fwsw_k100bFLPBrm5.treeout.gz"), 
                  as.is  = T, comment.char = "", quote = "",skip=1)
```
```{r TreemixVertices, results='hide', fig.show='true'}
d <- read.table("treemix/fwsw_k100bFLPBrm3.vertices.gz", 
                as.is  = T, comment.char = "", quote = "")
branch.cols<-rep("black",nrow(d))
branch.cols[d[,2] %in% c("TXFW","ALFW","LAFW","FLLG")]<-"cornflowerblue"

tip.names<-as.vector(d[d[,5] == "TIP",2])
tip.names<-data.frame(Original=tip.names,Replacement=tip.names,
                      stringsAsFactors = FALSE)
tip.names$Replacement[tip.names$Replacement=="FLLG"]<-"FLFW"
```
```{r FWSW_treemix_m3_FLPB,fig.height=7,fig.width=7, results='hide', fig.show='true',include=FALSE}
png("../figs/FWSW_treemix_m3_FLPB.png",height=7,width=7,units="in",res=300)
t3<-plot_tree("treemix/fwsw_k100bFLPBrm3","poporder",
              plus=0.05,scale=F,mbar=F,arrow=0.1,tip.order = tip.names)
ybar<-0.01
mcols = rev( heat.colors(150) )
mcols = mcols[50:length(mcols)]
ymi = ybar+0.15
yma = ybar+0.35
l = 0.2
w = l/100
xma = max(t3$d$x/20)
rect( rep(0.15, 100), ymi+(0:99)*w, rep(0.15+xma, 100), ymi+(1:100)*w, 
      col = mcols, border = mcols)
text(0.15+xma+0.001, ymi, lab = "0", adj = 0, cex = 0.7)
text(0.15+xma+0.001, yma, lab = "0.5", adj = 0, cex =0.7)
text(0.15, yma+0.06, lab = "Migration", adj = 0 , cex = 0.6)
text(0.15, yma+0.03, lab = "weight", adj = 0 , cex = 0.6)
dev.off()

```


### Choosing the optimal number of migration edges

To choose the optimal number of migration edges, we used the R package optM [@fitak_optm:_2019].


```{r plotOptM,message=FALSE,fig.show='true',fig.cap="Scree plot showing the comparison of Treemix number of migration edges."}
library(OptM)
tmOpt<-optM("treemix")
plot_optM(tmOpt,plot = TRUE)
```

Let's plot the no-migration-edge tree with the two-migration-edge tree, which optM chose as the best fit using the Evanno method.

```{r treemixCompare,results='hide'}
png("../figs/treemix_comparison.png",height = 4.5,width=8,units="in",res=300)
par(mfrow=c(1,2),mar=c(1,1,1,2),oma=c(1,1,1,2),xpd=TRUE)
t0<-plot_tree("treemix/fwsw_k100bFLPBr",scale=T,mbar=F,cex = 1.5,
              lwd=2,mig_left=FALSE,disp=0.0002,scadj=0.05)
t2<-plot_tree("treemix/fwsw_k100bFLPBrm2",scale=T,mbar=T,cex = 1.5,
              lwd=2,mig_left=FALSE,disp=0.0002,scadj=0.05)
dev.off()
```
![The plot of the tree with FLPB as root but no migration edges (left) compared to the tree with FLPB as root and two migration edges. The drift parameter is plottex on the x-axis, and migration edges are colored based on the migration weight.](../figs/treemix_comparison.png)


### Threepop and fourpop analysis
 
We can take a closer look at the two migration edges that are in the best Treemix model using threepop and fourpop analyses. In the threepop analysis, significantly negative f3 statistics mean that the first pop in the list (A in A;B,C) is admixed. Therefore, with the threepop analysis we want to look for the tree (A;B,C) where A corresponds to the end of an arrow and (B,C) corresponds to where an arrow begins. In the fourpop analysis, a significantly non-zero value indicates gene flow in the tree.

```{r readf3f4}
threepop<-data.frame(do.call(rbind,
                             strsplit(grep(
                               ";",readLines("treemix/fwsw_threepop.txt"),
                               value = TRUE),' ')))
colnames(threepop)<-c("pops","f3_stat","f3_se","f3_z")
threepop$f3_p<-pnorm(-abs(as.numeric(as.character(threepop$f3_z)))) # one sided

fourpop<-data.frame(do.call(rbind,
                            strsplit(grep(";",
                                          readLines("treemix/fwsw_fourpop_1.txt"),
                                          value = TRUE),' ')))
colnames(fourpop)<-c("pops","f4_stat","f4_se","f4_z")
fourpop$f4_p<-2*pnorm(-abs(as.numeric(as.character(fourpop$f4_z))))
```




**Edge 1: FLSI/FLAB -> TXFW/TX**

```{r f3Edge1Old, include=FALSE}
threepop[grep("FLSI;.*TXFW",threepop$pops),] # use this to see the order that I want
threepop[threepop$pops=="FLSI;TXFW,FLAB",] 
# This does not have a negative value so FLSI is not admixed -- but that's not really what's interesting, is it?
```


```{r f3Edge1}
kable(threepop[grep("TXFW;.*FLSI",threepop$pops),] )
```

None of these f3 statistics are zero, so that suggests that TXFW is not admixed with FLSI and other populations. Most interesting would be the trees (TXFW;TXCB,FLSI) and (TXFW,FLSI,FLAB):

```{r f3Edge1Specific}
kable(threepop[threepop$pops=="TXFW;TXCB,FLSI" | 
           threepop$pops=="TXFW;FLSI,FLAB",] )
```



```{r f4Edge1}
kable(fourpop[grep("TXFW,TXCB;.*FLSI.*",fourpop$pops),] )
kable(fourpop[fourpop$pops=="TXFW,TXCB;FLSI,FLAB",] )
as.numeric(as.character(fourpop$f4_stat[fourpop$pops=="TXFW,TXCB;FLSI,FLAB"]))+
  as.numeric(as.character(fourpop$f4_se[fourpop$pops=="TXFW,TXCB;FLSI,FLAB"]))
```

The statistic is negative but overlaps with zero, so not indicative of gene flow. 


**Edge 2: branch from west FL to others -> FLAB**

```{r f3Edge2}
kable(threepop[grep("FLAB;.*",threepop$pops),] )
kable(threepop[threepop$pops=="FLAB;FLPB,FLLG",])
```

Inspecting this three-population tree (FLAB;FLPB,FLLG) shows that the statistic is positive does not overlap with zero, and none of the FLAB values are negative, suggesting that this migration edge is unlikely to represent admixture. 

```{r f4Edge2}
kable(fourpop[grep("FLAB,FL.*;.*",fourpop$pops),] )
kable(fourpop[fourpop$pops=="FLAB,FLCC;FLPB,FLLG",] )
as.numeric(as.character(fourpop$f4_stat[fourpop$pops=="FLAB,FLCC;FLPB,FLLG"]))+
  as.numeric(as.character(fourpop$f4_se[fourpop$pops=="FLAB,FLCC;FLPB,FLLG"]))
```

This is negative but overlaps zero, so is also not indicative of gene flow. 

```{r f4Edge2Contd}
fourpop$f4_stat<-as.numeric(as.character(fourpop$f4_stat))
fourpop$f4_se<-as.numeric(as.character(fourpop$f4_se))
abs(fourpop$f4_stat[grep("FLAB,FL.*;.*",fourpop$pops)])-
  fourpop$f4_se[grep("FLAB,FL.*;.*",fourpop$pops)]
```

All of these f4 statistics are very close to zero, which suggests that there is not much evidence for gene flow between these branches.

## Make figure

```{r defineColors}
grp.colors<-c('#762a83','#af8dc3','#e7d4e8','#d9f0d3','#7fbf7b','#1b7837') 
grp7colors<-c('#762a83','#9970ab','#c2a5cf','#d9f0d3','#a6dba0','#5aae61','#1b7837')
grp5colors<-c('#762a83','#c2a5cf','#a6dba0','#5aae61','#1b7837')
```

```{r NewPopStructurePrep,eval=TRUE,results='hide'}
#admixture 
admixK5<-read.delim("admixture/admixK5.txt",header = TRUE)
admixK7<-read.delim("admixture/admixK7.txt",header = TRUE)
#pcadapt
pa<-readRDS("fwsw_all_pcadapt.RDS")
pa.props<-round((pa$singular.values/sum(pa$singular.values))*100,2)
pap<-read.delim("pcadapt_colp.txt",sep='\t')
# map
library(jpeg)
img<-readJPEG("all_sites_map.jpeg")

# stuff for treemix
source("../R/203_treemix_plotting_funcs.R") #I've modified the functions from treemix
library(lattice); library(grid); library(RColorBrewer)
poporder<-read.delim("treemix/poporder")
colors<-poporder$colors
poporder<-poporder$poporder

```


```{r NewPopStructure_v1,eval=TRUE,results='hide'}
npop<-length(pop.list)
pseq<-1:npop
m<-matrix(c(rep(1,16),rep(2,6),
            3:18,rep(2,6),
            19:34,rep(2,6),
            rep(35,8),rep(36,8),rep(37,6)),
          nrow=4,ncol=npop+6,byrow = T)
jpeg("../figs/NewPopStructure_v1.jpeg",res=300,height=8,width=10,units="in")
#set the layout
layout(mat=m,heights=c(6,1,1,6))
#MAP
#open an empty plot window with coordinates
par(oma=c(1.5,3.5,1,2),mar=c(0,0,0,0),xpd=NA)
plot(1:14,ty="n",axes=FALSE,xlab="",ylab="",xpd=TRUE)
#specify the position of the image through bottom-left and top-right coords
rasterImage(img,1,1,14,14,xpd=TRUE)
text(x = 1.5,y=11.5,"A",cex = 2,font =2)
text(x = 0.5,y=1.2,"C",cex = 2,font =2)

#Treemix
par(mar=c(0,0,0,1))
t2<-plot_tree("treemix/fwsw_k100bFLPBrm2",scale=T,mbar=T,cex = 1.5,
              lwd=2,mig_left=FALSE,disp=0.0002,scadj=0.05)
text(x = 0.035,y=0.9,"B",cex = 2,font =2)
#STRUCTURE
par(mar=c(1,0,0,0))
plotting.structure(admixK5,5,pop.order = poporder, pop.list, make.file=FALSE, 
                   xlabcol = all.colors,plot.new=FALSE,
                   colors=grp5colors[c(3,5,4,1,2)],xlabel=FALSE,
                   ylabel=expression(atop(italic(K)==5)),lab.cex=0.85)
plotting.structure(admixK7,7,pop.order = poporder,pop.labs, make.file=FALSE,
                   plot.new=FALSE,colors=grp7colors[c(6,7,1,2,5,3,4)],xlabel=TRUE,
                   xlabcol = all.colors,
                   ylabel=expression(atop(italic(K)==7)),lab.cex=0.85)

#PCADAPT
par(mar=c(2,2,2,2))
plot(pa$scores[,1],pa$scores[,2],col=alpha(pap$cols,0.5),bg=alpha(pap$cols,0.75),
     pch=as.numeric(pap$pch),	cex=3,bty="L",xlab="",ylab="",cex.axis=1.5)

mtext(paste("PC1 (",pa.props[1],"%)",sep=""),1,line = 2.5,cex=1)
mtext(paste("PC2 (",pa.props[2],"%)",sep=""),2,line = 2.5,cex=1)
text(x = -0.07,y=0.1,"D",cex = 2,font =2)

plot(pa$scores[,3],pa$scores[,4],col=alpha(pap$cols,0.5),bg=alpha(pap$cols,0.75),
     pch=as.numeric(pap$pch),
     cex=3,	bty="L",xlab="",ylab="",cex.axis=1.5)

mtext(paste("PC3 (",pa.props[3],"%)",sep=""),1,line = 2.5,cex=1)
mtext(paste("PC4 (",pa.props[4],"%)",sep=""),2,line = 2.5,cex=1)

plot(1:10,ty="n",axes=FALSE,xlab="",ylab="",xpd=TRUE)
legend("bottom", legend=ppi$Pop, pch=as.numeric(ppi$pch), pt.cex=3,cex=1.5,
       col=alpha(ppi$cols, 0.5),pt.bg=alpha(ppi$cols,0.25), ncol=2,bty='n')
dev.off()
```

![Population Structure summary plot (Figure 1 in main document)](../figs/NewPopStructure_v1.jpeg)


## Make table


```{r fstMatrix}
full_fsts<-read.delim("stacks/populations_whitelist/batch_2.fst_summary.tsv",
                      row.names = 1)
full_fsts<-rbind(full_fsts,TXSP=rep(NA,ncol(full_fsts))) #add the final row
Tfull_fsts<-t(full_fsts)
full_fsts[lower.tri(full_fsts)]<-Tfull_fsts[lower.tri(Tfull_fsts)] # now it's symmetric
full_fsts<-full_fsts[pop.list,pop.list]
colnames(full_fsts)<-rownames(full_fsts)<-pop.labs
fst_mat<-as.matrix(full_fsts)
```

```{r covPlot,results='hide',fig.show='true'}
cov<-read.table(gzfile("treemix/fwsw_k100b.cov.gz"), as.is = T, head = T, quote = "", 
                comment.char = "")
#reorder
covplot <- data.frame(matrix(nrow = nrow(cov), ncol = ncol(cov)))
for(i in 1:length(pop.list)){
  for( j in 1:length(pop.list)){
    
    covplot[i, j] = cov[which(names(cov)==pop.list[i]), which(names(cov)==pop.list[j])]
    rownames(covplot)[i]<-pop.list[i]
    colnames(covplot)[j]<-pop.list[j]
  }
}
covplot<-as.matrix(covplot)


```
```{r createFstExcel,eval=FALSE}
library(xlsx); library(RColorBrewer); library(scales)

table2<-fst_mat
table2[lower.tri(table2)]<-covplot[lower.tri(covplot)]
diag(table2)<-diag(covplot)
table2<-round(table2,digits = 4)

# first export the data
sheetName <- "FstCov"
file<-"table2_fst_cov.xlsx"
write.xlsx(table2,file,sheetName = sheetName)

wb<-loadWorkbook(file)
sheets <- getSheets(wb)               
sheet <- sheets[[sheetName]]          
rows <- getRows(sheet, rowIndex=2:(nrow(table2)+1)) # 1st row is headers
cells <- getCells(rows, colIndex = 2:(ncol(table2)+1)) # 1st col is rownames         
values<-lapply(cells,getCellValue)

# set the colors
pal<-colorRampPalette(c("#deebf7","#3182bd"))
cols<-matrix(nrow = nrow(table2),ncol=nrow(table2))
cols[upper.tri(cols)]<-pal(10)[as.numeric(cut(table2[upper.tri(table2)],breaks = 10))]
pal<-colorRampPalette(c("#78c679","#f7fcb9"))
cols[lower.tri(cols)]<-pal(10)[as.numeric(cut(table2[lower.tri(table2)],breaks = 10))]
pal<-colorRampPalette(c("#f7f7f7","#969696"))
diag(cols)<-pal(10)[as.numeric(cut(diag(table2),breaks = 10))]

for(i in 1:nrow(table2)){
  for(j in 1:ncol(table2)){
    csij<-CellStyle(wb,fill=Fill(foregroundColor = alpha(cols[i,j])))
    setCellStyle(cells[[paste(i+1,j+1,sep=".")]],cellStyle = csij)
  }
}

saveWorkbook(wb, file)
```



# Outliers: Fsts from Stacks, permutations, PCadapt  {-}

The alignments were done with a preliminary genome assembly that is different from the published, updated one. The data that I need to convert are the vcf and the stacks files. 



```{r convert_agp}

convert.agp<-function(locus=NULL,old.agp,old.scf,new.agp,scf.agp,
                      chr=NULL,bp=NULL,id=NULL){
  
  if(!is.null(locus)){
    chr<-locus$`#CHROM`
    bp<-locus$POS
    id<-locus$ID
  }else{
    bp<-as.numeric(unlist(bp))
    chr<-as.character(chr)
    id<-as.character(id)
  }
  component<-as.data.frame(old.agp[old.agp$object == chr & 
                                     old.agp$object_beg <= bp & 
                                     old.agp$object_end >= bp,],
                           stringsAsFactors=FALSE)
  if(nrow(component)>0){
    # it's found on one of the LGs
    comp.id<-component$component_id
    if(comp.id != 100){
      #make sure it's an actual scaffold as a component
      comp.bp<-as.numeric(as.character(component$component_beg))+
        (bp-as.numeric(as.character(component$object_beg)))-1
      #sanity check - is it a reasonable size?
      if(comp.bp<as.numeric(as.character(component$component_end))){ 
        updated<-new.agp[new.agp$component_id%in%comp.id & 
                  as.numeric(as.character(new.agp$component_beg)) <=comp.bp & 
                  as.numeric(as.character(new.agp$component_end)) >= comp.bp,]
        if(nrow(updated)==0){ #if you didn't find it, check scaffold
          updated<-scf.agp[scf.agp$object%in%comp.id & 
                  as.numeric(as.character(scf.agp$object_beg)) <=comp.bp & 
                  as.numeric(as.character(scf.agp$object_end)) >= comp.bp,]
          updated.bp<-comp.bp
          updated.chr<-as.character(comp.id)
        } else{
          updated.bp<-updated$object_beg+comp.bp
          updated.chr<-as.character(updated$object)  
        }
      }else {
        print("WARNING: position in component larger than component")
        updated.bp<-comp.id
        updated.chr<-as.character(comp.id)
      }
    }else{
      print(paste("WARNING: locus ",id, " is not on a scaffold",sep=""))
      updated.bp<-bp
      updated.chr<-NA
    }
    out<-data.frame(Locus=id,OrigChr=chr,OrigBP=bp,
                    NewChr=updated.chr,NewBP=updated.bp,
                    stringsAsFactors = FALSE)
  }else{
    #it's not on an LG - let's check the scaffolds
    component<-as.data.frame(old.scf[old.scf$object == chr & 
                                       old.scf$object_beg <= bp & 
                                       old.scf$object_end >= bp,],
                             stringsAsFactors=FALSE)
    if(nrow(component)>0){
      #then we found it
      #check to make sure my bp makes sense
      if(bp < max(old.scf[old.scf$object==chr,"object_end"])){
        comp.bp<-bp
        comp.id<-as.character(chr)
        #look for it in the new assembly
        updated<-new.agp[new.agp$component_id%in%comp.id & 
                  as.numeric(as.character(new.agp$component_beg)) <=comp.bp &   
                  as.numeric(as.character(new.agp$component_end)) >= comp.bp,]
        if(nrow(updated)==0){ #if you didn't find it, check scaffold
          updated<-scf.agp[scf.agp$object%in%comp.id & 
                  as.numeric(as.character(scf.agp$object_beg)) <=comp.bp & 
                  as.numeric(as.character(scf.agp$object_end)) >= comp.bp,]
          updated.bp<-comp.bp
          updated.chr<-as.character(comp.id)
        } else{
          updated.bp<-updated$object_beg+comp.bp
          updated.chr<-as.character(updated$object)  
        }
      } else {
          print("WARNING: position in scaffold larger than scaffold")
          updated.bp<-NA
          updated.chr<-NA
      }
      out<-data.frame(Locus=id,OrigChr=chr,OrigBP=bp,
                      NewChr=updated.chr,NewBP=updated.bp,
                      stringsAsFactors = FALSE)
    }else{
      out<-data.frame(Locus=id,OrigChr=chr,OrigBP=bp,
                      NewChr=NA,NewBP=NA,
                      stringsAsFactors = FALSE)
      print(paste("WARNING: locus ", id, " not found",sep=""))
    }
  }
  
  return(out)
}
convert.stacks<-function(stacks.fst,outname,lgs,ssc.agp,sscf.agp,chr.agp,scf.agp){
  for(i in 1:nrow(stacks.fst)){
     convert<-convert.agp(old.agp=ssc.agp,old.scf=sscf.agp,
                          new.agp=chr.agp[chr.agp$W=="W",],scf.agp = scf.agp,
                          chr=as.character(stacks.fst$Chr[i]),
                          bp=stacks.fst$BP[i],id=as.character(stacks.fst$Locus.ID[i]))
    stacks.fst[i,"Chr"]<-convert["NewChr"]
    stacks.fst[i,"BP"]<-convert["NewBP"]
  }
  # reorder by chrom
  scaffs<-levels(as.factor(stacks.fst$Chr))
  scaffs[1:22]<-lgs
  upd.fst<-do.call(rbind,lapply(scaffs,function(lg){
    this.chr<-stacks.fst[stacks.fst$Chr==lg,]
    this.chr<-this.chr[order(as.numeric(this.chr$BP)),]
    return(this.chr)
  }))
  write.table(upd.fst,outname,col.names = TRUE,row.names = FALSE,quote=FALSE,sep='\t')
  print(by(upd.fst,upd.fst$Chr,function(chr){ return(max(chr$BP)/1000000) })[lgs])
  return(upd.fst)
}
```

```{r gen_agp_lgs}
# old agps
ssc.agp<-read.delim("../../scovelli_genome/SSC_genome.agp",
                    comment.char="#",header=FALSE)
colnames(ssc.agp)<-c("object","object_beg","object_end","part_number","W",
                     "component_id","component_beg","component_end","orientation")
sscf.agp<-read.delim("../../scovelli_genome/SSC_scaffolds.agp",
                     comment.char="#",header=FALSE)
colnames(sscf.agp)<-c("object","object_beg","object_end","part_number","W",
                      "component_id","component_beg","component_end","orientation")
# new scaffold and chrom level agps
scf.agp<-read.delim(gzfile("../../scovelli_genome/ssc_2016_12_20_scafflevel.agp.gz"),
                    comment.char="#",header=FALSE)
chr.agp<-read.delim(gzfile("../../scovelli_genome/ssc_2016_12_20_chromlevel.agp.gz"),
                    comment.char="#",header=FALSE)
colnames(scf.agp)<-c("object","object_beg","object_end","part_number","W",
                     "component_id","component_beg","component_end","orientation")
colnames(chr.agp)<-c("object","object_beg","object_end","part_number","W",
                     "component_id","component_beg","component_end","orientation")
```

```{r convert_vcf,eval=FALSE}
vcf<-parse.vcf("stacks/populations_subset75/batch_2.pruned.vcf")
converted<-data.frame(Locus=integer(),OrigChr=character(),OrigBP=integer(),
                      NewChr=character(),NewBP=integer(),
                      stringsAsFactors = FALSE)
for(i in 1:nrow(vcf)){
  converted[i,]<-convert.agp(locus=vcf[i,],old.agp=ssc.agp,old.scf=sscf.agp,
                             new.agp=chr.agp[chr.agp$W=="W",],scf.agp = scf.agp)
}

```

```{r lgs}
lgs<-c("LG1","LG2","LG3","LG4","LG5","LG6","LG7","LG8","LG9","LG10","LG11",
	"LG12","LG13","LG14","LG15","LG16","LG17","LG18","LG19","LG20","LG21",
	"LG22")
```


```{r replace_vcf,eval=FALSE}
new.vcf<-as.data.frame(vcf,stringsAsFactor=FALSE)
for(i in 1:nrow(vcf)){
  new.vcf$POS[i]<-converted$NewBP[i]
  new.vcf$`#CHROM`[i]<-as.character(converted$NewChr[i])
}
write.table(new.vcf,"converted_subset.vcf",sep='\t',
            quote=FALSE,col.names = TRUE,row.names = FALSE)
```
```{r convertSWSW, eval=FALSE}
swsw.fl<-read.delim("stacks/populations_whitelist/batch_2.fst_FLCC-FLHB.tsv")
swsw.tx<-read.delim("stacks/populations_whitelist/batch_2.fst_TXCB-TXCC.tsv")
swsw.al<-read.delim("stacks/populations_whitelist/batch_2.fst_ALST-FLSG.tsv")

upd.st<-convert.stacks(swsw.tx,"stacks/converted.fst_TXCB-TXCC.txt",
                       lgs,ssc.agp,sscf.agp,chr.agp,scf.agp)
upd.sa<-convert.stacks(swsw.al,"stacks/converted.fst_ALST-FLSG.txt",
                       lgs,ssc.agp,sscf.agp,chr.agp,scf.agp)
upd.sf<-convert.stacks(swsw.fl,"stacks/converted.fst_FLCC-FLHB.txt",
                       lgs,ssc.agp,sscf.agp,chr.agp,scf.agp)
```


## Stacks {-}

```{r read_stacks_fsts}
fwsw.al<-read.delim("stacks/converted.fst_ALFW-ALST.txt")
fwsw.la<-read.delim("stacks/converted.fst_ALST-LAFW.txt")
fwsw.tx<-read.delim("stacks/converted.fst_TXCC-TXFW.txt")
fwsw.fl<-read.delim("stacks/converted.fst_FLCC-FLLG.txt")
```

```{r plot_stacks_fsts,fig.height=8,fig.width=6,fig.cap="Manhattan plot of pairwise AMOVA-corrected Fst values from Stacks for each freshwater - nearest saltwater population pair. The x-axis corresponds to genomic locations, with chromosomes labelled. To the right are loci that mapped to unanchored scaffolds."}
source("../R/205_popgenPlotting.R")
fst_dat<-list(fwsw.al,fwsw.la,fwsw.tx,fwsw.fl)
fsts<-plot_multiple_LGs(list_fsts = fst_dat,fst_name = "Corrected.AMOVA.Fst",
                        bp_name="BP",chr_name="Chr",lgs=lgs,
                        plot_labs=list("ALFW vs ALST","ALST vs LAFW",
                                       "TXFW vs TXCC","FLFW vs FLCC"),
                        pt_cols = list(c(grp.colors[3],grp.colors[2]),
                                       c(grp.colors[2],grp.colors[3]),
                                       c(grp.colors[1],grp.colors[2]),
                                       c(grp.colors[6],grp.colors[5])),
                        ncol=1,addSmooth = FALSE,pch=19,y.lim = c(0,1),
                        pt.cex=1,axis.size = 1)
```

So this generated a plot for each pairwise comparison. We could look for shared outliers and see if we can find anything.

```{r get_stacks_sig}
tx.sig<-fwsw.tx[fwsw.tx$Fisher.s.P<0.01,"Locus.ID"]
la.sig<-fwsw.la[fwsw.la$Fisher.s.P<0.01,"Locus.ID"]
al.sig<-fwsw.al[fwsw.al$Fisher.s.P<0.01,"Locus.ID"]
fl.sig<-fwsw.fl[fwsw.fl$Fisher.s.P<0.01,"Locus.ID"]
length(tx.sig[(tx.sig %in% c(la.sig,al.sig,fl.sig))])
length(la.sig[(la.sig %in% c(tx.sig,al.sig,fl.sig))])
length(al.sig[(al.sig %in% c(la.sig,tx.sig,fl.sig))])
all.shared<-fl.sig[fl.sig %in% la.sig & fl.sig %in% al.sig & fl.sig %in% tx.sig]
```

There are `r length(unique(all.shared))` outliers (as determined by Fisher's P from stacks < 0.01). 

As a point of comparison, we can repeat this with the similar pairwise saltwater-saltwater $F_{ST}$ comparisons.

```{r plot_stacks_fsts_swsw,fig.height=8,fig.width=6,fig.cap="Manhattan plot of pairwise AMOVA-corrected Fst values from Stacks for the saltwater populations nearest to freshwater populations compared to their nearest saltwater neightbor. The x-axis corresponds to genomic locations, with chromosomes labelled. To the right are loci that mapped to unanchored scaffolds."}
swsw.fl<-read.delim("stacks/converted.fst_TXCB-TXCC.txt")
swsw.tx<-read.delim("stacks/converted.fst_ALST-FLSG.txt")
swsw.al<-read.delim("stacks/converted.fst_FLCC-FLHB.txt")
fst_dat<-list(swsw.fl,swsw.tx,swsw.al)
fsts<-plot_multiple_LGs(list_fsts = fst_dat,fst_name = "Corrected.AMOVA.Fst",
                        bp_name="BP",chr_name="Chr",lgs=lgs,
                        plot_labs=list("TXSP vs TXCC","ALST vs FLSG","FLHB vs FLCC"),
                        pt_cols = list(c(grp.colors[1],grp.colors[2]),
                                       c(grp.colors[2],grp.colors[3]),
                                       c(grp.colors[6],grp.colors[5])),
                        ncol=1,addSmooth = FALSE,pch=19,y.lim = c(0,1),
                        pt.cex=1,axis.size = 1)
```

So this generated a plot for each pairwise comparison. We could look for shared outliers and see if we can find anything.

```{r get_stacks_sig_swsw}
tx.sig<-swsw.tx[swsw.tx$Fisher.s.P<0.01,"Locus.ID"]
al.sig<-swsw.al[swsw.al$Fisher.s.P<0.01,"Locus.ID"]
fl.sig<-swsw.fl[swsw.fl$Fisher.s.P<0.01,"Locus.ID"]
all.shared<-fl.sig[fl.sig %in% al.sig & fl.sig %in% tx.sig]
```

There are `r length(unique(all.shared))` outliers (as determined by Fisher's P from stacks < 0.01).

## Permutations {-}

```{r permute.gwsca}
permute.gwsca<-function(vcf,map1,nperms,z=1.96, maf.cutoff = 0.05,cov.thresh=0.2){
  # calculate the actuals
  actual_fsts<-gwsca(vcf,colnames(vcf)[1:9],
                     map1[map1[,2] %in% unique(map1[,2])[1],1],
                     map1[map1[,2] %in% unique(map1[,2])[2],1],
                     maf.cutoff=maf.cutoff,prop.ind.thresh=cov.thresh)
  # do the permutations
  perm_fsts<-lapply(1:nperms,function(i,vcf,map1){
    perm_map<-map1
    perm_map[,2]<-perm_map[,2][permute::shuffle(perm_map[,2])]
    perm_dat<-gwsca(vcf,colnames(vcf)[1:9],
                     perm_map[perm_map[,2] %in% unique(perm_map[,2])[1],1],
                     perm_map[perm_map[,2] %in% unique(perm_map[,2])[2],1],
                     maf.cutoff,cov.thresh)
   
    return(perm_dat)
  },vcf=vcf,map1=map1)
  
  # calculate stats
  fsts<-t(do.call(rbind,lapply(perm_fsts,'[[',"Fst"))) #extract permuted fsts
  perm_fst_mu<-rowMeans(fsts)
  perm_fst_in<-NULL
  for(i in 1:nrow(actual_fsts)){
    pmax<-max(fsts[i,] )
    pmin<-min(fsts[i,] )
    if(actual_fsts[i,"Fst"] > pmax | actual_fsts[i,"Fst"] < pmin ){
      perm_fst_in[i]<-1
    }else{
      perm_fst_in[i]<-0
    }
  }
  
  fst_dat<-data.frame(cbind(actual_fsts,
                            n_perms=nperms,
                            mean_perm=perm_fst_mu,
                            act_in_perm=perm_fst_in))
  return(fst_dat)
}
```
```{r permuteVCF,eval=FALSE}
vcf<-parse.vcf("converted_subset.vcf")
popmap<-data.frame(inds=colnames(vcf)[10:ncol(vcf)],
                   pops=gsub("sample_(\\w{4}).*","\\1",colnames(vcf)[10:ncol(vcf)]),
                   stringsAsFactors = FALSE)
pwise_maps<-list(popmap[popmap$pops %in% c("TXFW","TXCC"),],
                 popmap[popmap$pops %in% c("FLLG","FLCC"),],
                 popmap[popmap$pops %in% c("ALFW","ALST"),],
                 popmap[popmap$pops %in% c("LAFW","ALST"),])

permuted_fsts<-lapply(pwise_maps,permute.gwsca,vcf=vcf,nperms=1000, maf.cutoff=0)
saveRDS(permuted_fsts,"permuted_fsts.RDS")
```

Now let's visualize it.

```{r plot_fst_hists}
plot_fst_hists<-function(perms,plot_lab=NULL,cols=NULL,permlab="mean_perm",
                         reallab="Fst",baseplot=TRUE,inset=NULL){
  require(scales)
  if(is.null(plot_lab)){
    plot_lab<-""
  }
  if(is.null(cols)){
    cols<-c("grey","black")
  } else if(length(cols)==1){
    cols<-c("dark grey",cols)
  }
  #inset<-par()$fig
  #browser()
  if(isTRUE(baseplot)){
    hist(perms[,permlab],col=alpha(cols[1],0.5),border = alpha(cols[1],0.5),
         xlim=c(0,1),breaks = seq(0,1,0.01),main = plot_lab,
         xlab=expression(italic(F)[ST]),
         ylab="Number of SNPs")
    hist(perms[,reallab],col=alpha(cols[2],0.5),border = alpha(cols[2],0.5),
         xlim=c(0,1),breaks = seq(0,1,0.01),main = "",
         xlab=expression(italic(F)[ST]),
         ylab="Number of SNPs",add=TRUE)
  }
  if(!is.null(inset)){ # add an inset
    # adjust the fig coordinates
    ifig<-c(inset[1]+0.25*(inset[2]-inset[1]),inset[2], 
            inset[3]+0.25*(inset[4]-inset[3]), inset[4])
    par(fig = ifig,new=TRUE) # start x, end x, start y, end y (percent plotting space)
    hist(perms[,permlab][perms[,reallab]>0],col=alpha(cols[1],0.5),
         border = alpha(cols[1],0.5),
         xlim=c(0,1),breaks = seq(0,1,0.01),main = "",xlab="",
         ylab="")
    box() #give it a box
    hist(perms[,reallab,][perms[,reallab]>0],col=alpha(cols[2],0.5),
         border = alpha(cols[2],0.5),
         xlim=c(0,1),breaks = seq(0,1,0.01),main = "",xlab="",
         ylab="",add=TRUE)
  }
  invisible(par()$fig)
}

```
```{r plot_permutations, eval=FALSE}
plot_labs<-list("TXFW vs TXCC","FLFW vs FLCC","ALFW vs ALST","ALST vs LAFW")
pt_cols<-list(TXTX=grp.colors[1],FLFL=grp.colors[6],
              ALAL=grp.colors[3],ALLA=grp.colors[2])
png("../figs/permuted_fsts.png",pointsize = 16,height=7,width=8,units="in",res=300)
par(mfrow=c(2,2),new=FALSE,mar=c(4,4,3,1))
#plot the base
pars<-mapply(plot_fst_hists,perms=permuted_fsts,plot_lab=plot_labs,
             cols=pt_cols,SIMPLIFY = FALSE)
# add the insets
ipars<-mapply(plot_fst_hists,perms=permuted_fsts,plot_lab=plot_labs,cols=pt_cols,
              inset=pars,
              MoreArgs = list(baseplot=FALSE))
dev.off()
```

![Histograms of pairwise Fst values generated by the permutations. The inset in each shows the same data but with a smaller range on the y-axis to provide an imporved visualisation.](../figs/permuted_fsts.png)

Now let's start to aggregate everything.

```{r create_fw_SNPinfo, eval=FALSE}
permuted_fsts<-readRDS("permuted_fsts.RDS")
vcf<-parse.vcf("converted_subset.vcf")
fw_SNPinfo<-data.frame(ID=vcf$ID,Chrom=vcf$`#CHROM`,Pos=vcf$POS,BP=vcf$POS-1,
                       REF=vcf$REF,ALT=vcf$ALT,
                       perm_TX=permuted_fsts[[1]]$act_in_perm,
                       perm_FL=permuted_fsts[[2]]$act_in_perm,
                       perm_AL=permuted_fsts[[3]]$act_in_perm,
                       perm_LA=permuted_fsts[[4]]$act_in_perm,
                       stringsAsFactors = FALSE)
```



```{r add2SnpInfo, eval=FALSE}
# add Fsts
fw_SNPinfo<-merge(fw_SNPinfo,fwsw.al,by.x=c("Chrom","BP"),by.y=c("Chr","BP"),
                  all.x=TRUE,all.y = FALSE)[,c(colnames(fw_SNPinfo),
                                               "Corrected.AMOVA.Fst")] 
colnames(fw_SNPinfo)[ncol(fw_SNPinfo)]<-"stacks_AL"
fw_SNPinfo<-merge(fw_SNPinfo,fwsw.la,by.x=c("Chrom","BP"),by.y=c("Chr","BP"),
                  all.x=TRUE,all.y = FALSE)[,c(colnames(fw_SNPinfo),
                                               "Corrected.AMOVA.Fst")] 
colnames(fw_SNPinfo)[ncol(fw_SNPinfo)]<-"stacks_LA"
fw_SNPinfo<-merge(fw_SNPinfo,fwsw.tx,by.x=c("Chrom","BP"),by.y=c("Chr","BP"),
                  all.x=TRUE,all.y = FALSE)[,c(colnames(fw_SNPinfo),
                                               "Corrected.AMOVA.Fst")] 
colnames(fw_SNPinfo)[ncol(fw_SNPinfo)]<-"stacks_TX"
fw_SNPinfo<-merge(fw_SNPinfo,fwsw.fl,by.x=c("Chrom","BP"),by.y=c("Chr","BP"),
                  all.x=TRUE,all.y = FALSE)[,c(colnames(fw_SNPinfo),
                                               "Corrected.AMOVA.Fst")] 
colnames(fw_SNPinfo)[ncol(fw_SNPinfo)]<-"stacks_FL"
# add p-values
fw_SNPinfo<-merge(fw_SNPinfo,fwsw.al,by.x=c("Chrom","BP"),by.y=c("Chr","BP"),
                  all.x=TRUE,all.y = FALSE)[,c(colnames(fw_SNPinfo),"Fisher.s.P")] 
colnames(fw_SNPinfo)[ncol(fw_SNPinfo)]<-"stacks_AL_P"
fw_SNPinfo<-merge(fw_SNPinfo,fwsw.la,by.x=c("Chrom","BP"),by.y=c("Chr","BP"),
                  all.x=TRUE,all.y = FALSE)[,c(colnames(fw_SNPinfo),"Fisher.s.P")] 
colnames(fw_SNPinfo)[ncol(fw_SNPinfo)]<-"stacks_LA_P"
fw_SNPinfo<-merge(fw_SNPinfo,fwsw.tx,by.x=c("Chrom","BP"),by.y=c("Chr","BP"),
                  all.x=TRUE,all.y = FALSE)[,c(colnames(fw_SNPinfo),"Fisher.s.P")] 
colnames(fw_SNPinfo)[ncol(fw_SNPinfo)]<-"stacks_TX_P"
fw_SNPinfo<-merge(fw_SNPinfo,fwsw.fl,by.x=c("Chrom","BP"),by.y=c("Chr","BP"),
                  all.x=TRUE,all.y = FALSE)[,c(colnames(fw_SNPinfo),"Fisher.s.P")] 
colnames(fw_SNPinfo)[ncol(fw_SNPinfo)]<-"stacks_FL_P"
saveRDS(fw_SNPinfo,"fw_SNPinfo.RDS")
```



## PCAdapt {-}

For this analysis, to maintain consistency with the other outlier analyses, I'm using the subestted dataset. So I need to run PCAdapt [@luu_pcadapt:_2017] another time.

```{r convertVCF, eval=TRUE}
vcf<-parse.vcf("converted_subset.vcf")
write.table("##fileformat=VCFv","pcadapt_fw/fwsw.pruned.vcf",quote=FALSE,
            col.names = FALSE,row.names = FALSE)
suppressWarnings(write.table(vcf,"pcadapt_fw/fwsw.pruned.vcf",
                             quote=FALSE,append = TRUE,
                             row.names = FALSE,col.names = TRUE,sep='\t'))
```



```{r pcadaptOutliers, fig.cap="Screeplot for the subsetted dataset with 20 PC axes retained in the analysis."}
library(pcadapt)
#need to remove the first line with a # 
filename<-read.pcadapt("pcadapt_fw/fwsw.pruned.vcf",type="vcf") 
x<-pcadapt(filename, K=20)
plot(x,option="screeplot")
```

$K=4$ seems like the best choice here to keep values to the left of the straight line (or could be $K=6$). 

```{r organizePopInfo}
# Organize pop info
pops<-gsub("sample_(\\w{4}).*","\\1",colnames(vcf)[10:ncol(vcf)])	
grp<-pops
grp[grp=="TXFW" | grp=="LAFW" | grp=="ALFW" | grp=="FLLG"]<-"freshwater"
grp[grp!="freshwater"]<-"saltwater"
```


```{r PcadaptK4-1, fig.cap="Manhattan plot for the PCAdapt outlier analysis with the subsetted dataset and 4 PC axes retained in the analysis."}
res<-pcadapt(filename,K=4)
plot(res, option="manhattan")
```
```{r PcadaptK4-2, fig.cap="Q-Q plot for the PCAdapt outlier analysis with the subsetted dataset and 4 PC axes retained in the analysis."}
plot(res, option="qqplot")
```
```{r PcadaptK4-3, fig.cap="Distribution of the  for the PCAdapt outlier analysis with the subsetted dataset and 4 PC axes retained in the analysis."}
plot(res, option="stat.distribution")
```
```{r PcadaptK4-4, fig.cap="Plot of the scores from the PCAdapt outlier analysis with the subsetted dataset and 4 PC axes retained in the analysis."}
plot(res, option="scores",pop=pops)
```

The PCAdapt vignette recommends displaying the loadings and evaluate if loadings are clustered in single or several genomic regions

```{r PcadaptLoadings, fig.cap="Plots of the loadings for the four PC axes according to genomic position (on the x-axis)."}
par(mfrow = c(2, 2))
for (i in 1:4)
  plot(res$loadings[, i], pch = 19, cex = .3, ylab = paste0("Loadings PC", i))
```

This suggests that loadings are not clustered (assuming these are grouped by space), so we don't need to worry about LD thinning. Now let's look chromosome by chromosome:

```{r PcadaptLoadingsChr,fig.height=8, fig.cap="Inspecting the loadings for the four PC axes according to genomic position (on the x-axis) for each chromosome individually."}
par(mfrow=c(6,4),mar=c(3,3,2,1.5))
l<-lapply(lgs, function(lg,vcf){
  plot(res$loadings[which(vcf$`#CHROM` %in% lg), 1], pch = 19, cex = .3, 
       xlab = paste0("Position on ", lg), ylab = "Loadings PC 1")
  mtext(lg,3,outer=FALSE)
},vcf=vcf)
```

None of the LGs seem to have huge clusters of outliers so we can move on, lumping them all together.

We need to choose a cutoff for outlier detection. I'll use the qvalue approach, which identifies outliers with a false discovery rate of $\alpha$, which I'm setting here to 0.05.

```{r PcadaptQvalue}
library(qvalue)
qval <- qvalue(res$pvalues)$qvalues
alpha <- 0.05
outliers <- which(qval < alpha)
snp_pc<-get.pc(res,outliers) # Get the PCs associated with outliers
```

We identified `r length(outliers)` outliers with this analysis, which are associated with `r length(unique(snp_pc$PC))` of the 4 clusters. If we look at the distribution of these, though, we see that most are associated with PC 1

```{r showPcadaptOutliers}
table(snp_pc$PC)
```

Now we can add the qvalues to the fw_SNPinfo dataframe

```{r Pcadapt2Snpinfo, eval=FALSE}
fw_SNPinfo<-readRDS("fw_SNPinfo.RDS")
fw_SNPinfo$pcadaptQ<-qval
fw_SNPinfo$pcadaptPC<-get.pc(res,1:length(qval))$PC
saveRDS(fw_SNPinfo,"fw_SNPinfo.RDS")
```

I should note that for some of these PCAdapt gives "NA" -- not sure what causes this behaviour but there it is. It's true for the residuals and everything else. It looks to be due to low allele frequencies -- though stacks should have been run with a minimum allele frequency cutoff, so this is perplexing. 

## Bayenv {-}

Investigate the environmental data

```{r compareEnvVar}
env.data<-read.csv("bayenv/env_data_raw.csv",row.names = 1)
env.data<-rbind(env.data,pop=c(rep("SW",12),rep("FW",4)))
env.data<-as.data.frame(t(env.data))
wilcox.test(as.numeric(env.data$temp)~env.data$pop) #ties, but p=0.539
wilcox.test(as.numeric(env.data$seagrass)~env.data$pop) #ties, but p=0.897
```


This analysis is of just the freshwater and saltwater populations. First I ran bayenv using the script `run_bayenv2_matrix_general.sh`.

```{bash, eval=FALSE}
# set up correct file formats
../../scripts/run_bayenv2_matrix_general.sh FILEMANIP \
bayenv/sub75.pruned.clust stacks/populations_subset75/batch_2.pruned.ped \
stacks/populations_subset75/batch_2.pruned.map bayenv ~/Programs/bayenv 7
# estimate matrices
../../scripts/run_bayenv2_matrix_general.sh MATRIX bayenv ~/Programs/bayenv/ 7
```

At this point I looked at the matrices

![Heatmap plots of each of the ten replicate Bayenv matrices. Colors represent xx](../fwsw_results/bayenv/fwsw75_pruned.png)

They all looked fine so I chose the randomly selected a matrix to use for the remainder of the analyses.

```{bash, eval=FALSE}
# Create the SNPFILES
../../scripts/run_bayenv2_matrix_general.sh SNPFILES SNPSFILE SNPFILES
# Run bayenv
nohup ../../scripts/run_bayenv2_matrix_general.sh BAYENV \
~/Programs/bayenv/ matrix env_data_sub75.txt 7 3 SNPFILES > bayenv.log &
```

### Analyze Bayenv output

Once Bayenv was finished running, I first aggregated all of the output. 

```{r getBayenvResults}
get_bayenv_results<-function(dir,env_vars){
  # process the variable names
  var_names<-unlist(lapply(env_vars,function(var){
    nms<-c(paste0(var,"_BF"),paste0(var,"_rho"),paste0(var,"_rs"))
    return(nms)
  }))
  # list all the files
  bf.files<-list.files(pattern="bf",path = dir,full.names = TRUE)
  xtx.files<-list.files(pattern="xtx",path=dir,full.names = TRUE)
  # get the bf files
  bf.dat<-do.call(rbind,lapply(bf.files,function(filename){
    bf<-read.table(filename,header = FALSE)
  }))
  colnames(bf.dat)<-c("locus", var_names)
  
  # xtx files
  xtx.files<-list.files(pattern="xtx",path=dir,full.names = TRUE)
  xtx.dat<-do.call(rbind,lapply(xtx.files,function(filename){
    xtx<-read.table(filename,header = FALSE,stringsAsFactors = FALSE)
  }))
  colnames(xtx.dat)<-c("locus","XtX")
  
  # combine the two
  bayenv.dat<-merge(xtx.dat,bf.dat,by="locus")
  return(bayenv.dat)
}
```

The SNP names are uninformative, just the row number the SNP was in. We can make these better using the freq info

```{r snpnames4bayenv, eval=FALSE}
bayenv_dat<-get_bayenv_results(dir="bayenv/SNPFILES",
                               env_vars=c("temp","salinity","seagrass"))

freq<-read.table("bayenv/bayenv.frq.strat",header=T, stringsAsFactors=F)
#want to get $MAC for every snp at every pop 
#and NCHROBS-MAC for every stnp at every pop
freq<-cbind(freq,freq$NCHROBS-freq$MAC)
colnames(freq)[ncol(freq)]<-"NAC"
snp.names<-split(freq$SNP,freq$CLST)[[1]]
snp.names<-gsub("(\\d+)_\\d+","\\1",snp.names)

snp_dat<-data.frame(ID=snp.names,loc=seq(1,length(snp.names)*2,2))
bayenv_dat$locus<-as.numeric(gsub("SNPFILES\\/(\\d+)","\\1",bayenv_dat$locus))
bayenv_dat<-bayenv_dat[order(bayenv_dat$locus),]
bayenv_dat<-merge(snp_dat,bayenv_dat,by.x="loc",by.y="locus")
colnames(bayenv_dat)[1:2]<-c("index","SNPID")

pmap<-read.delim("stacks/populations_subset75/batch_2.pruned.map",header = FALSE) 
# the position location is wrong in this ^ file
pmap$locus<-gsub("(\\d+)_\\d+","\\1",pmap[,2])

bayenv_dat<-merge(pmap[,c(1,4,5)],bayenv_dat,by.x="locus",by.y="SNPID")
colnames(bayenv_dat)[2:3]<-c("Chrom","SNPID")
write.table(bayenv_dat,"bayenv/bayenv_output.txt",sep="\t",
            col.names = TRUE,row.names = FALSE,quote = FALSE)
```

Merge it with other snp info
```{r bayenv2snpinfo, eval=FALSE}
bayenv_dat<-read.delim("bayenv/bayenv_output.txt",header = TRUE)
bayenv_dat$logSalBF<-log(bayenv_dat$salinity_BF)
bayenv_dat$logTemBF<-log(bayenv_dat$temp_BF)
bayenv_dat$logSegBF<-log(bayenv_dat$seagrass_BF)
fw_SNPinfo<-readRDS("fw_SNPinfo.RDS")
fw_SNPinfo<-merge(fw_SNPinfo,
                  bayenv_dat[,c("locus","XtX","logSalBF","logTemBF","logSegBF")],
                  by.x="ID",by.y="locus",all.x=TRUE)
saveRDS(fw_SNPinfo,"fw_SNPinfo.RDS")
```

Now we can investigate the outliers etc.

```{r bayenv}
#taken directly from fwsw_analysis.R
bayenv.dat<-read.delim("bayenv/bayenv_output.txt",header=T)
# calculate quantiles for bayes factors
#focus on Bayes Factors, because of Lotterhos & Whitlock (2015)
bf.co<-apply(bayenv.dat[,grep("BF",colnames(bayenv.dat))],2,quantile,0.99) 
temp.bf.sig<-bayenv.dat[bayenv.dat$temp_BF>bf.co["temp_BF"],]
sal.bf.sig<-bayenv.dat[bayenv.dat$salinity_BF>bf.co["salinity_BF"],]
grass.bf.sig<-bayenv.dat[bayenv.dat$seagrass_BF>bf.co["seagrass_BF"],]
#get the log transformed Bayes Factors
bayenv.dat$logSal<-log(bayenv.dat$salinity_BF)
bayenv.dat$logTemp<-log(bayenv.dat$temp_BF)
bayenv.dat$logSeagrass<-log(bayenv.dat$seagrass_BF)

# xtx
xtx.sig<-bayenv.dat[bayenv.dat$XtX > quantile(bayenv.dat$XtX,0.99),]
```

There are `r nrow(temp.bf.sig[temp.bf.sig$locus %in% sal.bf.sig$locus & temp.bf.sig$locus %in% grass.bf.sig,])` overlapping outliers between temperature-, salinity-, and seagrass-associated loci.

But if we only care about salinity ones, there are `r nrow(sal.bf.sig)` outliers. Are any of those XtX outliers too? `r nrow(xtx.sig[xtx.sig$locus %in% sal.bf.sig$locus,])` overlap -- not bad!

Now, to plot.
```{r plotOutliersSetup}
library(scales)
fw_SNPinfo<-readRDS("fw_SNPinfo.RDS")
cols<-c(perm=alpha('#e41a1c',0.75),sal=alpha('#377eb8',0.75),
        pc=alpha('#4daf4a',0.75),xtx=alpha('#984ea3',0.75),
        stacks=alpha('#ff7f00',0.75))
```
```{r plotOutliers,fig.keep='last',fig.cap="Manhattan plots of the Bayenv XTX statistic and the log of the Bayes factors associated with salinity. Shown are only loci that mapped to regions on chromosomes. Grey points represent loci that are not outlier in any analyses. Colored points represent outliers in both the Bayenv analyses and the other outlier analyses."}
par(mfrow=c(2,1),oma=c(1,2,1,1),mar=c(2,2,1,1),xpd=TRUE)
# plot XtX
plot_dat<-fst.plot(fw_SNPinfo,scaffs.to.plot = lgs,fst.name = "XtX",
                   chrom.name = "Chrom",bp.name = "Pos",axis.size = 0,pch=19)
points(plot_dat$plot.pos[plot_dat$XtX>=quantile(plot_dat$XtX,0.99)],
       plot_dat$XtX[plot_dat$XtX>=quantile(plot_dat$XtX,0.99)],
       col=cols["xtx"],cex=0.75,pch=19)
points(plot_dat$plot.pos[plot_dat$logSalBF>=quantile(plot_dat$logSalBF,0.99)],
       plot_dat$XtX[plot_dat$logSalBF>=quantile(plot_dat$logSalBF,0.99)],
       col=cols["sal"],cex=0.85,pch=17)
points(plot_dat$plot.pos[
  rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       plot_dat$XtX[
         rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       col=cols["perm"],cex=1,pch=4,lwd=2)
points(plot_dat$plot.pos[plot_dat$stacks_AL < 0.05 & plot_dat$stacks_LA < 0.05 &
                           plot_dat$stacks_TX < 0.05 & plot_dat$stacks_FL < 0.05],
       plot_dat$XtX[plot_dat$stacks_AL < 0.05 & plot_dat$stacks_LA < 0.05 &
                           plot_dat$stacks_TX < 0.05 & plot_dat$stacks_FL < 0.05],
       col=cols["stacks"],cex=1,pch=5,lwd=2)
points(plot_dat$plot.pos[plot_dat$pcadaptQ<0.01],
       plot_dat$XtX[plot_dat$pcadaptQ<0.01],
       col=cols["pc"],cex=1,pch=0,lwd=2)
axis(2,las=1)
mtext(expression(italic("X")^"T"~italic("X")),2,line=2)

# add the LG labels
midpts<-tapply(plot_dat$plot.pos,plot_dat$Chrom,median)
text(x=midpts[lgs],y=0)

# plot Bayes Factors
plot_dat<-fst.plot(plot_dat,scaffs.to.plot = lgs,fst.name = "logSalBF",
                   chrom.name = "Chrom",bp.name = "Pos",axis.size = 0,pch=19)
points(plot_dat$plot.pos[plot_dat$logSalBF>=quantile(plot_dat$logSalBF,0.99)],
       plot_dat$logSalBF[plot_dat$logSalBF>=quantile(plot_dat$logSalBF,0.99)],
       col=cols["sal"],cex=0.85,pch=17)
points(plot_dat$plot.pos[plot_dat$XtX>=quantile(plot_dat$XtX,0.99)],
       plot_dat$logSalBF[plot_dat$XtX>=quantile(plot_dat$XtX,0.99)],
       col=cols["xtx"],cex=0.75,pch=19)
points(plot_dat$plot.pos[
  rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       plot_dat$logSalBF[
         rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       col=cols["perm"],cex=1,pch=4,lwd=2)
points(plot_dat$plot.pos[plot_dat$stacks_AL < 0.05 & plot_dat$stacks_LA < 0.05 &
                           plot_dat$stacks_TX < 0.05 & plot_dat$stacks_FL < 0.05],
       plot_dat$logSalBF[plot_dat$stacks_AL < 0.05 & plot_dat$stacks_LA < 0.05 &
                           plot_dat$stacks_TX < 0.05 & plot_dat$stacks_FL < 0.05],
       col=cols["stacks"],cex=1,pch=5,lwd=2)
points(plot_dat$plot.pos[plot_dat$pcadaptQ<0.01],
       plot_dat$logSalBF[plot_dat$pcadaptQ<0.01],
       col=cols["pc"],cex=1,pch=0,lwd=2)
axis(2,las=1)
mtext("log(Salinity Bayes Factors)",2,line=2)

# add the LG labels
midpts<-tapply(plot_dat$plot.pos,plot_dat$Chrom,median)
text(x=midpts[lgs],y=-5)

# add outside legend

opar <- par(fig=c(0, 1, 0, 1), oma=c(0, 0, 0, 0),
            mar=c(0, 0, 0, 0), new=TRUE)
on.exit(par(opar))
plot(0, 0, type='n', bty='n', xaxt='n', yaxt='n')
legend("top",c(expression("Permutation"~italic("F")["ST"]),
         expression("Stacks"~italic("F")["ST"]),
         "PCAdapt",expression(italic("X")^T~italic("X")),"Salinity BF"),
       xjust = 0.5,x.intersp = 0.5,
       col = cols[c("perm","stacks","pc","xtx","sal")],
       pt.bg=cols[c("perm","stacks","pc","xtx","sal")],
       pch=c(4,5,0,19,17),bty='n',ncol=3)
```


## Summary plot of outliers

First we'll get set up with the libraries, code, and data.

```{r getOutliers, eval=FALSE}
library(UpSetR);library(scales);library(ggplot2)
library(grid);library(gwscaR);library(gridGraphics)
source("../R/upset_hacked.R")
source("../R/205_popgenPlotting.R")
fw_SNPinfo<-readRDS("fw_SNPinfo.RDS")
outliers<-list(xtx=fw_SNPinfo$ID[fw_SNPinfo$XtX >= quantile(fw_SNPinfo$XtX,0.99,na.rm=TRUE)],
               salBF=fw_SNPinfo$ID[fw_SNPinfo$logSalBF>=
                                     quantile(fw_SNPinfo$logSalBF,0.99,na.rm=TRUE)],
               permutations=fw_SNPinfo$ID[
                 rowSums(fw_SNPinfo[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
               pcadapt=fw_SNPinfo$ID[which(fw_SNPinfo$pcadaptQ<0.01)],
               Alabama=fw_SNPinfo$ID[which(fw_SNPinfo$stacks_AL_P < 0.05)], 
               Louisiana=fw_SNPinfo$ID[which(fw_SNPinfo$stacks_LA_P < 0.05)],
               Texas=fw_SNPinfo$ID[which(fw_SNPinfo$stacks_TX_P < 0.05)],
               Florida=fw_SNPinfo$ID[which(fw_SNPinfo$stacks_FL_P < 0.05)],
               sharedStacks=fw_SNPinfo$ID[which(fw_SNPinfo$stacks_AL_P < 0.05 & 
                                                  fw_SNPinfo$stacks_LA_P < 0.05 &
                 fw_SNPinfo$stacks_TX_P < 0.05 & fw_SNPinfo$stacks_FL_P < 0.05)])
```

Then we'll plot the Stacks Fst outliers.

```{r plotStacksOutliers, eval=FALSE}
pop.list<-c("TXSP","TXCC","TXFW","TXCB","LAFW","ALST","ALFW","FLSG","FLKB",
	"FLFD","FLSI","FLAB","FLPB","FLHB","FLCC","FLLG")
pop.labs<-c("TXSP","TXCC","TXFW","TXCB","LAFW","ALST","ALFW","FLSG","FLKB",
            "FLFD","FLSI","FLAB","FLPB","FLHB","FLCC","FLFW")
lgs<-c("LG1","LG2","LG3","LG4","LG5","LG6","LG7","LG8","LG9","LG10","LG11",
	"LG12","LG13","LG14","LG15","LG16","LG17","LG18","LG19","LG20","LG21",
	"LG22")
lgn<-seq(1,22)
cols<-c(perm=alpha('#e41a1c',0.75),sal=alpha('#377eb8',0.75),pc=alpha('#a65628',0.75),
        stacks=alpha('#f781bf',0.75),xtx=alpha('#ff7f00',0.75))
grp7colors<-c('#762a83','#9970ab','#c2a5cf','#d9f0d3','#a6dba0','#5aae61','#1b7837')
png("../figs/FstOutliers.png",height=8,width=8.5,units="in",res=300,pointsize=20)
par(mfrow=c(4,1),oma=c(1,1,0.5,1),mar=c(2,2,1,1),xpd=TRUE)
# plot TX
plot_dat<-fst.plot(fw_SNPinfo,scaffs.to.plot = lgs,fst.name = "stacks_TX",
                   chrom.name = "Chrom",bp.name = "Pos",axis.size = 0,
                   pch=19,pt.cols = c(grp7colors[1],grp7colors[2]),pt.cex = 1)
points(plot_dat$plot.pos[plot_dat$logSalBF>=quantile(plot_dat$logSalBF,0.99)],
       plot_dat$stacks_TX[plot_dat$logSalBF>=quantile(plot_dat$logSalBF,0.99)],
       col=cols["sal"],cex=1,pch=2)
points(plot_dat$plot.pos[plot_dat$XtX>=quantile(plot_dat$XtX,0.99)],
       plot_dat$stacks_TX[plot_dat$XtX>=quantile(plot_dat$XtX,0.99)],
       col=cols["xtx"],cex=1,pch=3,lwd=2)
points(plot_dat$plot.pos[
  rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       plot_dat$stacks_TX[
         rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       col=cols["perm"],cex=1,pch=4,lwd=2)
points(plot_dat$plot.pos[plot_dat$pcadaptQ<0.01],
       plot_dat$stacks_TX[plot_dat$pcadaptQ<0.01],
       col=cols["pc"],cex=1,pch=0,lwd=2)
points(plot_dat$plot.pos[which(plot_dat$stacks_AL_P < 0.05 & 
                                 plot_dat$stacks_LA_P < 0.05 &
                           plot_dat$stacks_TX_P < 0.05 & 
                             plot_dat$stacks_FL_P < 0.05)],
       plot_dat$stacks_TX[which(plot_dat$stacks_AL_P < 0.05 & 
                                  plot_dat$stacks_LA_P < 0.05 &
                           plot_dat$stacks_TX_P < 0.05 & 
                             plot_dat$stacks_FL_P < 0.05)],
       col=cols["stacks"],cex=1,pch=5,lwd=2)
axis(2,las=1,pos=-1500000)
mtext("TXFW vs. TXCC",2,line=1,cex=0.65)
# add the LG labels
midpts<-tapply(plot_dat$plot.pos,plot_dat$Chrom,median)
text(x=midpts[lgs],y=-0.15)

# plot AL
plot_dat<-fst.plot(fw_SNPinfo,scaffs.to.plot = lgs,fst.name = "stacks_AL",
                   chrom.name = "Chrom",bp.name = "Pos",axis.size = 0,
                   pch=19,pt.cols = c(grp7colors[3],"lightgrey"),pt.cex = 1)
points(plot_dat$plot.pos[plot_dat$XtX>=quantile(plot_dat$XtX,0.99)],
       plot_dat$stacks_AL[plot_dat$XtX>=quantile(plot_dat$XtX,0.99)],
       col=cols["xtx"],cex=1,pch=3,lwd=2)
points(plot_dat$plot.pos[plot_dat$logSalBF>=quantile(plot_dat$logSalBF,0.99)],
       plot_dat$stacks_AL[plot_dat$logSalBF>=quantile(plot_dat$logSalBF,0.99)],
       col=cols["sal"],cex=1,pch=2)
points(plot_dat$plot.pos[
  rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       plot_dat$stacks_AL[
         rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       col=cols["perm"],cex=1,pch=4,lwd=2)
points(plot_dat$plot.pos[plot_dat$pcadaptQ<0.01],
       plot_dat$stacks_AL[plot_dat$pcadaptQ<0.01],
       col=cols["pc"],cex=1,pch=0,lwd=2)
points(plot_dat$plot.pos[which(plot_dat$stacks_AL_P < 0.05 & 
                                 plot_dat$stacks_LA_P < 0.05 &
                           plot_dat$stacks_TX_P < 0.05 & 
                             plot_dat$stacks_FL_P < 0.05)],
       plot_dat$stacks_AL[which(plot_dat$stacks_AL_P < 0.05 & 
                                  plot_dat$stacks_LA_P < 0.05 &
                           plot_dat$stacks_TX_P < 0.05 & 
                             plot_dat$stacks_FL_P < 0.05)],
       col=cols["stacks"],cex=1,pch=5,lwd=2)
axis(2,las=1,pos=-1500000)
mtext("ALFW vs. ALST",2,line=1,cex=0.65)
# add the LG labels
midpts<-tapply(plot_dat$plot.pos,plot_dat$Chrom,median)
text(x=midpts[lgs],y=-0.15)

# plot LA
plot_dat<-fst.plot(fw_SNPinfo,scaffs.to.plot = lgs,fst.name = "stacks_LA",
                   chrom.name = "Chrom",bp.name = "Pos",axis.size = 0,pch=19,
                   pt.cols = c("lightgrey",grp7colors[3]),pt.cex = 1)
points(plot_dat$plot.pos[plot_dat$logSalBF>=quantile(plot_dat$logSalBF,0.99)],
       plot_dat$stacks_LA[plot_dat$logSalBF>=quantile(plot_dat$logSalBF,0.99)],
       col=cols["sal"],cex=1,pch=2)
points(plot_dat$plot.pos[plot_dat$XtX>=quantile(plot_dat$XtX,0.99)],
       plot_dat$stacks_LA[plot_dat$XtX>=quantile(plot_dat$XtX,0.99)],
       col=cols["xtx"],cex=1,pch=3,lwd=2)
points(plot_dat$plot.pos[
  rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       plot_dat$stacks_LA[
         rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       col=cols["perm"],cex=1,pch=4,lwd=2)
points(plot_dat$plot.pos[plot_dat$pcadaptQ<0.01],
       plot_dat$stacks_LA[plot_dat$pcadaptQ<0.01],
       col=cols["pc"],cex=1,pch=0,lwd=2)
points(plot_dat$plot.pos[which(plot_dat$stacks_AL_P < 0.05 & 
                                 plot_dat$stacks_LA_P < 0.05 &
                           plot_dat$stacks_TX_P < 0.05 & 
                             plot_dat$stacks_FL_P < 0.05)],
       plot_dat$stacks_LA[which(plot_dat$stacks_AL_P < 0.05 & 
                                  plot_dat$stacks_LA_P < 0.05 &
                           plot_dat$stacks_TX_P < 0.05 & 
                             plot_dat$stacks_FL_P < 0.05)],
       col=cols["stacks"],cex=1,pch=5,lwd=2)
axis(2,las=1,pos=-1500000)
mtext("LAFW vs. ALST",2,line=1,cex=0.65)
# add the LG labels
midpts<-tapply(plot_dat$plot.pos,plot_dat$Chrom,median)
text(x=midpts[lgs],y=-0.15)


# FL
plot_dat<-fst.plot(fw_SNPinfo,scaffs.to.plot = lgs,fst.name = "stacks_FL",
                   chrom.name = "Chrom",bp.name = "Pos",axis.size = 0,pch=19,
                   pt.cols = c(grp7colors[6],grp7colors[7]),pt.cex = 1)
points(plot_dat$plot.pos[plot_dat$logSalBF>=quantile(plot_dat$logSalBF,0.99)],
       plot_dat$stacks_FL[plot_dat$logSalBF>=quantile(plot_dat$logSalBF,0.99)],
       col=cols["sal"],cex=1,pch=2)
points(plot_dat$plot.pos[plot_dat$XtX>=quantile(plot_dat$XtX,0.99)],
       plot_dat$stacks_FL[plot_dat$XtX>=quantile(plot_dat$XtX,0.99)],
       col=cols["xtx"],cex=1,pch=3,lwd=2)
points(plot_dat$plot.pos[
  rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       plot_dat$stacks_FL[
         rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       col=cols["perm"],cex=1,pch=4,lwd=2)
points(plot_dat$plot.pos[plot_dat$pcadaptQ<0.01],
       plot_dat$stacks_FL[plot_dat$pcadaptQ<0.01],
       col=cols["pc"],cex=1,pch=0,lwd=2)
points(plot_dat$plot.pos[which(plot_dat$stacks_AL_P < 0.05 & 
                                 plot_dat$stacks_LA_P < 0.05 &
                           plot_dat$stacks_TX_P < 0.05 & 
                             plot_dat$stacks_FL_P < 0.05)],
       plot_dat$stacks_FL[which(plot_dat$stacks_AL_P < 0.05 & 
                                  plot_dat$stacks_LA_P < 0.05 &
                           plot_dat$stacks_TX_P < 0.05 & 
                             plot_dat$stacks_FL_P < 0.05)],
       col=cols["stacks"],cex=1,pch=5,lwd=2)
axis(2,las=1,pos=-1500000)
mtext("FLFW vs. FLCC",2,line=1,cex=0.65)
# add the LG labels
midpts<-tapply(plot_dat$plot.pos,plot_dat$Chrom,median)
text(x=midpts[lgs],y=-0.15)

# add outside legend

opar <- par(fig=c(0, 1, 0, 1), oma=c(0, 0, 0, 0),
            mar=c(0, 0, 0, 0), new=TRUE)
on.exit(par(opar))
plot(0, 0, type='n', bty='n', xaxt='n', yaxt='n')
legend("top",c(expression("Permutation"~italic("F")["ST"]),
         expression("Stacks"~italic("F")["ST"]),
         "PCAdapt",expression(italic("X")^T~italic("X")),"Salinity BF"),
       xjust = 0.5,x.intersp = 0.5,
       col = cols[c("perm","stacks","pc","xtx","sal")],
       pt.bg=cols[c("perm","stacks","pc","xtx","sal")],
       pch=c(4,5,0,3,2),bty='n',ncol=5)
dev.off()
```

And create upset plots to show overlap between pairwise Stacks comparisons and between all outlier methods.

```{r createUpsetPlots, eval=FALSE}
cols<-c(permutations='#e41a1c',salBF='#377eb8',pcadapt='#a65628',
        xtx='#ff7f00',sharedStacks='#f781bf',
        Alabama='#af8dc3',Louisiana='#e7d4e8',Texas='#762a83',Florida='#1b7837')
png("../figs/upsetOutliers.png",res=300,height=4,width=7.5,units="in",pointsize = 20)
upset(fromList(outliers),sets=c("permutations","salBF","xtx","pcadapt","sharedStacks"),
      point.size=3.5,line.size=2,mainbar.y.label = "Number of Shared Outliers",
      sets.x.label = " Number of Outliers",text.scale=c(1.5,1.5,1.5,1.5,1.5,1.5),
      sets.bar.color =cols[c("permutations","salBF","xtx","pcadapt","sharedStacks")],
      margin1scale = 0.2,
      sets.pt.color=cols[c("permutations","salBF","xtx","pcadapt","sharedStacks")])
dev.off()
png("../figs/sharedStacks.png",res=300,height=4,width=7.5,units="in",pointsize = 20)
upset(fromList(outliers),sets=c("Texas","Alabama","Louisiana","Florida"),
      point.size=3.5,line.size=2,mainbar.y.label = "Number of Shared Outliers",
      sets.x.label = " Number of Outliers",text.scale=c(1.5,1.5,1.5,1.5,1.5,1.5),
      sets.bar.color =cols[c("Texas","Alabama","Louisiana","Florida")],
      margin1scale = 0.2,
      sets.pt.color=cols[c("Texas","Alabama","Louisiana","Florida")],
      keep.order = TRUE)
dev.off()


```

And finally we'll stitch them together into a final image.

```{r CreateOutliersImage, eval=FALSE}
library(magick);library(multipanelfigure)

image_files <- c("../figs/FstOutliers.png",
                 "../figs/upsetOutliers.png",
                 "../figs/sharedStacks.png")


png("../figs/fstPlots.png",height=4,width=8,units="in",res=300,pointsize = 11)
figure <- multi_panel_figure(
  width = c(4.5, 3),
  height = c(1.8,1.8),
  unit = "inches",
  row_spacing = 0.0,column_spacing = 0
)
(figure %<>% fill_panel(image_files[1],row = 1:2,scaling="fit",
                        allow_panel_overwriting = TRUE) )
(figure %<>% fill_panel(image_files[3], column=2, row=1,scaling="fit") )
(figure %<>% fill_panel(image_files[2],column=2,row=2,scaling="fit"))
dev.off()

```

![Multipanel figure showing the locations of outlier loci in the genome (A) as well as overlap between the outlier analyses (B and C). This figure is Figure 2 in the main text.](../figs/fstPlots.png)

## Annotations {-}


```{r annotate_snps}
annotate_snps<-function(snpDF,gff,genome.blast,ID="Locus.ID",
                        chrom="Chr",bp="BP",pos="Column")
{
  fw.sig.reg<-do.call(rbind,apply(snpDF,1,function(sig){
    this.gff<-gff[as.character(gff$seqname) %in% 
                    as.character(unlist(sig[chrom])),]
    description<-NA
    SSCID<-NA
    if(nrow(this.gff)>0){
      
      this.reg<-this.gff[which(this.gff$start <= as.numeric(sig[bp]) & 
                           this.gff$end >= as.numeric(sig[bp])),]
      if(nrow(this.reg) == 0){
        if(as.numeric(sig[bp]) > max(as.numeric(this.gff$end))){
          region<-"beyond.last.contig"
        }else{
          region<-NA
        }
      }else{
        if(length(grep("SSCG\\d+",this.reg$attribute))>0){
          geneID<-unique(gsub(".*(SSCG\\d+).*",
                              "\\1",
                              this.reg$attribute[grep("SSCG\\d+",
                                                      this.reg$attribute)]))
          gene<-genome.blast[genome.blast$sscv4_gene_ID %in% geneID,
                             "blastp_hit_description"]
        }else{
          geneID<-NA
          gene<-NA
        }
        # if there are multiples they'll be in separated by a semi-colon
        region<-paste(this.reg$feature,collapse = ";")
        description<-paste(gene,collapse=";")
        SSCID<-paste(geneID,collapse=";")
      }
    }else{
      region<-"scaffNotFound"
    }
    return(data.frame(Locus=sig[[ID]],Chr=sig[chrom],BP=sig[bp],SNPCol=sig[pos],
                      region=region, description=description,SSCID=SSCID,
                      row.names=NULL))
  }))
}
```

```{r getGFF, eval=FALSE}
gff.name<-"ssc_2016_12_20_chromlevel.gff.gz"
if(length(grep("gz",gff.name))>0){
  gff<-read.delim(gzfile(paste("../../scovelli_genome/",gff.name,sep="")),header=F)
} else{
  gff<-read.delim(paste("../../scovelli_genome/",gff.name,sep=""),header=F)
}
colnames(gff)<-c("seqname","source","feature","start","end","score",
                 "strand","frame","attribute")
genome.blast<-read.csv("../../scovelli_genome/ssc_2016_12_20_cds_nr_blast_results.csv",
                       skip=1,header=T)#I saved it as a csv
```
```{r annotate_snpinfo, eval=FALSE}
fw_SNPinfo<-readRDS("fw_SNPinfo.RDS")

snp_annotate<-annotate_snps(fw_SNPinfo,gff,genome.blast,ID="ID",
                            chrom="Chrom",bp="BP.x",pos = "Pos")
snp_annotate$Locus<-as.character(snp_annotate$Locus)
fw_SNPinfo$ID<-as.character(fw_SNPinfo$ID)
fw_SNPinfo<-merge(fw_SNPinfo,snp_annotate,by.x="ID",by.y="Locus",all.x=TRUE)
saveRDS(fw_SNPinfo,"fw_SNPinfo.RDS")
```

```{r ann2outlier,eval=TRUE}
fw_SNPinfo<-readRDS("fw_SNPinfo.RDS")
outliers<-list(xtx=fw_SNPinfo$ID[fw_SNPinfo$XtX >= quantile(fw_SNPinfo$XtX,0.99,na.rm = TRUE)],
               salBF=fw_SNPinfo$ID[fw_SNPinfo$logSalBF>=
                                     quantile(fw_SNPinfo$logSalBF,0.99,na.rm = TRUE)],
               permutations=fw_SNPinfo$ID[
                 rowSums(fw_SNPinfo[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
               pcadapt=fw_SNPinfo$ID[which(fw_SNPinfo$pcadaptQ<0.01)],
               Alabama=fw_SNPinfo$ID[which(fw_SNPinfo$stacks_AL_P < 0.05)], 
               Louisiana=fw_SNPinfo$ID[which(fw_SNPinfo$stacks_LA_P < 0.05)],
               Texas=fw_SNPinfo$ID[which(fw_SNPinfo$stacks_TX_P < 0.05)],
               Florida=fw_SNPinfo$ID[which(fw_SNPinfo$stacks_FL_P < 0.05)],
               sharedStacks=fw_SNPinfo$ID[which(fw_SNPinfo$stacks_AL_P < 0.05 & 
                                                  fw_SNPinfo$stacks_LA_P < 0.05 &
                 fw_SNPinfo$stacks_TX_P < 0.05 & fw_SNPinfo$stacks_FL_P < 0.05)])
out_snps<-fw_SNPinfo[fw_SNPinfo$ID %in% unlist(outliers),]
```

````{r summarizeAnnotations, eval=TRUE}
annInfo<-fw_SNPinfo[,c("ID","SSCID")]
annInfo$SSCID<-as.character(annInfo$SSCID)
annInfo$SSCID[!is.na(annInfo$SSCID)]<-"coding"
annInfo$SSCID[is.na(annInfo$SSCID)]<-"non-coding"
annInfo$outlier<-"not-outlier"
annInfo$outlier[annInfo$ID %in% unlist(outliers)]<-"outlier"
kable(table(annInfo$SSCID,annInfo$outlier),booktabs=TRUE,
      caption="The number of SNPs in the subsetted dataset that were outliers in coding and non-coding regions of the genome.")
```

If our null hypothesis is that we have randomly selected outliers with equal probability from coding and non-coding regions, we can use a Fisher's exact test to calculate the probability of our observed distribution of outliers.

```{r fisherTestOutliers}
fisher.test(table(annInfo$SSCID,annInfo$outlier))
```

Based on this, we could conclude that our table of outliers in coding regions is more extreme than expected under the null. 

Now let's look at a more specific set of genes -- those from our salinity-associated gene set.

```{r rearrangePutatives,eval=FALSE}
put_genes<-read.delim("putative_genes.txt",stringsAsFactors = FALSE)
s<-strsplit(put_genes$Scovelli_geneID,",")
genes<-data.frame(Gene=rep(put_genes$Gene,sapply(s,length)),
                  SSCID=unlist(s),stringsAsFactors = FALSE)
dat<-do.call(rbind,apply(genes,1,function(gene,snpinfo){
  if(length(grep(gene["SSCID"],snpinfo$SSCID))>0){
    ID<-cbind(snpinfo$ID[grep(gene["SSCID"],snpinfo$SSCID)])
    out<-data.frame(ID,rbind(gene),row.names = NULL)
    return(out)
  }
},snpinfo=fw_SNPinfo))

info<-merge(fw_SNPinfo,dat,by="ID",all.x=TRUE)
fw_SNPinfo<-info[unique(info$ID),]
colnames(fw_SNPinfo)[colnames(fw_SNPinfo)=="SSCID.x"]<-"SSCID"
saveRDS(fw_SNPinfo,"fw_SNPinfo.RDS")
```
```{r putativeGeneAnns}
annInfo$salgene<-"not-putative"
annInfo$salgene[annInfo$ID %in% fw_SNPinfo$ID[!is.na(fw_SNPinfo$Gene)]]<-"putative"
kable(table(annInfo$outlier,annInfo$salgene),booktabs=TRUE,
      caption="The number of SNPs in the subsetted dataset that were outliers in putative salinity genes or not.")
```
```{r fisherTestOutliersPutative}
fisher.test(table(annInfo$outlier,annInfo$salgene))
```

Putative salinity genes do not appear to be enriched with outliers.

# References {-}


