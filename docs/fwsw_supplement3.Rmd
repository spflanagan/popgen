---
title: Supplemental Material \# 3 for "Multiple colonizations of freshwater by the Gulf pipefish reveal a shared genomic signature of adaptation"
preprint: false
author: 
  - name: Sarah P. Flanagan
    affilnum: 1
    corresponding: true
    email: spflanagan.phd@gmail.com
  - name: Emily Rose
    affilnum: 2
  - name: Adam Jones
    affilnum: 3
affiliation:
  - affilnum: 1
    affil: School of Biological Sciences, University of Canterbury, 4800 Private Bag, Christchurch 8140 New Zealand
  - affilnum: 2
    affil: Department of Biology, The University of Tampa, Tampa, FL 33606 USA
  - affilnum: 3
    affil: Department of Biological Sciences, University of Idaho, Moscow, ID 83844 USA
abstract: >
  This document includes supplementary material for the paper. 
  In this document, we provide additional methods and results associated with the identification of outliers and the interpretation of outliers from multiple analyses.
  These analyses combined to create Figure 2 and Figure 3. 
header-includes: >
  \usepackage{lipsum}
  \usepackage{float}
  \floatplacement{figure}{H}
bibliography: programs.bib
output:
  bookdown::pdf_document2:
    toc: true
    toc_depth: 2
    fig_caption: yes
    keep_tex: yes
    number_sections: no
    template: manuscript.latex
  html_document: null
  word_document: null
fontsize: 11pt
capsize: normalsize
csl: molecular-ecology.csl
documentclass: article
spacing: singlespacing
editor_options: 
  chunk_output_type: console
---

# Overview of the study {-}

The initial analyses are in `200_fwsw_analysis.Rmd` and conducted the analyses on a dataset generated from comparing lumped 'freshwater' and 'saltwater' populations, containing SNPs found in 50% of individuals and with a minor allele frequency of at least 5%. The revised paper will instead focus on two datasets:

1. A dataset with all 16 populations, generated from all pairwise comparisons of populations, containing SNPs found in every population, in 75% of individuals, and with a minor allele frequency of at least 5%.

2. A dataset containing only the 4 freshwater populations (TXFW, LAFW, ALFW, FLFW) and their nearest saltwater populations (TXCC, ALST, FLCC -- note ALST is the nearest neighbor to both ALFW and LAFW). This dataset also contains SNPs found in 75% of individuals with a minor allele frequency of at least 5%. 

This supplement focuses on the analysis of dataset #2, focused on the investigation of outliers and potential targets of selection. 


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,out.extra='',fig.pos="H",
                      warning = FALSE,message = FALSE,
                      dev='png',dpi=300)
knitr::opts_knit$set(root.dir='../fwsw_results/')
```
```{r source}
source("../../gwscaR/R/gwscaR.R")
source("../../gwscaR/R/gwscaR_plot.R")
source("../../gwscaR/R/gwscaR_utility.R")
source("../../gwscaR/R/gwscaR_fsts.R")
source("../../gwscaR/R/gwscaR_popgen.R")
source("../../gwscaR/R/vcf2dadi.R")
source("../R/203_treemix_plotting_funcs.R")#I've modified these functions
library(knitr)
library(scales)
library(kableExtra)
library(vegan)
```

```{r popSetup}
pop.list<-c("TXSP","TXCC","TXFW","TXCB","LAFW","ALST","ALFW","FLSG","FLKB",
	"FLFD","FLSI","FLAB","FLPB","FLHB","FLCC","FLLG")
pop.labs<-c("TXSP","TXCC","TXFW","TXCB","LAFW","ALST","ALFW","FLSG","FLKB",
            "FLFD","FLSI","FLAB","FLPB","FLHB","FLCC","FLFW")
fw.list<-c("TXFW","LAFW","ALFW","FLLG")
sw.list<-c("TXSP","TXCC","TXCB","ALST","FLSG","FLKB",
	"FLFD","FLSI","FLAB","FLPB","FLHB","FLCC")
lgs<-c("LG1","LG2","LG3","LG4","LG5","LG6","LG7","LG8","LG9","LG10","LG11",
	"LG12","LG13","LG14","LG15","LG16","LG17","LG18","LG19","LG20","LG21",
	"LG22")
lgn<-seq(1,22)
all.colors<-c(rep("black",2),"#2166ac","black","#2166ac","black","#2166ac",
        rep("black",8),"#2166ac")
#grp.colors<-c('#e41a1c','#377eb8','#4daf4a','#984ea3','#ffff33','#f781bf')
grp.colors<-c('#762a83','#af8dc3','#e7d4e8','#d9f0d3','#7fbf7b','#1b7837')
col_vector<-c(red='#e6194b', green='#3cb44b', blue='#4363d8',yellow='#ffe119', 
              cyan='#46f0f0',orange='#f58231', teal='#008080', purple='#911eb4',  
              magenta='#f032e6', lime='#bcf60c', pink='#fabebe',  lavendar='#e6beff', 
              brown='#9a6324', olive='#808000', apricot='#ffd8b1',maroon='#800000', 
              mint='#aaffc3', navy='#000075', beige='#fffac8', grey='#808080', 
              white='#ffffff', black='#000000')

col_vector<-c('#762a83','#762a83',"#2166ac",'#762a83',"#2166ac",'#af8dc3',
              "#2166ac",'#e7d4e8','#e7d4e8','#e7d4e8','#e7d4e8','#7fbf7b',
              '#1b7837','#1b7837','#1b7837',"#2166ac")

ppi<-data.frame(Pop=pop.labs,cols = col_vector,
                pch=rep(c(15,16,17,18),4))
ppi$pch[grep("FW",ppi$Pop)]<-c(15,16,17,18)
```


# Outliers: Fsts from Stacks, permutations, PCadapt  {-}

The alignments were done with a preliminary genome assembly from March 2016 that had a different linkage map than the genome that was published in [@smallGenomeGulfPipefish2016]. The only differences were the final orientation and position of the scaffolds in the linkage groups, so we corrected the position information in the Stacks output (including vcf files) using the agp files for the preliminary genome and the published genome. This correction was important for considering the genomic positions of the SNPs but not for the global parameter estimates such as those in Supplement 1.


```{r convert_agp}

convert.agp<-function(locus=NULL,old.agp,old.scf,new.agp,scf.agp,
                      chr=NULL,bp=NULL,id=NULL){
  
  if(!is.null(locus)){
    chr<-locus$`#CHROM`
    bp<-locus$POS
    id<-locus$ID
  }else{
    bp<-as.numeric(unlist(bp))
    chr<-as.character(chr)
    id<-as.character(id)
  }
  component<-as.data.frame(old.agp[old.agp$object == chr & 
                                     old.agp$object_beg <= bp & 
                                     old.agp$object_end >= bp,],
                           stringsAsFactors=FALSE)
  if(nrow(component)>0){
    # it's found on one of the LGs
    comp.id<-component$component_id
    if(comp.id != 100){
      #make sure it's an actual scaffold as a component
      comp.bp<-as.numeric(as.character(component$component_beg))+
        (bp-as.numeric(as.character(component$object_beg)))-1
      #sanity check - is it a reasonable size?
      if(comp.bp<as.numeric(as.character(component$component_end))){ 
        updated<-new.agp[new.agp$component_id%in%comp.id & 
                  as.numeric(as.character(new.agp$component_beg)) <=comp.bp & 
                  as.numeric(as.character(new.agp$component_end)) >= comp.bp,]
        if(nrow(updated)==0){ #if you didn't find it, check scaffold
          updated<-scf.agp[scf.agp$object%in%comp.id & 
                  as.numeric(as.character(scf.agp$object_beg)) <=comp.bp & 
                  as.numeric(as.character(scf.agp$object_end)) >= comp.bp,]
          updated.bp<-comp.bp
          updated.chr<-as.character(comp.id)
        } else{
          updated.bp<-updated$object_beg+comp.bp
          updated.chr<-as.character(updated$object)  
        }
      }else {
        print("WARNING: position in component larger than component")
        updated.bp<-comp.id
        updated.chr<-as.character(comp.id)
      }
    }else{
      print(paste("WARNING: locus ",id, " is not on a scaffold",sep=""))
      updated.bp<-bp
      updated.chr<-NA
    }
    out<-data.frame(Locus=id,OrigChr=chr,OrigBP=bp,
                    NewChr=updated.chr,NewBP=updated.bp,
                    stringsAsFactors = FALSE)
  }else{
    #it's not on an LG - let's check the scaffolds
    component<-as.data.frame(old.scf[old.scf$object == chr & 
                                       old.scf$object_beg <= bp & 
                                       old.scf$object_end >= bp,],
                             stringsAsFactors=FALSE)
    if(nrow(component)>0){
      #then we found it
      #check to make sure my bp makes sense
      if(bp < max(old.scf[old.scf$object==chr,"object_end"])){
        comp.bp<-bp
        comp.id<-as.character(chr)
        #look for it in the new assembly
        updated<-new.agp[new.agp$component_id%in%comp.id & 
                  as.numeric(as.character(new.agp$component_beg)) <=comp.bp &   
                  as.numeric(as.character(new.agp$component_end)) >= comp.bp,]
        if(nrow(updated)==0){ #if you didn't find it, check scaffold
          updated<-scf.agp[scf.agp$object%in%comp.id & 
                  as.numeric(as.character(scf.agp$object_beg)) <=comp.bp & 
                  as.numeric(as.character(scf.agp$object_end)) >= comp.bp,]
          updated.bp<-comp.bp
          updated.chr<-as.character(comp.id)
        } else{
          updated.bp<-updated$object_beg+comp.bp
          updated.chr<-as.character(updated$object)  
        }
      } else {
          print("WARNING: position in scaffold larger than scaffold")
          updated.bp<-NA
          updated.chr<-NA
      }
      out<-data.frame(Locus=id,OrigChr=chr,OrigBP=bp,
                      NewChr=updated.chr,NewBP=updated.bp,
                      stringsAsFactors = FALSE)
    }else{
      out<-data.frame(Locus=id,OrigChr=chr,OrigBP=bp,
                      NewChr=NA,NewBP=NA,
                      stringsAsFactors = FALSE)
      print(paste("WARNING: locus ", id, " not found",sep=""))
    }
  }
  
  return(out)
}
```
```{r convert_stacks}
convert.stacks<-function(stacks.fst,outname,lgs,ssc.agp,sscf.agp,chr.agp,scf.agp){
  for(i in 1:nrow(stacks.fst)){
     convert<-convert.agp(old.agp=ssc.agp,old.scf=sscf.agp,
                          new.agp=chr.agp[chr.agp$W=="W",],scf.agp = scf.agp,
                          chr=as.character(stacks.fst$Chr[i]),
                          bp=stacks.fst$BP[i],id=as.character(stacks.fst$Locus.ID[i]))
    stacks.fst[i,"Chr"]<-convert["NewChr"]
    stacks.fst[i,"BP"]<-convert["NewBP"]
  }
  # reorder by chrom
  scaffs<-levels(as.factor(stacks.fst$Chr))
  scaffs[1:22]<-lgs
  upd.fst<-do.call(rbind,lapply(scaffs,function(lg){
    this.chr<-stacks.fst[stacks.fst$Chr==lg,]
    this.chr<-this.chr[order(as.numeric(this.chr$BP)),]
    return(this.chr)
  }))
  write.table(upd.fst,outname,col.names = TRUE,row.names = FALSE,quote=FALSE,sep='\t')
  print(by(upd.fst,upd.fst$Chr,function(chr){ return(max(chr$BP)/1000000) })[lgs])
  return(upd.fst)
}
```

```{r gen_agp_lgs}
# old agps
ssc.agp<-read.delim("../../scovelli_genome/SSC_genome.agp",
                    comment.char="#",header=FALSE)
colnames(ssc.agp)<-c("object","object_beg","object_end","part_number","W",
                     "component_id","component_beg","component_end","orientation")
sscf.agp<-read.delim("../../scovelli_genome/SSC_scaffolds.agp",
                     comment.char="#",header=FALSE)
colnames(sscf.agp)<-c("object","object_beg","object_end","part_number","W",
                      "component_id","component_beg","component_end","orientation")
# new scaffold and chrom level agps
scf.agp<-read.delim(gzfile("../../scovelli_genome/ssc_2016_12_20_scafflevel.agp.gz"),
                    comment.char="#",header=FALSE)
chr.agp<-read.delim(gzfile("../../scovelli_genome/ssc_2016_12_20_chromlevel.agp.gz"),
                    comment.char="#",header=FALSE)
colnames(scf.agp)<-c("object","object_beg","object_end","part_number","W",
                     "component_id","component_beg","component_end","orientation")
colnames(chr.agp)<-c("object","object_beg","object_end","part_number","W",
                     "component_id","component_beg","component_end","orientation")
```

```{r convert_vcf,eval=FALSE}
vcf<-parse.vcf("stacks/populations_subset75/batch_2.pruned.vcf")
converted<-data.frame(Locus=integer(),OrigChr=character(),OrigBP=integer(),
                      NewChr=character(),NewBP=integer(),
                      stringsAsFactors = FALSE)
for(i in 1:nrow(vcf)){
  converted[i,]<-convert.agp(locus=vcf[i,],old.agp=ssc.agp,old.scf=sscf.agp,
                             new.agp=chr.agp[chr.agp$W=="W",],scf.agp = scf.agp)
}

```

```{r lgs}
lgs<-c("LG1","LG2","LG3","LG4","LG5","LG6","LG7","LG8","LG9","LG10","LG11",
	"LG12","LG13","LG14","LG15","LG16","LG17","LG18","LG19","LG20","LG21",
	"LG22")
```


```{r replace_vcf,eval=FALSE}
new.vcf<-as.data.frame(vcf,stringsAsFactor=FALSE)
for(i in 1:nrow(vcf)){
  new.vcf$POS[i]<-converted$NewBP[i]
  new.vcf$`#CHROM`[i]<-as.character(converted$NewChr[i])
}
write.table(new.vcf,"converted_subset.vcf",sep='\t',
            quote=FALSE,col.names = TRUE,row.names = FALSE)
```
```{r convertSWSW, eval=FALSE}
swsw.fl<-read.delim("stacks/populations_whitelist/batch_2.fst_FLCC-FLHB.tsv")
swsw.tx<-read.delim("stacks/populations_whitelist/batch_2.fst_TXCB-TXCC.tsv")
swsw.al<-read.delim("stacks/populations_whitelist/batch_2.fst_ALST-FLSG.tsv")

upd.st<-convert.stacks(swsw.tx,"stacks/converted.fst_TXCB-TXCC.txt",
                       lgs,ssc.agp,sscf.agp,chr.agp,scf.agp)
upd.sa<-convert.stacks(swsw.al,"stacks/converted.fst_ALST-FLSG.txt",
                       lgs,ssc.agp,sscf.agp,chr.agp,scf.agp)
upd.sf<-convert.stacks(swsw.fl,"stacks/converted.fst_FLCC-FLHB.txt",
                       lgs,ssc.agp,sscf.agp,chr.agp,scf.agp)
```


## Stacks{-}


We used the AMOVA-corrected $F_{ST}$ values calculated by the populations module in Stacks to investigate the patterns of fixation between each pair of freshwater and nearest saltwater populations. In each pairwise comparison, we identified SNPs that were outliers using the Fisher's $P$-value in the Stacks output, using an $\alpha=0.01$. We then identified those SNPs that were shared among all four pairwise comparisons as genomic regions with a potentially parallel response to selection from the freshwater habitats.

```{r readStacksFsts}
fwsw.al<-read.delim("stacks/populations_subset75/converted.fst_ALFW-ALST.txt")
fwsw.la<-read.delim("stacks/populations_subset75/converted.fst_ALST-LAFW.txt")
fwsw.tx<-read.delim("stacks/populations_subset75/converted.fst_TXCC-TXFW.txt")
fwsw.fl<-read.delim("stacks/populations_subset75/converted.fst_FLCC-FLFW.txt")
kable(cbind(nrow(fwsw.al),nrow(fwsw.la),nrow(fwsw.tx),nrow(fwsw.fl)),
      col.names=c("Alabama","Louisiana","Texas","Florida"),
      caption="The number of SNPs in each dataset")
```

These datasets do not contain the full 12103 SNPs (\@ref(tab:readStacksFsts)) because some of those SNPs are fixed in the populations or do not pass coverage or minimum allele frequency thresholds.


```{r plotStacksFsts,fig.height=9,fig.width=7,fig.cap="Manhattan plot of pairwise AMOVA-corrected Fst values from Stacks for each freshwater - nearest saltwater population pair. The x-axis corresponds to genomic locations, with chromosomes labelled. To the right are loci that mapped to unanchored scaffolds."}
source("../R/205_popgenPlotting.R")
fst_dat<-list(fwsw.al,fwsw.la,fwsw.tx,fwsw.fl)
fsts<-plot_multiple_LGs(list_fsts = fst_dat,fst_name = "Corrected.AMOVA.Fst",
                        bp_name="BP",chr_name="Chr",lgs=lgs,
                        plot_labs=list("ALFW vs ALST","ALST vs LAFW",
                                       "TXFW vs TXCC","FLFW vs FLCC"),
                        pt_cols = list(c(grp.colors[3],grp.colors[2]),
                                       c(grp.colors[2],grp.colors[3]),
                                       c(grp.colors[1],grp.colors[2]),
                                       c(grp.colors[6],grp.colors[5])),
                        ncol=1,addSmooth = FALSE,pch=19,y.lim = c(0,1),
                        pt.cex=1,axis.size = 1)
```



```{r getStacksSig}
tx.sig<-fwsw.tx[fwsw.tx$Fisher.s.P<0.01,"Locus.ID"]
la.sig<-fwsw.la[fwsw.la$Fisher.s.P<0.01,"Locus.ID"]
al.sig<-fwsw.al[fwsw.al$Fisher.s.P<0.01,"Locus.ID"]
fl.sig<-fwsw.fl[fwsw.fl$Fisher.s.P<0.01,"Locus.ID"]

all.shared<-fl.sig[fl.sig %in% la.sig & fl.sig %in% al.sig & fl.sig %in% tx.sig]
gulf_shared<-tx.sig[tx.sig %in% la.sig & tx.sig %in% al.sig]
```

There are `r length(unique(all.shared))` outliers (as determined by Fisher's P from stacks < 0.01). But because of the large pairwise Fsts between the Florida populations (Figure \@ref(fig:plotStacksFsts)), we'll focus on the shared SNPs in the Texas, Alabama, and Louisiana analyeses, in which we have `r length(unique(gulf_shared))`. 

As a point of comparison, we repeated this analysis with the similar pairwise saltwater-saltwater population pairs. We expect that if substantially more outlier loci were shared in the freshwater-saltwater comparisons than in the saltwater-saltwtaer comparisons that the shared outliers are likely a signature of adaptation to freshwater as opposed to random chance due to population structure.  

```{r plotStacksfstsSWSW,fig.height=9,fig.width=6,fig.cap="Manhattan plot of pairwise AMOVA-corrected Fst values from Stacks for the saltwater populations nearest to freshwater populations compared to their nearest saltwater neightbor. The x-axis corresponds to genomic locations, with chromosomes labelled. To the right are loci that mapped to unanchored scaffolds."}
swsw.fl<-read.delim("stacks/converted.fst_TXCB-TXCC.txt")
swsw.tx<-read.delim("stacks/converted.fst_ALST-FLSG.txt")
swsw.al<-read.delim("stacks/converted.fst_FLCC-FLHB.txt")
fst_dat<-list(swsw.fl,swsw.tx,swsw.al)
fsts<-plot_multiple_LGs(list_fsts = fst_dat,fst_name = "Corrected.AMOVA.Fst",
                        bp_name="BP",chr_name="Chr",lgs=lgs,
                        plot_labs=list("TXSP vs TXCC","ALST vs FLSG","FLHB vs FLCC"),
                        pt_cols = list(c(grp.colors[1],grp.colors[2]),
                                       c(grp.colors[2],grp.colors[3]),
                                       c(grp.colors[6],grp.colors[5])),
                        ncol=1,addSmooth = FALSE,pch=19,y.lim = c(0,1),
                        pt.cex=1,axis.size = 1)
```


```{r get_stacks_sig_swsw}
tx.sig<-swsw.tx[swsw.tx$Fisher.s.P<0.01,"Locus.ID"]
al.sig<-swsw.al[swsw.al$Fisher.s.P<0.01,"Locus.ID"]
fl.sig<-swsw.fl[swsw.fl$Fisher.s.P<0.01,"Locus.ID"]
all.shared<-fl.sig[fl.sig %in% al.sig & fl.sig %in% tx.sig]
```

We found `r length(unique(all.shared))` outliers shared among all four freshwater-saltwater pairwise $F_{ST}$ analyses and only `r length(unique(all.shared))` outlier shared among the saltwater-saltwater pairwise comparisons.

We can also look at the distributions of the Fst values for these two sets of pairwise comparisons, and we see that they are different.


```{r plot_fst_hists}
plot_fst_hists<-function(perms,plot_lab=NULL,cols=NULL,permlab="mean_perm",
                         reallab="Fst",baseplot=TRUE,inset=NULL){
  require(scales)
  if(is.null(plot_lab)){
    plot_lab<-""
  }
  if(is.null(cols)){
    cols<-c("grey","black")
  } 
  # else if(length(cols)==1){
  #   cols<-c("dark grey",cols)
  # }
  #inset<-par()$fig
  #browser()
  if(isTRUE(baseplot)){
    hist(perms[,permlab][perms[,permlab]>0],col=alpha(cols[1],0.5),border = alpha(cols[1],0.5),
         xlim=c(0,1),breaks = seq(0,1,0.1),main = plot_lab,
         xlab=expression(italic(F)[ST]),
         ylab="Number of SNPs")
    # hist(perms[,reallab],col=alpha(cols[2],0.5),border = alpha(cols[2],0.5),
    #      xlim=c(0,1),breaks = seq(0,1,0.1),main = "",
    #      xlab=expression(italic(F)[ST]),
    #      ylab="Number of SNPs",add=TRUE)
  }
  if(!is.null(inset)){ # add an inset
    # adjust the fig coordinates
    ifig<-c(inset[1]+0.25*(inset[2]-inset[1]),inset[2], 
            inset[3]+0.25*(inset[4]-inset[3]), inset[4])
    par(fig = ifig,new=TRUE) # start x, end x, start y, end y (percent plotting space)
    # hist(perms[,permlab][perms[,reallab]>0],col=alpha(cols[1],0.5),
    #      border = alpha(cols[1],0.5),
    #      xlim=c(0,1),breaks = seq(0,1,0.1),main = "",xlab="",
    #      ylab="")
    
    hist(perms[,reallab,][perms[,reallab]>0],col=alpha(cols[2],0.5),
         border = alpha(cols[2],0.5),
         xlim=c(0,1),breaks = seq(0,1,0.1),main = "",xlab="",
         ylab="")
    box() #give it a box
  }
  invisible(par()$fig)
}

```

```{r StacksFstsHists,dpi=300,fig.width=8,fig.height=7,fig.cap="Distributions of the Stacks AMOVA-Corrected Fst values for the pairwise comparisons of each freshwater population and its nearest saltwater neighbor (main plots) and the pairwise comparisons of those saltwater popuulations and their nearset saltwater population (insests)."}
fwsw_list<-list(fwsw.tx,fwsw.la,fwsw.al,fwsw.fl)
swsw_list<-list(swsw.tx,swsw.al,swsw.al,swsw.fl)

plot_labs<-list("TXFW vs TXCC","ALST vs LAFW","ALFW vs ALST","FLFW vs FLCC")
pt_cols<-list(grp.colors[1],grp.colors[2],grp.colors[3],grp.colors[6])

par(mfrow=c(2,2),new=FALSE,mar=c(4,4,3,1),ps=16)
#plot the base
pars<-mapply(plot_fst_hists,perms=fwsw_list,plot_lab=plot_labs,
             permlab="Corrected.AMOVA.Fst",reallab="Corrected.AMOVA.Fst",
             cols=pt_cols,SIMPLIFY = FALSE)
# add the insets
ipars<-mapply(plot_fst_hists,perms=swsw_list,plot_lab=plot_labs,
              inset=pars,permlab="Corrected.AMOVA.Fst",reallab="Corrected.AMOVA.Fst",
              MoreArgs = list(baseplot=FALSE))


```


## Permutations {-}

We used permutations of the population labels to calculate a null distribution of $F_{ST}$ values for each fresthwater-saltwater population pair. We then compared those permuted values to the 'true' $F_{ST}$ values calculated with the correctly-applied population labels. We used gwscaR to implement 1000 permutations per population pair. Outliers were identified as those SNPs whose actual $F_{ST}$ values were outside of the distribution of $F_{ST}$ values from all 1000 permutations, either larger or smaller. For our outlier analyses, we restricted our attention to those SNPs that were outliers in the permutations of all four freshwater-saltwater population pairs.  

```{r permute.gwsca}
permute.gwsca<-function(vcf,map1,nperms,z=1.96, maf.cutoff = 0.05,cov.thresh=0.2){
  # calculate the actuals
  actual_fsts<-gwsca(vcf,colnames(vcf)[1:9],
                     map1[map1[,2] %in% unique(map1[,2])[1],1],
                     map1[map1[,2] %in% unique(map1[,2])[2],1],
                     maf.cutoff=maf.cutoff,prop.ind.thresh=cov.thresh)
  # do the permutations
  perm_fsts<-lapply(1:nperms,function(i,vcf,map1){
    perm_map<-map1
    perm_map[,2]<-perm_map[,2][permute::shuffle(perm_map[,2])]
    perm_dat<-gwsca(vcf,colnames(vcf)[1:9],
                     perm_map[perm_map[,2] %in% unique(perm_map[,2])[1],1],
                     perm_map[perm_map[,2] %in% unique(perm_map[,2])[2],1],
                     maf.cutoff,cov.thresh)
   
    return(perm_dat)
  },vcf=vcf,map1=map1)
  
  # calculate stats
  fsts<-t(do.call(rbind,lapply(perm_fsts,'[[',"Fst"))) #extract permuted fsts
  perm_fst_mu<-rowMeans(fsts)
  perm_fst_in<-NULL
  for(i in 1:nrow(actual_fsts)){
    pmax<-max(fsts[i,] )
    pmin<-min(fsts[i,] )
    if(actual_fsts[i,"Fst"] > pmax | actual_fsts[i,"Fst"] < pmin ){
      perm_fst_in[i]<-1
    }else{
      perm_fst_in[i]<-0
    }
  }
  
  fst_dat<-data.frame(cbind(actual_fsts,
                            n_perms=nperms,
                            mean_perm=perm_fst_mu,
                            act_in_perm=perm_fst_in))
  return(fst_dat)
}
```
```{r permuteVCF,eval=FALSE}
vcf<-parse.vcf("converted_subset.vcf")
popmap<-data.frame(inds=colnames(vcf)[10:ncol(vcf)],
                   pops=gsub("sample_(\\w{4}).*","\\1",colnames(vcf)[10:ncol(vcf)]),
                   stringsAsFactors = FALSE)
pwise_maps<-list(popmap[popmap$pops %in% c("TXFW","TXCC"),],
                 popmap[popmap$pops %in% c("FLLG","FLCC"),],
                 popmap[popmap$pops %in% c("ALFW","ALST"),],
                 popmap[popmap$pops %in% c("LAFW","ALST"),])

permuted_fsts<-lapply(pwise_maps,permute.gwsca,vcf=vcf,nperms=1000, maf.cutoff=0)
saveRDS(permuted_fsts,"permuted_fsts.RDS")
```



```{r permTable}
permuted_fsts<-readRDS("permuted_fsts.RDS")
perm_summ<-do.call(rbind,lapply(permuted_fsts,function(dat){
  actMu<-mean(dat$Fst)
  actSEM<-sqrt(var(dat$Fst)/nrow(dat))
  perMu<-mean(dat$mean_perm)
  perSEM<-sqrt(var(dat$mean_perm)/nrow(dat))
  nOut<-nrow(dat[which(dat$act_in_perm==1),])
  return(data.frame(actMu,actSEM,perMu,perSEM,nOut))
}))
row.names(perm_summ)<-c("TXFW_TXCC","FLFW_FLCC","ALFW_ALST","LAFW_ALST")
landscape(kable(perm_summ,"latex",row.names = TRUE,booktabs=TRUE,
      col.names=c("Actual mean Fst","Actual Fst SEM","Permuted mean Fst","Permuted Fst SEM", "Number of outliers"),
      caption="Summary of the permutations. Presented are the mean and standard error of the mean for the actual and permuted Fst values for each comparison. Also shown are the number of outliers identified in each analysis, where outliers were defined as those loci whose actual Fst values we either larger or smaller than the maximum or minimum permuted Fst value."))
```
```{r permOut}
permOut<-data.frame(perm_TX=permuted_fsts[[1]]$act_in_perm,
                     perm_FL=permuted_fsts[[2]]$act_in_perm,
                     perm_AL=permuted_fsts[[3]]$act_in_perm,
                     perm_LA=permuted_fsts[[4]]$act_in_perm)
```


The permutations resulted in substantially lower $F_{ST}$ values than the actual $F_{ST}$ values (Table \@ref(tab:permTable)), and the permuted $F_{ST}$s were very close to zero (Table \@ref(tab:permTable); Figure (\@ref(fig:plotPermutations))) whereas the actual $F_{ST}$ values had a larger tail. The increase in the overall number of outliers in the ALFW vs ALST and LAFW vs ALST comparisons likely reflects the fact that those permuted $F_{ST}$ values were much closer to zero with smaller permuted standard errors of the mean than the other two comparisons, likely due to the admixture in those populations. A total of `r nrow(permOut[which(rowSums(permOut)==4),])` SNPs were identified as outliers in all four permutation analyses and `r nrow(permOut[which(rowSums(permOut[,c(1,3,4)])==3),])` were shared among Texas, Alabama, and Louisiana pairwise comparisons.   


```{r MakePermutationsPlot, eval=FALSE}
plot_labs<-list("TXFW vs TXCC","FLFW vs FLCC","ALFW vs ALST","ALST vs LAFW")
pt_cols<-list(TXTX=grp.colors[1],FLFL=grp.colors[6],
              ALAL=grp.colors[3],ALLA=grp.colors[2])
png("../figs/permuted_fsts.png",pointsize = 16,height=7,width=8,units="in",res=300)
par(mfrow=c(2,2),new=FALSE,mar=c(4,4,3,1))
#plot the base
pars<-mapply(plot_fst_hists,perms=permuted_fsts,plot_lab=plot_labs,
             cols=pt_cols,SIMPLIFY = FALSE)
# add the insets
ipars<-mapply(plot_fst_hists,perms=permuted_fsts,plot_lab=plot_labs,cols=pt_cols,
              inset=pars,
              MoreArgs = list(baseplot=FALSE))
dev.off()
```

```{r plotPermutations,out.width='85%', fig.cap="Histograms of pairwise Fst values generated by the permutations (in grey) and the actual Fst values (in color in insets). Only loci with Fst values larger than zero are shown in the histograms."}
knitr::include_graphics('../figs/permuted_fsts.png')
```

We can also look at the genome-wide patterns of the permutations vs the actual Fsts, and we can see that the permuted Fsts have much smaller average Fsts and virtually no outliers (Figure \@ref(fig:permFstGenomewide)), unlike the actual pairwise Fst values (Figure \@ref(fig:permActualFstGenomewide)). The actual Fsts (Figure \@ref(fig:permActualFstGenomewide)) show similar patterns to the Stacks Fst analysis (Figure \@ref(fig:plotStacksFsts)) in the actual fsts , where the Florida pairwise comparison has much higher overall Fst values. These are not identical to the Stacks analysis because these Fsts are calculated without any corrections using the 

```{r permFstGenomewide,fig.height=9,fig.width=7,fig.cap="Manhattan plot of pairwise average Fst values from the permutation of population IDs for each freshwater - nearest saltwater population pair. The x-axis corresponds to genomic locations, with chromosomes labelled. To the right are loci that mapped to unanchored scaffolds."}
perm_dat<-list(permuted_fsts[[1]],permuted_fsts[[4]],permuted_fsts[[3]],permuted_fsts[[2]])
fsts<-plot_multiple_LGs(list_fsts = perm_dat,fst_name = "mean_perm",
                        bp_name="Pos",chr_name="Chrom",lgs=lgs,
                        plot_labs=list("TXFW vs TXCC","ALST vs LAFW",
                                       "ALFW vs ALST","FLFW vs FLCC"),
                        pt_cols = list(c(grp.colors[3],grp.colors[2]),
                                       c(grp.colors[2],grp.colors[3]),
                                       c(grp.colors[1],grp.colors[2]),
                                       c(grp.colors[6],grp.colors[5])),
                        ncol=1,addSmooth = FALSE,pch=19,y.lim = c(0,1),
                        pt.cex=1,axis.size = 1)
```

```{r permActualFstGenomewide,fig.height=9,fig.width=7,fig.cap="Manhattan plot of pairwise Fst values calculated for each freshwater - nearest saltwater population pair. The x-axis corresponds to genomic locations, with chromosomes labelled. To the right are loci that mapped to unanchored scaffolds."}
perm_dat<-list(permuted_fsts[[1]],permuted_fsts[[4]],permuted_fsts[[3]],permuted_fsts[[2]])
fsts<-plot_multiple_LGs(list_fsts = perm_dat,fst_name = "Fst",
                        bp_name="Pos",chr_name="Chrom",lgs=lgs,
                        plot_labs=list("TXFW vs TXCC","ALST vs LAFW",
                                       "ALFW vs ALST","FLFW vs FLCC"),
                        pt_cols = list(c(grp.colors[1],grp.colors[2]),
                                       c(grp.colors[2],grp.colors[3]),
                                       c(grp.colors[3],grp.colors[2]),
                                       c(grp.colors[6],grp.colors[5])),
                        ncol=1,addSmooth = FALSE,pch=19,y.lim = c(0,1),
                        pt.cex=1,axis.size = 1)
```


```{r fstOutlierSummary}
fw_SNPinfo<-readRDS("fw_SNPinfo.RDS")
outliers<-list(xtx=fw_SNPinfo$ID[fw_SNPinfo$XtX >= quantile(fw_SNPinfo$XtX,0.99,na.rm = TRUE)],
               salBF=fw_SNPinfo$ID[fw_SNPinfo$logSalBF>=
                                     quantile(fw_SNPinfo$logSalBF,0.99,na.rm = TRUE)],
               permutations=fw_SNPinfo$ID[
                 rowSums(fw_SNPinfo[,c("perm_TX","perm_AL","perm_LA")])==3],
               pcadapt=fw_SNPinfo$ID[which(fw_SNPinfo$pcadaptQ<0.01)],
               Alabama=fw_SNPinfo$ID[which(fw_SNPinfo$stacks_AL_P < 0.05)], 
               Louisiana=fw_SNPinfo$ID[which(fw_SNPinfo$stacks_LA_P < 0.05)],
               Texas=fw_SNPinfo$ID[which(fw_SNPinfo$stacks_TX_P < 0.05)],
               Florida=fw_SNPinfo$ID[which(fw_SNPinfo$stacks_FL_P < 0.05)],
               sharedStacks=fw_SNPinfo$ID[which(fw_SNPinfo$stacks_AL_P < 0.05 & 
                                                  fw_SNPinfo$stacks_LA_P < 0.05 &
                 fw_SNPinfo$stacks_TX_P < 0.05)])
fst_outs<-outliers$permutations[outliers$permutations %in% outliers$sharedStacks]
fst_out_dat<-fw_SNPinfo[fw_SNPinfo$ID %in% fst_outs,
           c("ID","SSCID","Chrom","BP","REF","ALT","region","description")]
fst_out_dat$region<-as.character(fst_out_dat$region)
fst_out_dat$region[grep("UTR",fst_out_dat$region)]<-"regulatory"
fst_out_dat$region[grep("gene",fst_out_dat$region)]<-"coding"
fst_out_dat$region[fst_out_dat$region %in% "contig"]<-"non-coding"
fst_out_dat$region[fst_out_dat$region %in% "scaffNotFound"]<-"unkown"
fst_out_dat$SSCID<-gsub(";","; ",fst_out_dat$SSCID)
fst_out_dat$Chrom<-gsub("_"," ",fst_out_dat$Chrom)
kable(fst_out_dat,"latex",booktabs=TRUE,row.names=FALSE,
      caption="SNPs that were Fst outliers in all pairwise Texas, Alabama, and Louisiana Stacks and permutation analyses. Shown are the SNP ID in this dataset, the ID of the gene it is mapped to in the S. scovelli genome, its location and reference and alternative alleles. The final two columns show the type of genomic region the SNP is in and the gene description (if relevant).") %>%
  kable_styling(latex_options="HOLD_position")%>%
  column_spec(1,width="2.5em") %>%
  column_spec(2,width="7.5em") %>%
  column_spec(3,width="3em") %>%
  column_spec(4,width="3em") %>%
  column_spec(5,width="1.5em") %>%
  column_spec(6,width="1.5em") %>%
  column_spec(7,width="3.5em") %>%
  column_spec(8,width="15em")
```

We can also take a look at the SNPs shared in both the Stacks and permutation analyses (focusing on the outliers in all pairwise Texas, Louisiana, and Alabama comparisons but not the Florida analyses). We found `r nrow(fst_out_dat)` shared SNPs, (`r nrow(fst_out_dat[grep("SSCG",fst_out_dat$SSCID),])`) of which matched annotated regions in the *S. scovelli* genome. One of these (Tripartite motif-containing protein 7, or TRIM7) is in the list of genes previously found to be involved in freshwater adaptation (Table \@ref(tab:putativeGeneAnns)). 

## PCAdapt {-}

We ran PCAdapt [@luuPcadaptPackagePerform2017] using the subsetted dataset to identify outliers while controlling for population structure. After an initial analysis with 20 principal components axes retained (Figure \@ref(fig:pcadaptOutliers)), $K=4$ was chosen as the appropriate number of axes to retain for the analysis.

```{r readVCFpcadapt}
vcf<-parse.vcf("converted_subset.vcf")
```
```{r convertVCF, eval=FALSE}
write.table("##fileformat=VCFv","pcadapt_fw/fwsw.pruned.vcf",quote=FALSE,
            col.names = FALSE,row.names = FALSE)
suppressWarnings(write.table(vcf,"pcadapt_fw/fwsw.pruned.vcf",
                             quote=FALSE,append = TRUE,
                             row.names = FALSE,col.names = TRUE,sep='\t'))
```
```{r pcadaptOutliers,message=FALSE,warning=FALSE, fig.cap="Screeplot for the subsetted dataset with 20 PC axes retained in the analysis."}
library(pcadapt)
#need to remove the first line with a # 
filename<-read.pcadapt("pcadapt_fw/fwsw.pruned.vcf",type="vcf") 
x<-pcadapt(filename, K=20)
plot(x,option="screeplot")
```
```{r organizePopInfo}
# Organize pop info
pops<-gsub("sample_(\\w{4}).*","\\1",colnames(vcf)[10:ncol(vcf)])	
grp<-pops
grp[grp=="TXFW" | grp=="LAFW" | grp=="ALFW" | grp=="FLLG"]<-"freshwater"
grp[grp!="freshwater"]<-"saltwater"
```

The PCAdapt analysis with $K=4$ offers broadly the same conclusions about population structure as the analysis of the full dataset -- the first PC axis differentiates between the Florida populations and the rest, while the second PC axis allows for more separation of the freshwater and saltwater populations in Texas and Florida. The Alabama saltwater, Alabama freshwater, and Louisiana freshwater populations all form one cluster (Figure \@ref(fig:PcadaptK4pcs)). These results are all consistent with those from the analysis of the dataset containing all 16 populations (see the main text and supplement 1).

```{r PcadaptK4pcs, fig.cap="Plot of the scores from the PCAdapt outlier analysis with the subsetted dataset and 4 PC axes retained in the analysis."}
res<-pcadapt(filename,K=4)
plot(res, option="scores",pop=pops)
```


Although our dataset contains loci that should be unlinked (only one SNP per RAD locus), we visualized the loadings for all of the SNPs to evaluate whether any of the loadings were clustered by region. FOr all four principal components axes, the the loadings for the SNPs were randomly distributed throughout the genome with no obvious clustering (Figure \@ref(fig:PcadaptLoadings)), even when visualized across each chromosome (Figure \@ref(fig:PcadaptLoadingsChr)).

```{r PcadaptLoadings, fig.cap="Plots of the loadings for the four PC axes according to genomic position (on the x-axis)."}
par(mfrow = c(2, 2))
for (i in 1:4)
  plot(res$loadings[, i], pch = 19, cex = .3, ylab = paste0("Loadings PC", i))
```


```{r PcadaptLoadingsChr,fig.height=8, fig.cap="Inspecting the loadings for the four PC axes according to genomic position (on the x-axis) for each chromosome individually."}
par(mfrow=c(6,4),mar=c(3,3,2,1.5))
l<-lapply(lgs, function(lg,vcf){
  plot(res$loadings[which(vcf$`#CHROM` %in% lg), 1], pch = 19, cex = .3, 
       xlab = paste0("Position on ", lg), ylab = "Loadings PC 1")
  mtext(lg,3,outer=FALSE)
},vcf=vcf)
```


PCadapt calculated test statistics based on $z$-scores from regressing SNPs with the $K=4$ principal components, using the Mahalanobis distance. We visualized the distribution of the resulting p-values using a Manhattan plot (Figure \@ref(fig:PcadaptK4-1)), which revealed a small number of loci with small p-values. The Q-Q plot (Figure \@ref(fig:PcadaptK4-2)) also reflected the fact that many loci followed the uniform distribution, but the smallest p-values are smaller than expected, confirming the presence of outlier SNPs in the dataset. The distribution of the test statistic further confirms these findings (Figure \@ref(fig:PcadaptK4-3)), with most of the test statistics concentrated around zero but with some in the tail of the distribution. 

```{r PcadaptK4-1, fig.cap="Manhattan plot for the PCAdapt outlier analysis with the subsetted dataset and 4 PC axes retained in the analysis."}

plot(res, option="manhattan")
```
```{r PcadaptK4-2, fig.cap="Q-Q plot for the PCAdapt outlier analysis with the subsetted dataset and 4 PC axes retained in the analysis."}
plot(res, option="qqplot")
```
```{r PcadaptK4-3, fig.cap="Distribution of the  for the PCAdapt outlier analysis with the subsetted dataset and 4 PC axes retained in the analysis."}
plot(res, option="stat.distribution")
```


```{r PcadaptQvalue}
library(qvalue)
qval <- qvalue(res$pvalues)$qvalues
alpha <- 0.05
outliers <- which(qval < alpha)
snp_pc<-get.pc(res,outliers) # Get the PCs associated with outliers
```

To identify outliers, we used the `qvalue` package [@storeyQvalueQvalueEstimation2019] to transform p-values into q-values. We chose a false discovery rate of $\alpha=0.05$. Using this approach we identified `r length(outliers)` outliers associated with `r length(unique(snp_pc$PC))` of the 4 PC axes, although most of them were associated with PC1 (Table \@ref(tab:showPcadaptOutliers)).

```{r showPcadaptOutliers}
pcs<-table(snp_pc$PC)
names(pcs)<-c("PC1","PC2","PC3","PC4")
kable(t(pcs),booktabs=TRUE,
      caption="Number of outliers associated with each of the four retained principal components axes")
```


## Bayenv {-}



```{r compareEnvVar,warning=FALSE,message=FALSE}
env.data<-read.csv("bayenv/env_data_raw.csv",row.names = 1)
env.data<-rbind(env.data,pop=c(rep("SW",12),rep("FW",4)))
env.data<-as.data.frame(t(env.data))
sal<-wilcox.test(as.numeric(env.data$salinity)~env.data$pop)
tmp<-wilcox.test(as.numeric(env.data$temp)~env.data$pop) #ties, but p=0.539
sgr<-wilcox.test(as.numeric(env.data$seagrass)~env.data$pop) #ties, but p=0.897
```

We used Bayenv2.0 [@guntherRobustIdentificationLocal2013] to use correlations between environmental variables (water temperature, salinity, and seagrass) and allele frequencies to identify loci possibly experiencing local adaptation. Before running the analysis, we compared the environmental variables between freshwater and saltwater populations using a Wilcoxon rank-sum test and found that unsurprisingly salinity differed significantly ($W=$ `r sal$statistic`, $p=$ `r sal$p.value`), but water temperature ($W=$ `r tmp$statistic`, $p=$ `r tmp$p.value`) and seagrass coverage did not ($W=$ `r sgr$statistic`, $p=$ `r sgr$p.value`).

We began by estimating the covariance matrices in ten independent runs. The matrices from each run were compared visually (Figure \@ref(fig:BayenvMatrices)) and determined to follow similar patterns, suggesting that the matrix is well estimated. Given that all matrices were similar in pattern, we randomly selected one of the 10 matrices to use in the subsequent analyses.

```{r BayenvMatrices,out.width='90%',out.height='50%',fig.cap="Heatmap plots of each of the ten replicate Bayenv covariance matrices. Darker colors represent higher covariances. Populations are in the order: "}
knitr::include_graphics('../fwsw_results/bayenv/fwsw75_pruned.png')
```


```{r bayenv}
#taken directly from fwsw_analysis.R
bayenv.dat<-read.delim("bayenv/bayenv_output.txt",header=T)
# calculate quantiles for bayes factors
#focus on Bayes Factors, because of Lotterhos & Whitlock (2015)
bf.co<-apply(bayenv.dat[,grep("BF",colnames(bayenv.dat))],2,quantile,0.99,na.rm=TRUE) 
temp.bf.sig<-bayenv.dat[bayenv.dat$temp_BF>bf.co["temp_BF"],]
sal.bf.sig<-bayenv.dat[bayenv.dat$salinity_BF>bf.co["salinity_BF"],]
grass.bf.sig<-bayenv.dat[bayenv.dat$seagrass_BF>bf.co["seagrass_BF"],]
#get the log transformed Bayes Factors
bayenv.dat$logSal<-log(bayenv.dat$salinity_BF)
bayenv.dat$logTemp<-log(bayenv.dat$temp_BF)
bayenv.dat$logSeagrass<-log(bayenv.dat$seagrass_BF)

# xtx
xtx.sig<-bayenv.dat[bayenv.dat$XtX > quantile(bayenv.dat$XtX,0.99,na.rm=TRUE),]
```

We ran Bayenv2.0 to identify environmental correlations for each SNP (represented by the resulting Bayes Factors) and to estimate population differentiation statistics (represented by the $X^TX$ value for each SNP). To analyze the output of the Bayenv2.0 environmental correlation runs, we identified loci that had extreme Bayes Factors and extreme $X^TX$ statistics as those in the 99th quantile. We found `r nrow(temp.bf.sig[temp.bf.sig$locus %in% sal.bf.sig$locus & temp.bf.sig$locus %in% grass.bf.sig,])` overlapping outliers between temperature-, salinity-, and seagrass-associated loci. However, because we are interested in shared signatures of adaptation to freshwater, we focused our attention to the salinity-associated loci, of which we found `r nrow(sal.bf.sig)`. Of those, `r nrow(xtx.sig[xtx.sig$locus %in% sal.bf.sig$locus,])` were also outliers in the distribuion of the population differentiation statistics, $X^TX$. Neither the set of outliers associated with associated or population differentiation showed spatial clustering genome-wide (see figure 4 in the main text).

## Summarizing outliers

To summarize the results of the outliers

```{r getOutliers}
fw_SNPinfo<-readRDS("fw_SNPinfo.RDS")
outliers<-list(xtx=fw_SNPinfo$ID[fw_SNPinfo$XtX >= quantile(fw_SNPinfo$XtX,0.99,na.rm = TRUE)],
               salBF=fw_SNPinfo$ID[fw_SNPinfo$logSalBF>=
                                     quantile(fw_SNPinfo$logSalBF,0.99,na.rm = TRUE)],
               permutations=fw_SNPinfo$ID[
                 rowSums(fw_SNPinfo[,c("perm_TX","perm_AL","perm_LA")])==3],
               pcadapt=fw_SNPinfo$ID[which(fw_SNPinfo$pcadaptQ<0.01)],
               Alabama=fw_SNPinfo$ID[which(fw_SNPinfo$stacks_AL_P < 0.05)], 
               Louisiana=fw_SNPinfo$ID[which(fw_SNPinfo$stacks_LA_P < 0.05)],
               Texas=fw_SNPinfo$ID[which(fw_SNPinfo$stacks_TX_P < 0.05)],
               Florida=fw_SNPinfo$ID[which(fw_SNPinfo$stacks_FL_P < 0.05)],
               sharedStacks=fw_SNPinfo$ID[which(fw_SNPinfo$stacks_AL_P < 0.05 & 
                                                  fw_SNPinfo$stacks_LA_P < 0.05 &
                 fw_SNPinfo$stacks_TX_P < 0.05)])
```
```{r outChroms}
outlierSumm<-do.call(rbind,lapply(outliers,function(outs){

  chs<-table(fw_SNPinfo$Chrom[fw_SNPinfo$ID %in% outs])
  return(data.frame(NumOutliers=nrow(fw_SNPinfo[fw_SNPinfo$ID %in% outs,]),
              NumChrom=length(chs[grep("LG",names(chs))]),
             NumScaffs=length(chs[grep("LG",names(chs),invert = TRUE)]),
             NumCoding=length(which(!is.na(fw_SNPinfo$SSCID[fw_SNPinfo$ID %in% outs])))))
}) )
kable(outlierSumm,"latex",booktabs=TRUE,
      caption="Table summarizing the outliers from each analysis.")
```




# Annotations {-}

Adaptation to freshwater might involve changes in coding regions of the genome or changes in regulatory regions, so we used the *S. scovelli* genome to identify the genomic locations of the outlier loci identified by our various analyses (Stacks $F_{ST}$s, permutations, PCAdapt outliers, Bayenv population differentiation, and Bayenv salinity correlations). We were able to identify whether outlier SNPs were located in coding regions, 3' or 5' untranslated regions ('regulatory regions'), or un-annotated regions of the genome. This last category we consider to be 'non-coding' as the *S. scovelli* genome was annotated using RNA-sequencing data from embryonic head tissue and brood pouch tissue, as well as other fish species such as *Danio rerio*, so un-annotated regions are likely to be non-coding. One of the SNPs in the dataset could not be mapped to a location in the genome. 

```{r ann2outlier,eval=TRUE}
fw_SNPinfo<-readRDS("fw_SNPinfo.RDS")
out_snps<-fw_SNPinfo[fw_SNPinfo$ID %in% unlist(outliers),]
```

````{r summarizeAnnotations, eval=TRUE}
annInfo<-fw_SNPinfo[,c("ID","region")]
annInfo$region<-as.character(annInfo$region)

annInfo$region[grep("UTR",annInfo$region)]<-"regulatory"
annInfo$region[grep("gene",annInfo$region)]<-"coding"
annInfo$region[annInfo$region %in% "contig"]<-"non-coding"
annInfo$region[annInfo$region %in% "scaffNotFound"]<-"unkown"

annInfo$outlier<-"not-outlier"
annInfo$outlier[annInfo$ID %in% unlist(outliers)]<-"outlier"
kable(table(annInfo$region,annInfo$outlier),booktabs=TRUE,
      caption="The number of SNPs in the subsetted dataset that were outliers in coding and non-coding regions of the genome.") %>%
  kable_styling(latex_options="HOLD_position")
```

```{r fisherTestOutliers, message=FALSE,warning=FALSE}
ft<-fisher.test(table(annInfo$region,annInfo$outlier))
```

We did not find that the outliers in the analysis (in aggregate) were found in any one genomic region at a higher frequency than the non-outlier loci (Table \@ref(tab:summarizeAnnotations), Fisher's exact test, odds ratio $=$ `r ft$estimate`, $p=$ `r ft$p.value`).


```{r putGenes}
put_genes<-read.delim("putative_genes.txt",stringsAsFactors = FALSE)
```

```{r rearrangePutatives,eval=FALSE}
s<-strsplit(put_genes$Scovelli_geneID,",")
genes<-data.frame(Gene=rep(put_genes$Gene,sapply(s,length)),
                  SSCID=unlist(s),stringsAsFactors = FALSE)
dat<-do.call(rbind,apply(genes,1,function(gene,snpinfo){
  if(length(grep(gene["SSCID"],snpinfo$SSCID))>0){
    ID<-cbind(snpinfo$ID[grep(gene["SSCID"],snpinfo$SSCID)])
    out<-data.frame(ID,rbind(gene),row.names = NULL)
    return(out)
  }
},snpinfo=fw_SNPinfo))

info<-merge(fw_SNPinfo,dat,by="ID",all.x=TRUE)
fw_SNPinfo<-info[unique(info$ID),]
colnames(fw_SNPinfo)[colnames(fw_SNPinfo)=="SSCID.x"]<-"SSCID"
saveRDS(fw_SNPinfo,"fw_SNPinfo.RDS")
```


We also compiled a list of genes previously implicated in adaptation to freshwater in previous studies. We identified a total of `r length(unique(put_genes$Gene))` candidate genes, all of which fall into the general categories of osmoregulation, temperature acclimation, and bone or other morphological development (Table \@ref(tab:putativeGenesTable)). Other studies have identified many of the same genes as putative targets of freshwater adaptation, in particular *aquaporin-3* (*AQP3*), *Na+/K+ transporting ATPase alpha 1* (*ATP1A*), *carbonic anhydrases* (*CA*), *ectodysplasin A* (*Eda*), *insulin-like growth factor-binding* (*IGFBP*) genes, and *Wnt* family member 7B (*WNT7B*). Not every gene was matched exactly in the *S. scovelli* genome (e.g., we could match all *aquaporin* genes, but not specifically *aquaporin-3*), and some matched multiple times (e.g., the candidate gene ID *apolipoprotein*, *APOL*, is a gene family and has many members throughout the genome), so we had a total of `r nrow(put_genes)` gene annotations for the `r length(unique(put_genes$Gene))` candidate genes. 

```{r putativeGeneAnns}
annInfo$salgene<-"not-putative"
annInfo$salgene[annInfo$ID %in% fw_SNPinfo$ID[!is.na(fw_SNPinfo$Gene)]]<-"putative"
kable(table(annInfo$outlier,annInfo$salgene),booktabs=TRUE,
      caption="The number of SNPs in the subsetted dataset that were outliers in putative salinity genes or not.") %>%
  kable_styling(latex_options="HOLD_position")
```
```{r fisherTestOutliersPutative,message=FALSE,warning=FALSE}
ft<-fisher.test(table(annInfo$outlier,annInfo$salgene))
```

We investigated whether the outlier SNPs from our above analyses were in these putative gene regions more frequently than expected (Table \@ref(tab:putativeGeneAnns)), but these putative salinity genes do not appear to be enriched with outliers in our dataset (Fisher's exact test, odds ratio $=$ `r ft$estimate`, $p=$ `r ft$p.value`).


```{r putativeGenesTable}
put_genes[,6]<-gsub(",",", ",put_genes[,6])
landscape(kable(put_genes[,c(1,2,4,5,6)],"latex",booktabs=TRUE,longtable=TRUE,
      caption = "Table of putative freshwater adaptation genes and their gene ID name in the Gulf pipefish genome.")) %>%
  kable_styling(latex_options="HOLD_position","repeat_header") %>%
  column_spec(1,width="10em") %>%
  column_spec(2,width="10em") %>%
  column_spec(3,width="10em") %>%
  column_spec(4,width="10em") %>%
  column_spec(5,width="10em")
```


# References {-}


