---
title: "FWSW lab Notebook"
author: "Sarah P. Flanagan"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_notebook
editor_options: 
  chunk_output_type: console
---

```{r setup}
knitr::opts_knit$set(root.dir='../fwsw_results/', fig.pos='H')
```

# 13 November 2019

Ok, so when plotting I found that 24 of 29 XtX outliers are PCAdapt outliers. But when making the Upset plot yesterday this wasn't true. So what gives?

Well, somehow it looks like I'd lost the Fsts and p-values from Stacks. Grabbing the outlier analysis from 21 Oct, we can try this again

```{r}
fw_SNPinfo<-readRDS("fw_SNPinfo.RDS")
shared_stacks<-fw_SNPinfo$ID[fw_SNPinfo$stacks_AL_P < 0.05 & fw_SNPinfo$stacks_LA_P < 0.05 &
                          fw_SNPinfo$stacks_TX_P < 0.05 & fw_SNPinfo$stacks_FL_P < 0.05]
shared_stacks<-shared_stacks[!is.na(shared_stacks)]
fw_SNPinfo[fw_SNPinfo$ID %in% shared_stacks,]
```

Number of shared permutation outliers:
```{r}
length(which(rowSums(fw_SNPinfo[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4))
length(unique(fw_SNPinfo$Chrom[which(rowSums(fw_SNPinfo[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4)]))
```

Are any of those the same as the Stacks ones?

```{r}
permout<-fw_SNPinfo$ID[which(rowSums(fw_SNPinfo[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4)]
permout[permout %in% shared_stacks]
```

Pcapadt: 
```{r}
dim(fw_SNPinfo[fw_SNPinfo$pcadaptQ<0.01 & !is.na(fw_SNPinfo$pcadaptQ),])
pcout<-fw_SNPinfo$ID[fw_SNPinfo$pcadaptQ<0.01 & !is.na(fw_SNPinfo$pcadaptQ)]
pcout[pcout %in% shared_stacks] # overlapping with shared stacks
pcout[pcout %in% permout] # overlapping with permutations
```

Bayenv:

```{r}
xtxout<-fw_SNPinfo$ID[fw_SNPinfo$XtX>=quantile(fw_SNPinfo$XtX,0.99)]
xtxout[xtxout %in% pcout]
```

```{r}
salout<-fw_SNPinfo$ID[fw_SNPinfo$logSalBF>=quantile(fw_SNPinfo$logSalBF,0.99)]
salout[salout %in% xtxout]
salout[salout %in% pcout]
salout[salout %in% shared_stacks]
salout[salout %in% permout]
```

Ok, I'm still only getting one shared outlier between Pcadapt and Bayenv's Xtx. Really not sure what's different. Since then all I've done is filter some datasets and re-run populations, so it shouldn't have affected anything. How strange! The only other difference might be that I was using my laptop, possibly? None of those figures appear to be saved on my desktop at work, so I must have been doing that at home. So possibly I had different data on my laptop. It seems that the problem was that I lost a bunch of rows at some point when making fw_SNPinfo on here. If I use the data on my laptop, I get the same thing, and I still have 12103 rows of data. So yay!

Ok, so now upset plots with this lovely new information.

```{r}
library(UpSetR)
fw_SNPinfo<-readRDS("fw_SNPinfo.RDS")
outliers<-list(xtx=fw_SNPinfo$ID[fw_SNPinfo$XtX >= quantile(fw_SNPinfo$XtX,0.99)],
               salBF=fw_SNPinfo$ID[fw_SNPinfo$logSalBF>=quantile(fw_SNPinfo$logSalBF,0.99)],
               permutations=fw_SNPinfo$ID[rowSums(fw_SNPinfo[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
               pcadapt=fw_SNPinfo$ID[which(fw_SNPinfo$pcadaptQ<0.01)],
               stacksAL=fw_SNPinfo$ID[which(fw_SNPinfo$stacks_AL < 0.05)], 
               stacksLA=fw_SNPinfo$ID[which(fw_SNPinfo$stacks_LA < 0.05)],
               stacksTX=fw_SNPinfo$ID[which(fw_SNPinfo$stacks_TX < 0.05)],
               stacksFL=fw_SNPinfo$ID[which(fw_SNPinfo$stacks_FL < 0.05)],
               sharedStacks=fw_SNPinfo$ID[which(fw_SNPinfo$stacks_AL < 0.05 & fw_SNPinfo$stacks_LA < 0.05 &
                 fw_SNPinfo$stacks_TX < 0.05 & fw_SNPinfo$stacks_FL < 0.05)])

uss<-upset(fromList(outliers),sets=c("stacksAL","stacksLA","stacksTX","stacksFL"))

```
```{r}
usa<-upset(fromList(outliers),sets=c("xtx","salBF","permutations","pcadapt","sharedStacks"))
```

I think I'm going to want to trick them out with color, better labels, etc., and probably put them in a single multi-panel thing. From the issues section of the github page (https://github.com/hms-dbmi/UpSetR/issues/63), I found this potential solution:

```{r}
library(scales)

cols<-c(permutations='#e41a1c',salBF='#377eb8',pcadapt='#4daf4a',
        xtx='#984ea3',sharedStacks='#ff7f00',
        stacksTX='#762a83',stacksAL='#af8dc3',stacksLA='#e7d4e8',stacksFL='#7fbf7b')
metadata<-data.frame(set=names(outliers),
                     cols=c(cols[c("xtx","sal","perm","pc","stacks")],grp.colors[c(1,2,3,6)]))
upset(fromList(outliers),sets=c("xtx","salBF","permutations","pcadapt","sharedStacks"),
      point.size=3.5,line.size=2,mainbar.y.label = "Number of Shared Outliers",
      sets.x.label = "Number of Outlier SNPs",text.scale=c(1.5,1.5,1.5,1.5,1.5,1.5),
      sets.bar.color =cols[1:5])
    
grid::grid.edit('arrange',name='arrange2')
vp = grid::grid.grab()
upset(fromList(outliers),sets=c("stacksAL","stacksLA","stacksTX","stacksFL"),
      point.size=3.5,line.size=2,mainbar.y.label = "Number of Shared Outliers",
      sets.x.label = "Number of Outlier SNPs",text.scale=c(1.5,1.5,1.5,1.5,1.5,1.5))
grid::grid.edit('arrange',name='arrange3')
vp1 = grid::grid.grab()
gridExtra::grid.arrange(vp,vp1)
```

This works, as long as the fig size is large enough! So now just need to trick it out with colors. I've tried adding
```
set.metadata = list(data = metadata, 
                          plots = list(list(type = "matrix_rows",column = "set",colors=c(permutations='#e41a1c',salBF='#377eb8',pcadapt='#4daf4a',
        xtx='#984ea3',sharedStacks='#ff7f00'))))
```     

but it doesn't help much. So now I'm going to try to use the information in thisblog post: https://www.r-bloggers.com/hacking-our-way-through-upsetr/ 

```{r}
require(ggplot2); require(plyr); require(gridExtra); require(grid); require(UpSetR)
source("../R/upset_hacked.R")
movies <- read.csv( system.file("extdata", "movies.csv", package = "UpSetR"), 
                    header=T, sep=";" )
upset(data = movies, sets = c("Action", "Comedy", "Drama"), 
      order.by="degree", matrix.color="blue", point.size=5,
      sets.bar.color=c("maroon","blue","orange"))

```

I used the code from the blog and updated/modified it a bit. It's saved in `upset_hacked.R`. I'm 90% confident I need to modify it further to make the colors more versatile (I think right now it's stuck at 3 different choices).



# 12 November 2019

The supplement is turning into a more streamlined version of 202_fwsw_reanalysis.Rmd, which is OK - and I'll compile it to hide the code and it will look lovely. Plus I can add citations and more text in the supplement doc. I also started a separate supplement doc for the morphometrics analyses. 

Now I'm wondering if for the shared outliers an UpSet plot would be better than what I've currently got. This will take some playing around with. I'd also like to annotate the outliers (like I did before). Then I think all that I'll have left is the demographic analysis. So, to summarize:

* make UpSet plot 
* Annotate outliers
* Analyze dadi output

For the upset plot, it needs a list of sets or a binary matrix. I can easily get a list of sets from fw_SNPinfo (I think)
```{r}
library(UpSetR)
fw_SNPinfo<-readRDS("fw_SNPinfo.RDS")
outliers<-list(xtx=fw_SNPinfo$ID[fw_SNPinfo$XtX >= quantile(fw_SNPinfo$XtX,0.99)],
               salBF=fw_SNPinfo$ID[fw_SNPinfo$logSalBF>=quantile(fw_SNPinfo$logSalBF,0.99)],
               permutations=fw_SNPinfo$ID[rowSums(fw_SNPinfo[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
               pcadapt=fw_SNPinfo$ID[which(fw_SNPinfo$pcadaptQ<0.01)],
               stacksAL=fw_SNPinfo$ID[which(fw_SNPinfo$stacks_AL < 0.05)], 
               stacksLA=fw_SNPinfo$ID[which(fw_SNPinfo$stacks_LA < 0.05)],
               stacksTX=fw_SNPinfo$ID[which(fw_SNPinfo$stacks_TX < 0.05)],
               stacksFL=fw_SNPinfo$ID[which(fw_SNPinfo$stacks_FL < 0.05)])
```

Here's the overall plot

```{r}
upset(fromList(outliers),nsets = length(outliers))
```

But I wonder if I should do two -- one with just stacks output and one with all stacks lumped vs the others

```{r}
stacks_outliers<-list(stacksAL=fw_SNPinfo$ID[which(fw_SNPinfo$stacks_AL < 0.05)], 
               stacksLA=fw_SNPinfo$ID[which(fw_SNPinfo$stacks_LA < 0.05)],
               stacksTX=fw_SNPinfo$ID[which(fw_SNPinfo$stacks_TX < 0.05)],
               stacksFL=fw_SNPinfo$ID[which(fw_SNPinfo$stacks_FL < 0.05)])


lumped_outliers<-list(xtx=fw_SNPinfo$ID[which(fw_SNPinfo$XtX >= quantile(fw_SNPinfo$XtX,0.99))],
               salBF=fw_SNPinfo$ID[which(fw_SNPinfo$logSalBF>=quantile(fw_SNPinfo$logSalBF,0.99))],
               permutations=fw_SNPinfo$ID[rowSums(fw_SNPinfo[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
               pcadapt=fw_SNPinfo$ID[which(fw_SNPinfo$pcadaptQ<0.01)],
               stacks=fw_SNPinfo$ID[which(fw_SNPinfo$stacks_AL < 0.05 & fw_SNPinfo$stacks_LA < 0.05 &
                 fw_SNPinfo$stacks_TX < 0.05 & fw_SNPinfo$stacks_FL < 0.05)])


upset(fromList(stacks_outliers),nsets = length(stacks_outliers))
upset(fromList(lumped_outliers),nsets = length(lumped_outliers))
```

What's weird is that this doesn't really match what I wrote in the results which is that 24 of 29 XtX outliers are PCAdapt outliers. 

```{r}
fw_SNPinfo[which(fw_SNPinfo$pcadaptQ<0.01) %in% which(fw_SNPinfo$XtX>=quantile(fw_SNPinfo$XtX,0.99)),]
```

There's something wonky with the which -es

# 11 November 2019

Now that I've got data for the subsetted dataset for all populations, I can make the summary table. So that's what I'm doing. But first I merged the 12103 locus, 7 population dataset with the smaller dataset for all 16 pops with the whitelisted loci. Now I can run the code I'd previously written to estimate observed heterozygosity, allele frequencies, and polymorphic loci. Easy peasy. There are some slightly unnerving differences between the full and subsetted dataset for the populations not in the subsetted analysis, which is kind of weird. I just realized this table should probably include environmental variables.

The other thing I'd like to do is create a supplementary document showing additional figures and data. I can do this in Rmarkdown using a template package. It looks like rticles has a bunch of choices, and I also know that rmdTemplates (https://github.com/Pakillo/rmdTemplates) works really well. The supplement will include lots of stuff from 202_fwsw_reanalysis.Rmd and also from this document, probably. I've started the document and have put together the backbone for it. 

 
# 7 Nov 2019

That seems to have worked better. 

# 6 Nov 2019

My computer restarted overnight, great. Re-started populations.
At work, I'm checking out the progress of my dadi runs.
`for dir in fwsw_results/dadi_results/FLLG*/; do ls $dir | wc -l; done` 
works in bash and all I have to do is divide by 2. I get 
35
23
37
33
29
25
for FLLG_ALFW, FLLG_ALST, FLLG_FLCC, FLLG_LAFW, FLLG_TXCC, and FLLG_TXFW respectively - so FLLG vs ALFW and vs FLCC are moving along at a pretty good pace. The slow ones are ALST and TXFW. Still have a ways to go, though, considering there are 26 models to run...

Ok, populations finished running and seems to have completed successfully! Though not all of the loci were retained...
It looks like there were incompatible loci (with more than 2 alleles present)

So my original reason to do this was to get data for the 'null' population comparisons, I think. So I realize easiest thing would be to have it run on all 16 populations...maybe I can get this to work? Let me "archive" this successful run by re-naming it sw_pops_subset75 within populations_subset75 and I've created an empty folder all_pops_subset75. Now I just need to modify the script with the directory name and the correct maps file, and I'll give it another try (not changing any of the other parameters).

Now I'm running it with `../scripts/208_run_populations_subset.sh 2>&1 | tee logs/208_run_populations_whitelist_all.log`


# 5 Nov 2019

Ok, let's try this again
```{r}
sub1_map<-read.table("stacks/populations_subset75/all_pops1/batch_2.plink.map",header=FALSE)
sub2_map<-read.table("stacks/populations_subset75/all_pops2/batch_2.plink.map",header=FALSE)
keep_map<-read.table("stacks/populations_subset75/batch_2.pruned.map",header = FALSE)
```

No wonder stacks is freaking out, it's got a very large number of loci - why isn't it just keeping the whitelist?

```{r}
dim(sub1_map[sub1_map$V2 %in% keep_map$V2,])
dim(sub2_map[sub2_map$V2 %in% keep_map$V2,])
```

But all the loci in the whitelist are not in the subset maps!

Maybe my whitelist isn't formatted well?

```{r}
dim(sub1_map[gsub("(\\d+)_\\d+","\\1",sub1_map$V2) %in% gsub("(\\d+)_\\d+","\\1",keep_map$V2),])
```

That keeps a lot more loci - 82210. Maybe the Position value I used wasn't right - how did I make the whitelist? 

I used the map positions, but maybe that's not right. According to the Stacks manual:

```
The column is a zero-based coordinate of the SNP location, so the first nucleotide at a locus is labeled as column zero, the second position as column one. These coordinates correspond with the column reported in the populations.sumstats.tsv file as well as in several other output files from populations. 
```

And it looks like I used the wrong values to generate the whitelist - I used the V4 column, which is the BP not the column position.

```{r}
wl<-data.frame(loc=gsub("(\\d+)_\\d+","\\1",keep_map$V2),column=gsub("(\\d+)_(\\d+)","\\2",keep_map$V2))
write.table(wl,"stacks/populations_subset75/pruned_snps.txt",
            sep = '\t',row.names = FALSE,col.names = FALSE,quote=FALSE)
```

So now I've just got to try this again, and turn off all the populations filters. I've changed the code and now just have to run it at home.


# 1 Nov 2019

Populations didn't run properly, but it does seem to have saved plink output -- it seemed to die at the vcf-creation moment. So I'll see what the plink data look like.

```{r}
sub1_map<-read.table("stacks/populations_subset75/all_pops1/batch_2.plink.map",header=FALSE)
sub2_map<-read.table("stacks/populations_subset75/all_pops2/batch_2.plink.map",header=FALSE)
```


# 31 October 2019

Populations isn't running, and I think it's because I'm running out of memory. So! I will run it not on all 16 populations with the whitelisted SNPs, but on the ones that aren't in the subset.

```{r}
popmap<-read.delim("../fwsw_pops_map.txt",header = FALSE)
submap<-read.delim("../fwsw_sub_map.txt",header = FALSE)
altmap<-popmap[!(popmap$V1 %in% submap$V1),]
write.table(altmap,"../fwsw_alt_map.txt",col.names = FALSE,row.names=FALSE,quote=FALSE,sep='\t')
```

Now I'm running populations with the whitelist - we'll see if it helps.

It still gets stuck - let's split it into two.

```{r}
write.table(altmap[altmap$V2 %in% unique(altmap$V2)[1:4],],"../fwsw_alt1_map.txt",
            col.names = FALSE,row.names=FALSE,quote=FALSE,sep='\t')
write.table(altmap[altmap$V2 %in% unique(altmap$V2)[5:length(unique(altmap$V2))],],
            "../fwsw_alt2_map.txt",
            col.names = FALSE,row.names=FALSE,quote=FALSE,sep='\t')
```


# 29 October 2019

For whatever reason populations doesn't want to run with the whitelist. I might be able to achieve the same goal just by using the vcfs

```{r}
all_vcf<-parse.vcf("stacks/populations_all/batch_2.vcf")
sub_vcf<-parse.vcf("stacks/populations_subset75/batch_2.pruned.vcf")
sub_all_vcf<-all_vcf[which(paste(all_vcf$ID,all_vcf$POS,sep="_") %in% paste(sub_vcf$ID,sub_vcf$POS,sep="_") ),]
```

Weirdly, this only results in 9549 loci. Huh, also, the populations_all has fewer unique IDs than the subset 75. So I might not be able to do this -- I may have to rely on populations on my home computer after all.

As for the dadi analyses, the FLLG comparisons are still running (which are the first set). Unfortunately the log files are not being written because they're being passed to python as another argument...so that's not helpful. I'll probably need to change it to be `| tee x-y.log`. But here's the ones that have run so far:

```
FLLG_ALFW:
FLLG_ALFW_1.AM.log.txt        FLLG_ALFW_1.IM.log.txt        FLLG_ALFW_1.SC.log.txt        FLLG_ALFW_1.SI2N.log.txt        FLLG_ALFW_1.SIG.log.txt        FLLG_ALFW_1.SI.log.txt        SIG.log.txt
FLLG_ALFW_1.AM.optimized.txt  FLLG_ALFW_1.IM.optimized.txt  FLLG_ALFW_1.SC.optimized.txt  FLLG_ALFW_1.SI2N.optimized.txt  FLLG_ALFW_1.SIG.optimized.txt  FLLG_ALFW_1.SI.optimized.txt

FLLG_ALST:
FLLG_ALST_1.AM.log.txt        FLLG_ALST_1.IM2N.optimized.txt  FLLG_ALST_1.IM.log.txt        FLLG_ALST_1.SC.optimized.txt     FLLG_ALST_1.SI2N.log.txt        FLLG_ALST_1.SIG.optimized.txt  IM2N.log.txt
FLLG_ALST_1.AM.optimized.txt  FLLG_ALST_1.IMG.log.txt         FLLG_ALST_1.IM.optimized.txt  FLLG_ALST_1.SI2NG.log.txt        FLLG_ALST_1.SI2N.optimized.txt  FLLG_ALST_1.SI.log.txt
FLLG_ALST_1.IM2N.log.txt      FLLG_ALST_1.IMG.optimized.txt   FLLG_ALST_1.SC.log.txt        FLLG_ALST_1.SI2NG.optimized.txt  FLLG_ALST_1.SIG.log.txt         FLLG_ALST_1.SI.optimized.txt

FLLG_FLCC:
FLLG_FLCC_1.AM.log.txt        FLLG_FLCC_1.IM2m.optimized.txt  FLLG_FLCC_1.IMG.log.txt        FLLG_FLCC_1.IM.optimized.txt  FLLG_FLCC_1.SI2NG.log.txt        FLLG_FLCC_1.SI2N.optimized.txt  FLLG_FLCC_1.SI.log.txt
FLLG_FLCC_1.AM.optimized.txt  FLLG_FLCC_1.IM2N.log.txt        FLLG_FLCC_1.IMG.optimized.txt  FLLG_FLCC_1.SC.log.txt        FLLG_FLCC_1.SI2NG.optimized.txt  FLLG_FLCC_1.SIG.log.txt         FLLG_FLCC_1.SI.optimized.txt
FLLG_FLCC_1.IM2m.log.txt      FLLG_FLCC_1.IM2N.optimized.txt  FLLG_FLCC_1.IM.log.txt         FLLG_FLCC_1.SC.optimized.txt  FLLG_FLCC_1.SI2N.log.txt         FLLG_FLCC_1.SIG.optimized.txt   IM2m.log.txt

FLLG_LAFW:
FLLG_LAFW_1.AM.log.txt        FLLG_LAFW_1.IM2N.optimized.txt  FLLG_LAFW_1.IM.log.txt        FLLG_LAFW_1.SC.optimized.txt     FLLG_LAFW_1.SI2N.log.txt        FLLG_LAFW_1.SIG.optimized.txt  IM2N.log.txt
FLLG_LAFW_1.AM.optimized.txt  FLLG_LAFW_1.IMG.log.txt         FLLG_LAFW_1.IM.optimized.txt  FLLG_LAFW_1.SI2NG.log.txt        FLLG_LAFW_1.SI2N.optimized.txt  FLLG_LAFW_1.SI.log.txt
FLLG_LAFW_1.IM2N.log.txt      FLLG_LAFW_1.IMG.optimized.txt   FLLG_LAFW_1.SC.log.txt        FLLG_LAFW_1.SI2NG.optimized.txt  FLLG_LAFW_1.SIG.log.txt         FLLG_LAFW_1.SI.optimized.txt

FLLG_TXCC:
FLLG_TXCC_1.AM.log.txt        FLLG_TXCC_1.IM2m.optimized.txt  FLLG_TXCC_1.IMG.log.txt        FLLG_TXCC_1.IM.optimized.txt  FLLG_TXCC_1.SI2NG.log.txt        FLLG_TXCC_1.SI2N.optimized.txt  FLLG_TXCC_1.SI.log.txt
FLLG_TXCC_1.AM.optimized.txt  FLLG_TXCC_1.IM2N.log.txt        FLLG_TXCC_1.IMG.optimized.txt  FLLG_TXCC_1.SC.log.txt        FLLG_TXCC_1.SI2NG.optimized.txt  FLLG_TXCC_1.SIG.log.txt         FLLG_TXCC_1.SI.optimized.txt
FLLG_TXCC_1.IM2m.log.txt      FLLG_TXCC_1.IM2N.optimized.txt  FLLG_TXCC_1.IM.log.txt         FLLG_TXCC_1.SC.optimized.txt  FLLG_TXCC_1.SI2N.log.txt         FLLG_TXCC_1.SIG.optimized.txt   IM2m.log.txt

FLLG_TXFW:
FLLG_TXFW_1.AM.log.txt        FLLG_TXFW_1.IM2N.optimized.txt  FLLG_TXFW_1.IM.log.txt        FLLG_TXFW_1.SC.optimized.txt     FLLG_TXFW_1.SI2N.log.txt        FLLG_TXFW_1.SIG.optimized.txt  IM2N.log.txt
FLLG_TXFW_1.AM.optimized.txt  FLLG_TXFW_1.IMG.log.txt         FLLG_TXFW_1.IM.optimized.txt  FLLG_TXFW_1.SI2NG.log.txt        FLLG_TXFW_1.SI2N.optimized.txt  FLLG_TXFW_1.SI.log.txt
FLLG_TXFW_1.IM2N.log.txt      FLLG_TXFW_1.IMG.optimized.txt   FLLG_TXFW_1.SC.log.txt        FLLG_TXFW_1.SI2NG.optimized.txt  FLLG_TXFW_1.SIG.log.txt         FLLG_TXFW_1.SI.optimized.txt
```

So it's pretty good progress - all of them have gotten through the homogeneous models. But it is rather slow...we'll see how this goes. I might need to re-evaluate how I'm running these (I should follow up with the HPC guy).



# 25 October 2019

I realized I don't think I updated the projections for the filtered dataset - let me try that again.

```{r}
pop.map<-read.delim("stacks/populations_subset75/filter_rad_20191022@1502/14_filtered/strata.filtered.tsv")
table(pop.map$STRATA)*2

```
Ok, that's not true, those are the projections I used. 

So I'm not sure what's going on with that or what to do next. But I can do a couple of things:

* Update the text of the ms
* Re-do outlier analysis with this filtered dataset
* Figure out how to automate the dadi runs a bit better.

Is it weird that I want to do the third one first? Even though I don't know what to make of the filtered data? Well, it's what I want to do so I'm going to do it - even if I run it on the 12103 SNPs I was originally using. 

In my notes it says I need to use MINIMUM projections - could that be the issue? I need to use the minimum number of individuals genotyped at a locus?

Ok, I've written a python script that takes arguments and runs all of the models on a population pair for a given number of rounds. 

Ok, but which population pairs do I want to use, and which dataset?? Also, shouldn't I also run 1D models? 

The dadi manual says:

```

When constructing the Spectrum each SNP will be projected down to the requested number of samples in each population. (Note that SNPs cannot be projected up, so SNPs without enough calls in any population will be ignored.)...

If your data have missing calls for some individuals, projecting down to a smaller sample
size will increase the number of SNPs you can use for analysis. On the other hand, some
fraction of the SNPs will now project down to frequency 0, and thus be uniformative. As a
rule of thumb, we often choose our projection to maximize the number of segregating sites
in our final fs (assessed via fs.S()), although we have not formally tested whether this
maximizes statistical power.

```
So this probably isn't causing the wonky spectra but it does suggest that the most appropriate dataset is the one with loci present in 100% of individuals in the populations analysed. I could check with the fs.S() command...

with ALFW-ALST, spect.S() resulted in 1371 for the filtered dataset, 536 for the second filtered dataset, and 
1359.86 for the 'full' dataset. The original dataset has 5478.9 (without changing the projections). So...maybe this is part of the issue. And maybe I should just use the original dadi dataset, even if it does have some missingness issues.

So I also need a wrapper script to run the python script. Done! And I started running it using GNU parallel, hopefully it works well. 

I've decided to stick with the 12103 dataset so I don't need to re-do other analyses.  What I should do is use the whitelist for the 12103 to extract SNPs for the other populations so I can do the pairwise Fst comparisons.

Ok, so I need a create a whitelist.

```{r}
map<-read.delim("stacks/populations_subset75/batch_2.pruned.map",header = FALSE)
wl<-data.frame(gsub("(\\d+)_\\d+","\\1",map$V2),map$V4)
write.table(wl,"stacks/populations_subset75/pruned_snps.txt",
            sep = '\t',row.names = FALSE,col.names = FALSE,quote=FALSE)
```



# 24 October 2019

The 1D spectra for the filtered datasets don't look very good - almost all of them dip below (or to?) 0, for counts > 10 or 20, which means that they're not well represented -- and this is different from the unfiltered dataset. I'm guessing this is because of the smaller overall sample size, but it could also be due to a relatively permissive MAC filter.

What if I use the full dataset instead?

```{r}
dadi_full<-vcf2dadiSNPs(vcf="filter_rad_20191014@1654/14_filtered/radiator_data_20191014@1710.vcf",
                        filename="dadi_filtered/fwsw_full.snps",
                        pop.map = "filter_rad_20191014@1654/14_filtered/strata.filtered.tsv")

```

Running the plots function on it results in just as bad/weird plots. Not sure what to do about that.

What if I use a more stringent MAC filter and missingness filter?

```{r}
setwd("stacks/populations_subset75/")
data<-radiator::filter_rad(data="batch_2.pruned_header.vcf",
                           strata="fwsw_sub_strata.txt",
                           output=c("genepop","vcf","plink","structure"))
setwd("../../")
```

It results in a lot fewer loci (4499) -- log at bottom

```{r}
dadi_filt2<-vcf2dadiSNPs(vcf="stacks/populations_subset75/filter_rad_20191024@0843/14_filtered/radiator_data_20191024@0846.vcf",
                         filename="dadi_filtered/fwsw_filter2.snps",
                         pop.map = "stacks/populations_subset75/filter_rad_20191024@0843/14_filtered/strata.filtered.tsv")
```

Nope, this did not help.

```
################################################################################
############################# radiator::filter_rad #############################
################################################################################
The function arguments names have changed: please read documentation

Execution date@time: 20191024@0843
Folder created: filter_rad_20191024@0843
Function call and arguments stored in: radiator_filter_rad_args_20191024@0843.tsv
File written: random.seed (779280)
Filters parameters file generated: filters_parameters_20191024@0843.tsv

Reading VCF
Data summary: 
    number of samples: 303
    number of markers: 12103
done! timing: 1 sec

Generating individual stats...
Generating markers stats...


Number of chromosome/contig/scaffold: 532
Number of locus: 12103
Number of markers: 12103
Number of populations: 7
Number of individuals: 303

Number of ind/pop:
ALFW = 48
ALST = 47
FLCC = 41
FLLG = 47
LAFW = 48
TXCC = 41
TXFW = 31

Number of duplicate id: 0
radiator Genomic Data Structure (GDS) file: radiator_20191024@0843.gds
################################################################################
########################### radiator::filter_monomorphic #######################
################################################################################
Execution date@time: 20191024@0844
Function call and arguments stored in: radiator_filter_monomorphic_args_20191024@0844.tsv
Filters parameters file: initiated
File written: blacklist.monomorphic.markers_20191024@0844.tsv
Synchronizing markers.meta
File written: whitelist.polymorphic.markers_20191024@0844.tsv
Filters parameters file: updated
################################### RESULTS ####################################

Filter monomorphic markers
Number of individuals / strata / chrom / locus / SNP:
    Before: 303 / 7 / 532 / 12103 / 12103
    Blacklisted: 0 / 0 / 1 / 9 / 9
    After: 303 / 7 / 531 / 12094 / 12094

Computation time, overall: 1 sec
######################## filter_monomorphic completed ##########################
################################################################################
######################## radiator::filter_common_markers #######################
################################################################################
Execution date@time: 20191024@0844
Function call and arguments stored in: radiator_filter_common_markers_args_20191024@0844.tsv
Filters parameters file: initiated
Scanning for common markers...
Generating UpSet plot to visualize markers in common
File written: whitelist.common.markers_20191024@0844.tsv
Filters parameters file: updated
################################### RESULTS ####################################

Filter common markers:
Number of individuals / strata / chrom / locus / SNP:
    Before: 303 / 7 / 531 / 12094 / 12094
    Blacklisted: 0 / 0 / 0 / 0 / 0
    After: 303 / 7 / 531 / 12094 / 12094

Computation time, overall: 2 sec
####################### filter_common_markers completed ########################
################################################################################
######################### radiator::filter_individuals #########################
################################################################################
Execution date@time: 20191024@0844
Function call and arguments stored in: radiator_filter_individuals_args_20191024@0844.tsv
Interactive mode: on

Step 1. Visualization
Step 2. Missingness
Step 3. Heterozygosity
Step 4. Total Coverage (if available)


Filters parameters file: initiated

Step 1. Visualization of samples QC

File written: individuals qc info and stats summary
File written: individuals qc plot

Step 2. Filtering markers based individual missingness/genotyping

Do you want to blacklist samples based on missingness ? (y/n):
y
2 options to blacklist samples:
1. based on the outlier statistics
2. enter your own threshold
1

Removing outliers individuals based on genotyping statistics: 0.213308
Filters parameters file: updated
################################### RESULTS ####################################

Filter individuals based on missingness: 0.213308
Number of individuals / strata / chrom / locus / SNP:
    Before: 303 / 7 / 531 / 12094 / 12094
    Blacklisted: 49 / 0 / 0 / 0 / 0
    After: 254 / 7 / 531 / 12094 / 12094

Step 3. Filtering markers based on individual heterozygosity

Do you want to blacklist samples based on heterozygosity ? (y/n):
y
2 options to blacklist samples:
1. based on the outlier statistics
2. enter your own threshold
1

Removing outliers individuals based on heterozygosity statistics: 0.010165 / 0.04393725
    number of individuals blacklisted based on heterozygosity: 10
Filters parameters file: updated
################################### RESULTS ####################################

Filter individuals based on heterozygosity: 0.010165 0.04393725
Number of individuals / strata / chrom / locus / SNP:
    Before: 254 / 7 / 531 / 12094 / 12094
    Blacklisted: 0 / 0 / 0 / 0 / 0
    After: 254 / 7 / 531 / 12094 / 12094

Filter monomorphic markers
Number of individuals / strata / chrom / locus / SNP:
    Blacklisted: 0 / 0 / 16 / 426 / 426

Computation time, overall: 35 sec
########################### completed filter_individuals #######################
################################################################################
############################## radiator::filter_mac ############################
################################################################################
Execution date@time: 20191024@0844
Function call and arguments stored in: radiator_filter_mac_args_20191024@0844.tsv
Interactive mode: on

Step 1. Visualization and helper table
Step 2. Filtering markers based on MAC


Importing data ...
Filters parameters file: initiated
Calculating GLOBAL MAC
File written: maf.global.tsv

Step 1. MAC visualization and helper table

File written: mac.summary.stats.tsv
MAC range: [1 - 251]
MAF range: [0.002 - 0.4941]
Generating MAC helper table...
File written: maf.helper.table.tsv

Step 2. Filtering markers based on MAC

Choose the filter.mac threshold: 
2
File written: whitelist.markers.mac.tsv
File written: blacklist.markers.mac.tsv
Filters parameters file: updated
################################### RESULTS ####################################

Filter mac threshold: 2
Number of individuals / strata / chrom / locus / SNP:
    Before: 254 / 7 / 515 / 11668 / 11668
    Blacklisted: 0 / 0 / 163 / 6466 / 6466
    After: 254 / 7 / 352 / 5202 / 5202

Computation time, overall: 22 sec
############################ completed filter_mac ##############################
################################################################################
########################### radiator::filter_coverage ##########################
################################################################################
Execution date@time: 20191024@0845
Function call and arguments stored in: radiator_filter_coverage_args_20191024@0845.tsv
Interactive mode: on

Step 1. Visualization and helper table
Step 2. Filtering markers based on total coverage


Importing data ...
Filters parameters file: initiated

Step 1. Coverage visualization and helper table

Generating coverage statistics
Generating coverage statistics: without outliers
Generating mean coverage helper table...
Files written: helper tables and plots

Step 2. Filtering markers based on mean coverage

Choose the min mean coverage threshold(e.g. 7 or 10): 
11
Choose the max mean coverage threshold (e.g. 100 or 300): 
50
File written: blacklist.markers.coverage_20191024@0845.tsv
File written: whitelist.markers.coverage_20191024@0845.tsv
Filters parameters file: updated
################################### RESULTS ####################################

Filter mean coverage thresholds: 11 / 50
Number of individuals / strata / chrom / locus / SNP:
    Before: 254 / 7 / 352 / 5202 / 5202
    Blacklisted: 0 / 0 / 31 / 175 / 175
    After: 254 / 7 / 321 / 5027 / 5027

Computation time, overall: 17 sec
########################## completed filter_coverage ###########################
################################################################################
######################### radiator::filter_genotyping ##########################
################################################################################
Execution date@time: 20191024@0845
Function call and arguments stored in: radiator_filter_genotyping_args_20191024@0845.tsv
Interactive mode: on

Step 1. Visualization and helper table
Step 2. Filtering markers based on maximum missing proportion allowed


Importing data ...
Filters parameters file: initiated

Step 1. Missing visualization and helper table

Generating statistics
Generating missingness/genotyping helper table...
File written: markers.pop.missing.helper.table.tsv
Files written: helper tables and plots

Step 2. Filtering markers based on maximum missing proportion

Choose the maximum missing proportion allowed: 
0.1

Removing markers based on genotyping statistic: 0.1
File written: blacklist.markers.genotyping_20191024@0845.tsv
File written: whitelist.markers.genotyping_20191024@0845.tsv
Filters parameters file: updated
################################### RESULTS ####################################

Filter genotyping threshold: 0.1
Number of individuals / strata / chrom / locus / SNP:
    Before: 254 / 7 / 321 / 5027 / 5027
    Blacklisted: 0 / 0 / 0 / 1 / 1
    After: 254 / 7 / 321 / 5026 / 5026

Computation time, overall: 28 sec
######################## completed filter_genotyping ###########################
################################################################################
######################### radiator::filter_snp_position_read ###################
################################################################################
Execution date@time: 20191024@0845
Function call and arguments stored in: radiator_filter_snp_position_read_args_20191024@0845.tsv
2 steps to visualize and filter the data based on the number of SNP on the read/locus:
Step 1. Visualization (boxplot, distribution
Step 2. Threshold selection
Filters parameters file: initiated
COL info required, returning data

Computation time, overall: 0 sec
##################### completed filter_snp_position_read #######################
################################################################################
############################ radiator::filter_snp_number #######################
################################################################################
Execution date@time: 20191024@0845
Function call and arguments stored in: radiator_filter_snp_number_args_20191024@0845.tsv
Interactive mode: on
2 steps to visualize and filter the data based on the number of SNP on the read/locus:
Step 1. Impact of SNP number per read/locus (on individual genotypes and locus/snp number potentially filtered)
Step 2. Choose the filtering thresholds
Filters parameters file: initiated
Generating statistics
Generating helper table...
geom_path: Each group consists of only one observation. Do you need
to adjust the group aesthetic?
geom_path: Each group consists of only one observation. Do you need
to adjust the group aesthetic?
geom_path: Each group consists of only one observation. Do you need
to adjust the group aesthetic?
geom_path: Each group consists of only one observation. Do you need
to adjust the group aesthetic?
Files written: helper tables and plots

Step 2. Filtering markers based on the maximum of SNPs per locus

Do you still want to blacklist markers? (y/n):
n
File written: whitelist.markers.genotyping.tsv
File written: blacklist.markers.genotyping.tsv
Filters parameters file: updated
################################### RESULTS ####################################

Filter SNPs per locus threshold: 1e+12
Number of individuals / strata / chrom / locus / SNP:
    Before: 254 / 7 / 321 / 5026 / 5026
    Blacklisted: 0 / 0 / 0 / 0 / 0
    After: 254 / 7 / 321 / 5026 / 5026

Computation time, overall: 4 sec
######################### completed filter_snp_number ##########################
################################################################################
############################## radiator::filter_ld #############################
################################################################################
Execution date@time: 20191024@0846
Function call and arguments stored in: radiator_filter_ld_args_20191024@0846.tsv

Interactive mode: on

Step 1. Short distance LD threshold selection
Step 2. Filtering markers based on short distance LD
Step 3. Long distance LD pruning selection
Step 4. Threshold selection
Step 5. Filtering markers based on long distance LD


Filters parameters file: initiated
Minimizing short distance LD...

There is no variation in the number of SNP/locus across the data

Filters parameters file: updated
################################### RESULTS ####################################

Number of individuals / strata / chrom / locus / SNP:
    Before: 254 / 7 / 321 / 5026 / 5026
    Blacklisted: 0 / 0 / 0 / 0 / 0
    After: 254 / 7 / 321 / 5026 / 5026

Do you want to continue filtering using long distance ld  ? (y/n):
n

Computation time, overall: 1 sec
############################# completed filter_ld ##############################
################################################################################
######################## radiator::detect_mixed_genomes ########################
################################################################################
Execution date@time: 20191024@0846

detect_mixed_genomes function call arguments:
    data = SeqVarGDSClass
    interactive.filter = TRUE
    detect.mixed.genomes = FALSE
    ind.heterozygosity.threshold = NULL
    verbose = TRUE
    parallel.core = 11

dots-dots-dots ... arguments

Arguments inside "..." assigned in detect_mixed_genomes:
    internal = FALSE
    parameters = list
    path.folder = filter_rad_20191024@0843


File written: radiator_detect_mixed_genomes_args_20191024@0846.tsv
Filters parameters file: initiated
Calculating heterozygosity statistics
Generating plots

The greatest value of a picture is when it forces us
to notice what we never expected to see.

John W. Tukey. Exploratory Data Analysis. 1977.


Inspect plots and tables in folder created...
    Do you want to exclude individuals based on heterozygosity ? (y/n): 
n
Filters parameters file: updated
################################### RESULTS ####################################
Detect mixed genomes: 0 1
Number of individuals / strata / chrom / locus / SNP:
    Before: 254 / 7 / 321 / 5026 / 5026
    Blacklisted: 0 / 0 / 0 / 0 / 0
    After: 254 / 7 / 321 / 5026 / 5026

Computation time, overall: 12 sec
######################## completed detect_mixed_genomes ########################

################################################################################
###################### radiator::detect_duplicate_genomes ######################
################################################################################
Execution date@time: 20191024@0846
Function call and arguments stored in a file
File written: radiator_detect_duplicate_genomes_args_20191024@0846.tsv
File written: random.seed (779280)
Filters parameters file: initiated
Calculating manhattan distances between individuals...
Generating summary statistics
Generating plots

Inspect tables and figures to decide if some individual(s) need to be blacklisted
    Do you need to blacklist individual(s) (y/n): 
n
Filters parameters file: updated
################################### RESULTS ####################################
Detect duplicate genomes: 0
Number of individuals / strata / chrom / locus / SNP:
    Before: 254 / 7 / 321 / 5026 / 5026
    Blacklisted: 0 / 0 / 0 / 0 / 0
    After: 254 / 7 / 321 / 5026 / 5026

Computation time, overall: 9 sec
###################### completed detect_duplicate_genomes ######################
################################################################################
############################# radiator::filter_hwe #############################
################################################################################
Execution date@time: 20191024@0846
Interactive mode: on
Function call and arguments stored in: radiator_filter_hwe_args_20191024@0846.tsv
Filters parameters file: initiated
    using tidy data frame of genotypes as input
    skipping all filters
Summarizing data
File written: genotypes.summary.tsv
HWE analysis for pop: ALFW
  |=============================================| 100%, Elapsed 00:01
HWE analysis for pop: ALST
  |=============================================| 100%, Elapsed 00:01
HWE analysis for pop: FLCC
  |=============================================| 100%, Elapsed 00:01
HWE analysis for pop: FLLG
  |=============================================| 100%, Elapsed 00:01
HWE analysis for pop: LAFW
  |=============================================| 100%, Elapsed 00:01
HWE analysis for pop: TXCC
  |=============================================| 100%, Elapsed 00:01
HWE analysis for pop: TXFW
  |=============================================| 100%, Elapsed 00:01
HWE analysis for pop: OVERALL
  |=============================================| 100%, Elapsed 00:01
File written: hw.pop.sum.tsv
Plot written: hwd.plot.blacklist.markers.pdf
Plot written: hwe.ternary.plots.missing.data.pdf
Plot written: hwe.manhattan.plot.pdf

Do you want to continue with the filtering ? (y/n):
y

Based on figures and tables enter the hw.pop.threshold (integer): 
1

Generating blacklists, whitelists and filtered tidy data...
done!

Choosing the final filtered dataset
   select the mid p-value threshold (5 options):
1: 0.05 *
2. 0.01 **
3. 0.001 ***
4. 0.0001 ****
5. 0.00001 *****
1

Final filtered tidy dataset: 
tidy.filtered.hwe.0.05.mid.p.value.1.hw.pop.threshold.rad

Using hw.pop.threshold/midp.threshold: 1/0.05
Filters parameters file: updated
################################### RESULTS ####################################
Filter HWE: 1 / 0.05
Number of individuals / strata / chrom / locus / SNP:
    Before: 254 / 7 / 321 / 5026 / 5026
    Blacklisted: 0 / 0 / 19 / 527 / 527
    After: 254 / 7 / 302 / 4499 / 4499

Computation time, overall: 21 sec
############################# completed filter_hwe #############################

Preparing output files...
File written: whitelist.markers.tsv
File written: blacklist.markers.tsv
File written: blacklist.id.tsv
Writing the filtered strata: strata.filtered.tsvstrata.filtered.tsv

Generating statistics after filtering
calculating individual stats...
File written: individuals qc info and stats summary
File written: individuals qc plot
calculating markers stats...

Transferring data to genomic converter...
Synchronizing data and strata...
    Number of strata: 7
    Number of individuals: 254

Writing tidy data set:
radiator_data_20191024@0846.rad
Calibrating REF/ALT alleles...
    number of REF/ALT switch = 2
Data summary: 
    number of samples: 254
    number of markers: 4499

Computation time, overall: 193 sec
############################# completed filter_rad #############################

```

# 23 October 2019

cool, got the extension

Now I'm thinking that I need to re-do the dadi analysis with the better pruned dataset. Dammit. But I wonder if part of the issue comes from missingness in the dataset.

Choices:

1. plow ahead and pretend nothing is wrong.
2. re-analyze at least some of the datasets using the same models but the trimmed dataset
3. compare spectra for trimmed vs nontrimmed dataset
4. use trimmed data plus all of the models from Rougeux for all of the population pairs

I'm going to start with (3), which means that I need to convert the dataset into dadi format. And crap, I didn't save to vcf yesterday, so I've got to re-do all that other stuff - this is within the populations_subset75 directory.

```{r}
vcf_header<-grep("##",readLines("batch_2.vcf"),value=TRUE)
# fix a weird stacks thing
vcf_header[grep("AD",vcf_header)]<-gsub("(ID=AD,Number=)(\\d)","\\1\\.",grep("AD",vcf_header,value=TRUE))
vcf<-parse.vcf("batch_2.pruned.vcf")
write.table(vcf_header,"batch_2.pruned_header.vcf",quote = FALSE,col.names = FALSE,row.names = FALSE)
suppressWarnings(write.table(vcf,"batch_2.pruned_header.vcf",quote = FALSE,col.names = TRUE,row.names = FALSE,append = TRUE,sep='\t'))
```


```{r}
data<-radiator::filter_rad(data="batch_2.pruned_header.vcf",
                           strata="fwsw_sub_strata.txt",
                           output=c("genepop","vcf","plink","structure"))
```

I chose the same settings as below (also, log pasted here at end of today's entry).  

Ok, NOW I can convert to dadi format. Moving back to the fwsw_results, directory...

```{r}
pop.list<-c("TXSP","TXCC","TXFW","TXCB","LAFW","ALST","ALFW","FLSG","FLKB",
	"FLFD","FLSI","FLAB","FLPB","FLHB","FLCC","FLLG")
dir.create("dadi_filtered") # make a new directory for this!
vcf<-parse.vcf("stacks/populations_subset75/filter_rad_20191023@0847/14_filtered/radiator_data_20191023@0852.vcf")
dadi_filt<-vcf2dadiSNPs(vcf="stacks/populations_subset75/filter_rad_20191023@0847/14_filtered/radiator_data_20191023@0852.vcf",
                        filename="dadi_filtered/fwsw_sub75_filt",
                        pop.map = "stacks/populations_subset75/filter_rad_20191023@0847/14_filtered/strata.filtered.tsv")
```

I had to make some tweaks to the vcf2dadiSNPs function but I think I got it up and running with this dataset. Awesome. 

Ok, now I'll use interactive python to create SFS images.

I also need to know how many individuals are in each population

```{r}
pop.map<-read.delim("stacks/populations_subset75/filter_rad_20191023@0847/14_filtered/strata.filtered.tsv")
table(pop.map$STRATA)*2
```

Ok, so I've automated the plotting.  Now I'm wondering if I can write a loop to write scripts so I can automate the script generation and not need to copy and paste. A bash script might be right - and possibly I could use that to also run the analyses?

I'm thinking I'll pursue #4 above, although I'm not sure that the 2D SFS are any better now than before, they seem pretty sparse to be honest.


```
################################################################################
############################# radiator::filter_rad #############################
################################################################################
The function arguments names have changed: please read documentation

Execution date@time: 20191023@0847
Folder created: filter_rad_20191023@0847
Function call and arguments stored in: radiator_filter_rad_args_20191023@0847.tsv
File written: random.seed (911592)
Filters parameters file generated: filters_parameters_20191023@0847.tsv

Reading VCF
Data summary: 
    number of samples: 303
    number of markers: 12103
done! timing: 1 sec

Generating individual stats...
Generating markers stats...


Number of chromosome/contig/scaffold: 532
Number of locus: 12103
Number of markers: 12103
Number of populations: 7
Number of individuals: 303

Number of ind/pop:
ALFW = 48
ALST = 47
FLCC = 41
FLLG = 47
LAFW = 48
TXCC = 41
TXFW = 31

Number of duplicate id: 0
radiator Genomic Data Structure (GDS) file: radiator_20191023@0847.gds
################################################################################
########################### radiator::filter_monomorphic #######################
################################################################################
Execution date@time: 20191023@0847
Function call and arguments stored in: radiator_filter_monomorphic_args_20191023@0847.tsv
Filters parameters file: initiated
File written: blacklist.monomorphic.markers_20191023@0847.tsv
Synchronizing markers.meta
File written: whitelist.polymorphic.markers_20191023@0847.tsv
Filters parameters file: updated
################################### RESULTS ####################################

Filter monomorphic markers
Number of individuals / strata / chrom / locus / SNP:
    Before: 303 / 7 / 532 / 12103 / 12103
    Blacklisted: 0 / 0 / 1 / 9 / 9
    After: 303 / 7 / 531 / 12094 / 12094

Computation time, overall: 1 sec
######################## filter_monomorphic completed ##########################
################################################################################
######################## radiator::filter_common_markers #######################
################################################################################
Execution date@time: 20191023@0847
Function call and arguments stored in: radiator_filter_common_markers_args_20191023@0847.tsv
Filters parameters file: initiated
Scanning for common markers...
Generating UpSet plot to visualize markers in common
File written: whitelist.common.markers_20191023@0847.tsv
Filters parameters file: updated
################################### RESULTS ####################################

Filter common markers:
Number of individuals / strata / chrom / locus / SNP:
    Before: 303 / 7 / 531 / 12094 / 12094
    Blacklisted: 0 / 0 / 0 / 0 / 0
    After: 303 / 7 / 531 / 12094 / 12094

Computation time, overall: 1 sec
####################### filter_common_markers completed ########################
################################################################################
######################### radiator::filter_individuals #########################
################################################################################
Execution date@time: 20191023@0847
Function call and arguments stored in: radiator_filter_individuals_args_20191023@0847.tsv
Interactive mode: on

Step 1. Visualization
Step 2. Missingness
Step 3. Heterozygosity
Step 4. Total Coverage (if available)


Filters parameters file: initiated

Step 1. Visualization of samples QC

File written: individuals qc info and stats summary
File written: individuals qc plot

Step 2. Filtering markers based individual missingness/genotyping

Do you want to blacklist samples based on missingness ? (y/n):
y
2 options to blacklist samples:
1. based on the outlier statistics
2. enter your own threshold
1

Removing outliers individuals based on genotyping statistics: 0.213308
Filters parameters file: updated
################################### RESULTS ####################################

Filter individuals based on missingness: 0.213308
Number of individuals / strata / chrom / locus / SNP:
    Before: 303 / 7 / 531 / 12094 / 12094
    Blacklisted: 49 / 0 / 0 / 0 / 0
    After: 254 / 7 / 531 / 12094 / 12094

Step 3. Filtering markers based on individual heterozygosity

Do you want to blacklist samples based on heterozygosity ? (y/n):
y
2 options to blacklist samples:
1. based on the outlier statistics
2. enter your own threshold
1

Removing outliers individuals based on heterozygosity statistics: 0.010165 / 0.04393725
    number of individuals blacklisted based on heterozygosity: 10
Filters parameters file: updated
################################### RESULTS ####################################

Filter individuals based on heterozygosity: 0.010165 0.04393725
Number of individuals / strata / chrom / locus / SNP:
    Before: 254 / 7 / 531 / 12094 / 12094
    Blacklisted: 0 / 0 / 0 / 0 / 0
    After: 254 / 7 / 531 / 12094 / 12094

Filter monomorphic markers
Number of individuals / strata / chrom / locus / SNP:
    Blacklisted: 0 / 0 / 16 / 426 / 426

Computation time, overall: 48 sec
########################### completed filter_individuals #######################
################################################################################
############################## radiator::filter_mac ############################
################################################################################
Execution date@time: 20191023@0848
Function call and arguments stored in: radiator_filter_mac_args_20191023@0848.tsv
Interactive mode: on

Step 1. Visualization and helper table
Step 2. Filtering markers based on MAC


Importing data ...
Filters parameters file: initiated
Calculating GLOBAL MAC
File written: maf.global.tsv

Step 1. MAC visualization and helper table

File written: mac.summary.stats.tsv
MAC range: [1 - 251]
MAF range: [0.002 - 0.4941]
Generating MAC helper table...
File written: maf.helper.table.tsv

Step 2. Filtering markers based on MAC

Choose the filter.mac threshold: 
1
File written: whitelist.markers.mac.tsv
File written: blacklist.markers.mac.tsv
Filters parameters file: updated
################################### RESULTS ####################################

Filter mac threshold: 1
Number of individuals / strata / chrom / locus / SNP:
    Before: 254 / 7 / 515 / 11668 / 11668
    Blacklisted: 0 / 0 / 0 / 0 / 0
    After: 254 / 7 / 515 / 11668 / 11668

Computation time, overall: 22 sec
############################ completed filter_mac ##############################
################################################################################
########################### radiator::filter_coverage ##########################
################################################################################
Execution date@time: 20191023@0848
Function call and arguments stored in: radiator_filter_coverage_args_20191023@0848.tsv
Interactive mode: on

Step 1. Visualization and helper table
Step 2. Filtering markers based on total coverage


Importing data ...
Filters parameters file: initiated

Step 1. Coverage visualization and helper table

Generating coverage statistics
Generating coverage statistics: without outliers
Generating mean coverage helper table...
Files written: helper tables and plots

Step 2. Filtering markers based on mean coverage

Choose the min mean coverage threshold(e.g. 7 or 10): 
11
Choose the max mean coverage threshold (e.g. 100 or 300): 
50
File written: blacklist.markers.coverage_20191023@0848.tsv
File written: whitelist.markers.coverage_20191023@0848.tsv
Filters parameters file: updated
################################### RESULTS ####################################

Filter mean coverage thresholds: 11 / 50
Number of individuals / strata / chrom / locus / SNP:
    Before: 254 / 7 / 515 / 11668 / 11668
    Blacklisted: 0 / 0 / 23 / 256 / 256
    After: 254 / 7 / 492 / 11412 / 11412

Computation time, overall: 80 sec
########################## completed filter_coverage ###########################
################################################################################
######################### radiator::filter_genotyping ##########################
################################################################################
Execution date@time: 20191023@0850
Function call and arguments stored in: radiator_filter_genotyping_args_20191023@0850.tsv
Interactive mode: on

Step 1. Visualization and helper table
Step 2. Filtering markers based on maximum missing proportion allowed


Importing data ...
Filters parameters file: initiated

Step 1. Missing visualization and helper table

Generating statistics
Generating missingness/genotyping helper table...
File written: markers.pop.missing.helper.table.tsv
Files written: helper tables and plots

Step 2. Filtering markers based on maximum missing proportion

Choose the maximum missing proportion allowed: 
0.2

Removing markers based on genotyping statistic: 0.2
File written: blacklist.markers.genotyping_20191023@0850.tsv
File written: whitelist.markers.genotyping_20191023@0850.tsv
Filters parameters file: updated
################################### RESULTS ####################################

Filter genotyping threshold: 0.2
Number of individuals / strata / chrom / locus / SNP:
    Before: 254 / 7 / 492 / 11412 / 11412
    Blacklisted: 0 / 0 / 0 / 0 / 0
    After: 254 / 7 / 492 / 11412 / 11412

Computation time, overall: 11 sec
######################## completed filter_genotyping ###########################
################################################################################
######################### radiator::filter_snp_position_read ###################
################################################################################
Execution date@time: 20191023@0850
Function call and arguments stored in: radiator_filter_snp_position_read_args_20191023@0850.tsv
2 steps to visualize and filter the data based on the number of SNP on the read/locus:
Step 1. Visualization (boxplot, distribution
Step 2. Threshold selection
Filters parameters file: initiated
COL info required, returning data

Computation time, overall: 0 sec
##################### completed filter_snp_position_read #######################
################################################################################
############################ radiator::filter_snp_number #######################
################################################################################
Execution date@time: 20191023@0850
Function call and arguments stored in: radiator_filter_snp_number_args_20191023@0850.tsv
Interactive mode: on
2 steps to visualize and filter the data based on the number of SNP on the read/locus:
Step 1. Impact of SNP number per read/locus (on individual genotypes and locus/snp number potentially filtered)
Step 2. Choose the filtering thresholds
Filters parameters file: initiated
Generating statistics
Generating helper table...
geom_path: Each group consists of only one observation. Do you need
to adjust the group aesthetic?
geom_path: Each group consists of only one observation. Do you need
to adjust the group aesthetic?
geom_path: Each group consists of only one observation. Do you need
to adjust the group aesthetic?
geom_path: Each group consists of only one observation. Do you need
to adjust the group aesthetic?
Files written: helper tables and plots

Step 2. Filtering markers based on the maximum of SNPs per locus

Do you still want to blacklist markers? (y/n):
n
File written: whitelist.markers.genotyping.tsv
File written: blacklist.markers.genotyping.tsv
Filters parameters file: updated
################################### RESULTS ####################################

Filter SNPs per locus threshold: 1e+12
Number of individuals / strata / chrom / locus / SNP:
    Before: 254 / 7 / 492 / 11412 / 11412
    Blacklisted: 0 / 0 / 0 / 0 / 0
    After: 254 / 7 / 492 / 11412 / 11412

Computation time, overall: 6 sec
######################### completed filter_snp_number ##########################
################################################################################
############################## radiator::filter_ld #############################
################################################################################
Execution date@time: 20191023@0850
Function call and arguments stored in: radiator_filter_ld_args_20191023@0850.tsv

Interactive mode: on

Step 1. Short distance LD threshold selection
Step 2. Filtering markers based on short distance LD
Step 3. Long distance LD pruning selection
Step 4. Threshold selection
Step 5. Filtering markers based on long distance LD


Filters parameters file: initiated
Minimizing short distance LD...

There is no variation in the number of SNP/locus across the data

Filters parameters file: updated
################################### RESULTS ####################################

Number of individuals / strata / chrom / locus / SNP:
    Before: 254 / 7 / 492 / 11412 / 11412
    Blacklisted: 0 / 0 / 0 / 0 / 0
    After: 254 / 7 / 492 / 11412 / 11412

Do you want to continue filtering using long distance ld  ? (y/n):
n

Computation time, overall: 5 sec
############################# completed filter_ld ##############################
################################################################################
######################## radiator::detect_mixed_genomes ########################
################################################################################
Execution date@time: 20191023@0850

detect_mixed_genomes function call arguments:
    data = SeqVarGDSClass
    interactive.filter = TRUE
    detect.mixed.genomes = FALSE
    ind.heterozygosity.threshold = NULL
    verbose = TRUE
    parallel.core = 11

dots-dots-dots ... arguments

Arguments inside "..." assigned in detect_mixed_genomes:
    internal = FALSE
    parameters = list
    path.folder = filter_rad_20191023@0847


File written: radiator_detect_mixed_genomes_args_20191023@0850.tsv
Filters parameters file: initiated
Calculating heterozygosity statistics
Generating plots

The greatest value of a picture is when it forces us
to notice what we never expected to see.

John W. Tukey. Exploratory Data Analysis. 1977.


Inspect plots and tables in folder created...
    Do you want to exclude individuals based on heterozygosity ? (y/n): 
n
Filters parameters file: updated
################################### RESULTS ####################################
Detect mixed genomes: 0 1
Number of individuals / strata / chrom / locus / SNP:
    Before: 254 / 7 / 492 / 11412 / 11412
    Blacklisted: 0 / 0 / 0 / 0 / 0
    After: 254 / 7 / 492 / 11412 / 11412

Computation time, overall: 48 sec
######################## completed detect_mixed_genomes ########################

################################################################################
###################### radiator::detect_duplicate_genomes ######################
################################################################################
Execution date@time: 20191023@0851
Function call and arguments stored in a file
File written: radiator_detect_duplicate_genomes_args_20191023@0851.tsv
File written: random.seed (911592)
Filters parameters file: initiated
Calculating manhattan distances between individuals...
Generating summary statistics
Generating plots

Inspect tables and figures to decide if some individual(s) need to be blacklisted
    Do you need to blacklist individual(s) (y/n): 
n
Filters parameters file: updated
################################### RESULTS ####################################
Detect duplicate genomes: 0
Number of individuals / strata / chrom / locus / SNP:
    Before: 254 / 7 / 492 / 11412 / 11412
    Blacklisted: 0 / 0 / 0 / 0 / 0
    After: 254 / 7 / 492 / 11412 / 11412

Computation time, overall: 8 sec
###################### completed detect_duplicate_genomes ######################
Registered S3 methods overwritten by 'ggtern':
  method           from   
  +.gg             ggplot2
  grid.draw.ggplot ggplot2
  plot.ggplot      ggplot2
  print.ggplot     ggplot2
################################################################################
############################# radiator::filter_hwe #############################
################################################################################
Execution date@time: 20191023@0851
Interactive mode: on
Function call and arguments stored in: radiator_filter_hwe_args_20191023@0851.tsv
Filters parameters file: initiated
    using tidy data frame of genotypes as input
    skipping all filters
Summarizing data
File written: genotypes.summary.tsv
HWE analysis for pop: ALFW
  |=============================================| 100%, Elapsed 00:01
HWE analysis for pop: ALST
  |=============================================| 100%, Elapsed 00:01
HWE analysis for pop: FLCC
  |=============================================| 100%, Elapsed 00:01
HWE analysis for pop: FLLG
  |=============================================| 100%, Elapsed 00:01
HWE analysis for pop: LAFW
  |=============================================| 100%, Elapsed 00:01
HWE analysis for pop: TXCC
  |=============================================| 100%, Elapsed 00:01
HWE analysis for pop: TXFW
  |=============================================| 100%, Elapsed 00:01
HWE analysis for pop: OVERALL
  |=============================================| 100%, Elapsed 00:01
File written: hw.pop.sum.tsv
Plot written: hwd.plot.blacklist.markers.pdf
Plot written: hwe.ternary.plots.missing.data.pdf
Plot written: hwe.manhattan.plot.pdf

Do you want to continue with the filtering ? (y/n):
y

Based on figures and tables enter the hw.pop.threshold (integer): 
1

Generating blacklists, whitelists and filtered tidy data...
done!

Choosing the final filtered dataset
   select the mid p-value threshold (5 options):
1: 0.05 *
2. 0.01 **
3. 0.001 ***
4. 0.0001 ****
5. 0.00001 *****
5
Please try again: 
5
Please try again: 
1

Final filtered tidy dataset: 
tidy.filtered.hwe.0.05.mid.p.value.1.hw.pop.threshold.rad

Using hw.pop.threshold/midp.threshold: 1/0.05
Filters parameters file: updated
################################### RESULTS ####################################
Filter HWE: 1 / 0.05
Number of individuals / strata / chrom / locus / SNP:
    Before: 254 / 7 / 492 / 11412 / 11412
    Blacklisted: 0 / 0 / 9 / 527 / 527
    After: 254 / 7 / 483 / 10885 / 10885

Computation time, overall: 51 sec
############################# completed filter_hwe #############################

Preparing output files...
File written: whitelist.markers.tsv
File written: blacklist.markers.tsv
File written: blacklist.id.tsv
Writing the filtered strata: strata.filtered.tsvstrata.filtered.tsv

Generating statistics after filtering
calculating individual stats...
File written: individuals qc info and stats summary
File written: individuals qc plot
calculating markers stats...

Transferring data to genomic converter...
Synchronizing data and strata...
    Number of strata: 7
    Number of individuals: 254

Writing tidy data set:
radiator_data_20191023@0852.rad
Calibrating REF/ALT alleles...
    number of REF/ALT switch = 2
Data summary: 
    number of samples: 254
    number of markers: 10885

Computation time, overall: 365 sec
############################# completed filter_rad #############################
```


# 22 October 2019

Adam's suggested I ask for an extension. That's what I should be doing! - done.

But I also want to know if the 12103 markers I've been using are filtered properly so I might run radiator on them. 

the batch_2.pruned.vcf file is the one I want. I copied the headers from batch_2.vcf to batch_2.pruned.vcf - that was the only way it would work. I also need to make a new pop map

```{r}
vcf<-parse.vcf("batch_2.pruned.vcf")
strata<-data.frame(INDIVIDUALS=colnames(vcf)[10:ncol(vcf)],
                   STRATA=gsub("sample_(\\w{4}).*","\\1",colnames(vcf)[10:ncol(vcf)]))
write.table(strata,"fwsw_sub_strata.txt",col.names = TRUE,row.names = FALSE,quote = FALSE,sep='\t')
```


```{r}
library(radiator)
setwd("popgen/fwsw_results/stacks/populations_subset75/")
data<-radiator::filter_rad(data="batch_2.pruned.vcf",
                           strata="fwsw_sub_strata.txt")
```

I keep getting this weird error: 

```
Error in .DynamicClusterCall(cl, length(cl), .fun = function(.proc_idx,  : 
  One of the nodes produced an error: Can not open file 'C:\Users\spf50\Research\popgen\fwsw_results\stacks\populations_subset75\filter_rad_20191022@1453\01_radiator\radiator_20191022@1453.gds'. The process cannot access the file because it is being used by another process.
```

Re-started the computer, we'll see if that helps -- it did not. 

Looks like this might be related to parallel cores -- 

```{r}
 data<-radiator::filter_rad(data="batch_2.pruned.vcf",
                            strata="fwsw_sub_strata.txt",parallel.core = 1)
```

^ works.


In the MAF helper table it looks like MAC 26 corresponds to MAF of 0.05 - which only includes a small number of loci!

I've got a feeling that the 12103 SNPs I've been using aren't the best set. 

```
> data<-radiator::filter_rad(data="batch_2.pruned.vcf",
+                            strata="fwsw_sub_strata.txt",parallel.core = 1)
################################################################################
############################# radiator::filter_rad #############################
################################################################################
The function arguments names have changed: please read documentation

Execution date@time: 20191022@1502
Folder created: filter_rad_20191022@1502
Function call and arguments stored in: radiator_filter_rad_args_20191022@1502.tsv
File written: random.seed (56970)
Filters parameters file generated: filters_parameters_20191022@1502.tsv

Reading VCF
Data summary: 
    number of samples: 303
    number of markers: 12103
done! timing: 8 sec

Generating individual stats...
[==================================================] 100%, completed in 0s
Generating markers stats...
[==================================================] 100%, completed in 0s
[==================================================] 100%, completed in 0s


Number of chromosome/contig/scaffold: 532
Number of locus: 12103
Number of markers: 12103
Number of populations: 7
Number of individuals: 303

Number of ind/pop:
ALFW = 48
ALST = 47
FLCC = 41
FLLG = 47
LAFW = 48
TXCC = 41
TXFW = 31

Number of duplicate id: 0
radiator Genomic Data Structure (GDS) file: radiator_20191022@1502.gds
################################################################################
########################### radiator::filter_monomorphic #######################
################################################################################
Execution date@time: 20191022@1507
Function call and arguments stored in: radiator_filter_monomorphic_args_20191022@1507.tsv
Filters parameters file: initiated
File written: blacklist.monomorphic.markers_20191022@1507.tsv
Synchronizing markers.meta
File written: whitelist.polymorphic.markers_20191022@1507.tsv
Filters parameters file: updated
################################### RESULTS ####################################

Filter monomorphic markers
Number of individuals / strata / chrom / locus / SNP:
    Before: 303 / 7 / 532 / 12103 / 12103
    Blacklisted: 0 / 0 / 1 / 9 / 9
    After: 303 / 7 / 531 / 12094 / 12094

Computation time, overall: 1 sec
######################## filter_monomorphic completed ##########################
################################################################################
######################## radiator::filter_common_markers #######################
################################################################################
Execution date@time: 20191022@1507
Function call and arguments stored in: radiator_filter_common_markers_args_20191022@1507.tsv
Filters parameters file: initiated
Scanning for common markers...
Generating UpSet plot to visualize markers in common
File written: whitelist.common.markers_20191022@1507.tsv
Filters parameters file: updated
################################### RESULTS ####################################

Filter common markers:
Number of individuals / strata / chrom / locus / SNP:
    Before: 303 / 7 / 531 / 12094 / 12094
    Blacklisted: 0 / 0 / 0 / 0 / 0
    After: 303 / 7 / 531 / 12094 / 12094

Computation time, overall: 1 sec
####################### filter_common_markers completed ########################
################################################################################
######################### radiator::filter_individuals #########################
################################################################################
Execution date@time: 20191022@1507
Function call and arguments stored in: radiator_filter_individuals_args_20191022@1507.tsv
Interactive mode: on

Step 1. Visualization
Step 2. Missingness
Step 3. Heterozygosity
Step 4. Total Coverage (if available)


Filters parameters file: initiated

Step 1. Visualization of samples QC

[==================================================] 100%, completed in 0s
File written: individuals qc info and stats summary
File written: individuals qc plot

Step 2. Filtering markers based individual missingness/genotyping

Do you want to blacklist samples based on missingness ? (y/n):
y
2 options to blacklist samples:
1. based on the outlier statistics
2. enter your own threshold
1

Removing outliers individuals based on genotyping statistics: 0.213308
Filters parameters file: updated
################################### RESULTS ####################################

Filter individuals based on missingness: 0.213308
Number of individuals / strata / chrom / locus / SNP:
    Before: 303 / 7 / 531 / 12094 / 12094
    Blacklisted: 49 / 0 / 0 / 0 / 0
    After: 254 / 7 / 531 / 12094 / 12094

Step 3. Filtering markers based on individual heterozygosity

Do you want to blacklist samples based on heterozygosity ? (y/n):
n

Filter monomorphic markers
Number of individuals / strata / chrom / locus / SNP:
    Blacklisted: 0 / 0 / 16 / 426 / 426

Computation time, overall: 314 sec
########################### completed filter_individuals #######################
################################################################################
############################## radiator::filter_mac ############################
################################################################################
Execution date@time: 20191022@1512
Function call and arguments stored in: radiator_filter_mac_args_20191022@1512.tsv
Interactive mode: on

Step 1. Visualization and helper table
Step 2. Filtering markers based on MAC


Importing data ...
Filters parameters file: initiated
Calculating GLOBAL MAC
[==================================================] 100%, completed in 0s
File written: maf.global.tsv

Step 1. MAC visualization and helper table

File written: mac.summary.stats.tsv
MAC range: [1 - 251]
MAF range: [0.002 - 0.4941]
Generating MAC helper table...
File written: maf.helper.table.tsv

Step 2. Filtering markers based on MAC

Choose the filter.mac threshold: 
1
File written: whitelist.markers.mac.tsv
File written: blacklist.markers.mac.tsv
Filters parameters file: updated
################################### RESULTS ####################################

Filter mac threshold: 1
Number of individuals / strata / chrom / locus / SNP:
    Before: 254 / 7 / 515 / 11668 / 11668
    Blacklisted: 0 / 0 / 0 / 0 / 0
    After: 254 / 7 / 515 / 11668 / 11668

Computation time, overall: 443 sec
############################ completed filter_mac ##############################
################################################################################
########################### radiator::filter_coverage ##########################
################################################################################
Execution date@time: 20191022@1519
Function call and arguments stored in: radiator_filter_coverage_args_20191022@1519.tsv
Interactive mode: on

Step 1. Visualization and helper table
Step 2. Filtering markers based on total coverage


Importing data ...
Filters parameters file: initiated

Step 1. Coverage visualization and helper table

Generating coverage statistics
[==================================================] 100%, completed in 0s
Generating coverage statistics: without outliers
Generating mean coverage helper table...
Files written: helper tables and plots

Step 2. Filtering markers based on mean coverage

Choose the min mean coverage threshold(e.g. 7 or 10): 
11
Choose the max mean coverage threshold (e.g. 100 or 300): 
50
File written: blacklist.markers.coverage_20191022@1519.tsv
File written: whitelist.markers.coverage_20191022@1519.tsv
Filters parameters file: updated
################################### RESULTS ####################################

Filter mean coverage thresholds: 11 / 50
Number of individuals / strata / chrom / locus / SNP:
    Before: 254 / 7 / 515 / 11668 / 11668
    Blacklisted: 0 / 0 / 23 / 256 / 256
    After: 254 / 7 / 492 / 11412 / 11412

Computation time, overall: 208 sec
########################## completed filter_coverage ###########################
################################################################################
######################### radiator::filter_genotyping ##########################
################################################################################
Execution date@time: 20191022@1523
Function call and arguments stored in: radiator_filter_genotyping_args_20191022@1523.tsv
Interactive mode: on

Step 1. Visualization and helper table
Step 2. Filtering markers based on maximum missing proportion allowed


Importing data ...
Filters parameters file: initiated

Step 1. Missing visualization and helper table

Generating statistics
[==================================================] 100%, completed in 0s
Generating missingness/genotyping helper table...
[==================================================] 100%, completed in 0s
[==================================================] 100%, completed in 0s
[==================================================] 100%, completed in 0s
[==================================================] 100%, completed in 0s
[==================================================] 100%, completed in 0s
[==================================================] 100%, completed in 0s
[==================================================] 100%, completed in 0s
File written: markers.pop.missing.helper.table.tsv
Files written: helper tables and plots

Step 2. Filtering markers based on maximum missing proportion

Choose the maximum missing proportion allowed: 
0.2

Removing markers based on genotyping statistic: 0.2
File written: blacklist.markers.genotyping_20191022@1523.tsv
File written: whitelist.markers.genotyping_20191022@1523.tsv
Filters parameters file: updated
################################### RESULTS ####################################

Filter genotyping threshold: 0.2
Number of individuals / strata / chrom / locus / SNP:
    Before: 254 / 7 / 492 / 11412 / 11412
    Blacklisted: 0 / 0 / 0 / 0 / 0
    After: 254 / 7 / 492 / 11412 / 11412

Computation time, overall: 45 sec
######################## completed filter_genotyping ###########################
################################################################################
######################### radiator::filter_snp_position_read ###################
################################################################################
Execution date@time: 20191022@1524
Function call and arguments stored in: radiator_filter_snp_position_read_args_20191022@1524.tsv
2 steps to visualize and filter the data based on the number of SNP on the read/locus:
Step 1. Visualization (boxplot, distribution
Step 2. Threshold selection
Filters parameters file: initiated
COL info required, returning data

Computation time, overall: 0 sec
##################### completed filter_snp_position_read #######################
################################################################################
############################ radiator::filter_snp_number #######################
################################################################################
Execution date@time: 20191022@1524
Function call and arguments stored in: radiator_filter_snp_number_args_20191022@1524.tsv
Interactive mode: on
2 steps to visualize and filter the data based on the number of SNP on the read/locus:
Step 1. Impact of SNP number per read/locus (on individual genotypes and locus/snp number potentially filtered)
Step 2. Choose the filtering thresholds
Filters parameters file: initiated
Generating statistics
Generating helper table...
geom_path: Each group consists of only one observation. Do you need
to adjust the group aesthetic?
geom_path: Each group consists of only one observation. Do you need
to adjust the group aesthetic?
geom_path: Each group consists of only one observation. Do you need
to adjust the group aesthetic?
geom_path: Each group consists of only one observation. Do you need
to adjust the group aesthetic?
Files written: helper tables and plots

Step 2. Filtering markers based on the maximum of SNPs per locus

Do you still want to blacklist markers? (y/n):
n
File written: whitelist.markers.genotyping.tsv
File written: blacklist.markers.genotyping.tsv
Filters parameters file: updated
################################### RESULTS ####################################

Filter SNPs per locus threshold: 1e+12
Number of individuals / strata / chrom / locus / SNP:
    Before: 254 / 7 / 492 / 11412 / 11412
    Blacklisted: 0 / 0 / 0 / 0 / 0
    After: 254 / 7 / 492 / 11412 / 11412

Computation time, overall: 14 sec
######################### completed filter_snp_number ##########################
################################################################################
############################## radiator::filter_ld #############################
################################################################################
Execution date@time: 20191022@1524
Function call and arguments stored in: radiator_filter_ld_args_20191022@1524.tsv

Interactive mode: on

Step 1. Short distance LD threshold selection
Step 2. Filtering markers based on short distance LD
Step 3. Long distance LD pruning selection
Step 4. Threshold selection
Step 5. Filtering markers based on long distance LD


Filters parameters file: initiated
Minimizing short distance LD...

There is no variation in the number of SNP/locus across the data

Filters parameters file: updated
################################### RESULTS ####################################

Number of individuals / strata / chrom / locus / SNP:
    Before: 254 / 7 / 492 / 11412 / 11412
    Blacklisted: 0 / 0 / 0 / 0 / 0
    After: 254 / 7 / 492 / 11412 / 11412

Do you want to continue filtering using long distance ld  ? (y/n):
n

Computation time, overall: 9 sec
############################# completed filter_ld ##############################
################################################################################
######################## radiator::detect_mixed_genomes ########################
################################################################################
Execution date@time: 20191022@1524

detect_mixed_genomes function call arguments:
    data = SeqVarGDSClass
    interactive.filter = TRUE
    detect.mixed.genomes = FALSE
    ind.heterozygosity.threshold = NULL
    verbose = TRUE
    parallel.core = 1

dots-dots-dots ... arguments

Arguments inside "..." assigned in detect_mixed_genomes:
    internal = FALSE
    parameters = list
    path.folder = filter_rad_20191022@1502


File written: radiator_detect_mixed_genomes_args_20191022@1524.tsv
Filters parameters file: initiated
[==================================================] 100%, completed in 0s
Calculating heterozygosity statistics
Generating plots

The greatest value of a picture is when it forces us
to notice what we never expected to see.

John W. Tukey. Exploratory Data Analysis. 1977.


Inspect plots and tables in folder created...
    Do you want to exclude individuals based on heterozygosity ? (y/n): 
n
Filters parameters file: updated
################################### RESULTS ####################################
Detect mixed genomes: 0 1
Number of individuals / strata / chrom / locus / SNP:
    Before: 254 / 7 / 492 / 11412 / 11412
    Blacklisted: 0 / 0 / 0 / 0 / 0
    After: 254 / 7 / 492 / 11412 / 11412

Computation time, overall: 26 sec
######################## completed detect_mixed_genomes ########################

################################################################################
###################### radiator::detect_duplicate_genomes ######################
################################################################################
Execution date@time: 20191022@1524
Function call and arguments stored in a file
File written: radiator_detect_duplicate_genomes_args_20191022@1524.tsv
File written: random.seed (56970)
Filters parameters file: initiated
[==================================================] 100%, completed in 0s
Calculating manhattan distances between individuals...
Generating summary statistics
Generating plots

Inspect tables and figures to decide if some individual(s) need to be blacklisted
    Do you need to blacklist individual(s) (y/n): 
n
Filters parameters file: updated
################################### RESULTS ####################################
Detect duplicate genomes: 0
Number of individuals / strata / chrom / locus / SNP:
    Before: 254 / 7 / 492 / 11412 / 11412
    Blacklisted: 0 / 0 / 0 / 0 / 0
    After: 254 / 7 / 492 / 11412 / 11412

Computation time, overall: 28 sec
###################### completed detect_duplicate_genomes ######################
################################################################################
############################# radiator::filter_hwe #############################
################################################################################
Execution date@time: 20191022@1525
Interactive mode: on
Function call and arguments stored in: radiator_filter_hwe_args_20191022@1525.tsv
Filters parameters file: initiated
    using tidy data frame of genotypes as input
    skipping all filters
Summarizing data
File written: genotypes.summary.tsv
HWE analysis for pop: ALFW
HWE analysis for pop: ALST
HWE analysis for pop: FLCC
HWE analysis for pop: FLLG
HWE analysis for pop: LAFW
HWE analysis for pop: TXCC
HWE analysis for pop: TXFW
HWE analysis for pop: OVERALL
File written: hw.pop.sum.tsv
Plot written: hwd.plot.blacklist.markers.pdf
Plot written: hwe.ternary.plots.missing.data.pdf
Plot written: hwe.manhattan.plot.pdf

Do you want to continue with the filtering ? (y/n):
y

Based on figures and tables enter the hw.pop.threshold (integer): 
1

Generating blacklists, whitelists and filtered tidy data...
done!

Choosing the final filtered dataset
   select the mid p-value threshold (5 options):
1: 0.05 *
2. 0.01 **
3. 0.001 ***
4. 0.0001 ****
5. 0.00001 *****
5
Please try again: 
5
Please try again: 
1

Final filtered tidy dataset: 
tidy.filtered.hwe.0.05.mid.p.value.1.hw.pop.threshold.rad

Using hw.pop.threshold/midp.threshold: 1/0.05
Filters parameters file: updated
################################### RESULTS ####################################
Filter HWE: 1 / 0.05
Number of individuals / strata / chrom / locus / SNP:
    Before: 254 / 7 / 492 / 11412 / 11412
    Blacklisted: 0 / 0 / 9 / 527 / 527
    After: 254 / 7 / 483 / 10885 / 10885

Computation time, overall: 209 sec
############################# completed filter_hwe #############################

Preparing output files...
File written: whitelist.markers.tsv
File written: blacklist.markers.tsv
File written: blacklist.id.tsv
Writing the filtered strata: strata.filtered.tsvstrata.filtered.tsv

Generating statistics after filtering
calculating individual stats...
[==================================================] 100%, completed in 0s
File written: individuals qc info and stats summary
File written: individuals qc plot
calculating markers stats...
[==================================================] 100%, completed in 0s
[==================================================] 100%, completed in 0s

Transferring data to genomic converter...
Synchronizing data and strata...
    Number of strata: 7
    Number of individuals: 254

Writing tidy data set:
radiator_data_20191022@1532.rad
Data summary: 
    number of samples: 254
    number of markers: 10885

Computation time, overall: 1829 sec
############################# completed filter_rad #############################
There were 50 or more warnings (use warnings() to see the first 50)


```
the warnings are about an unavailable font family.

what this analysis suggests is that perhaps I've been working with less-than-ideal data, including 49 individuals that didn't pass missingness tests.

```{r}
blacklist_inds<-read.delim("filter_rad_20191022@1502/04_filter_individuals/blacklist.individuals.missing_20191022@1507.tsv")
blacklist_inds$INDIVIDUALS<-gsub("-","_",blacklist_inds$INDIVIDUALS)
strata<-read.delim("fwsw_sub_strata.txt")
table(strata$STRATA[!(strata$INDIVIDUALS %in% blacklist_inds$INDIVIDUALS)])
```

But removing those individuals leaves enough individuals per population - I could run the dadi analysis on this dataset. 

Ok, so I also re-ran stacks on the whitelisted loci and individuals for the 'full' dataset. For some reason the Stacks Fst values are much higher than the ones I calculated using gwscaR

```{r}
full_fsts<-read.delim("stacks/populations_whitelist/batch_2.fst_summary.tsv",row.names = 1)
full_fsts<-rbind(full_fsts,TXSP=rep(NA,ncol(full_fsts))) #add the final row

Tfull_fsts<-t(full_fsts)
full_fsts[lower.tri(full_fsts)]<-Tfull_fsts[lower.tri(Tfull_fsts)] # now it's symmetric
full_fsts<-full_fsts[pop.list,pop.list]
colnames(full_fsts)<-rownames(full_fsts)<-pop.labs
```

The maximum value is between FLFW and TXFW, 0.254.

`r rowMeans(full_fsts,na.rm = TRUE)`
TXSP                        0.04080420
TXCC                        0.04113533
TXFW                        0.07004118
TXCB                        0.04451881
LAFW                        0.03660252
ALST                        0.03097860
ALFW                        0.03860451
FLSG                        0.02929251
FLKB                        0.02966820
FLFD                        0.03289763
FLSI                        0.03135164
FLAB                        0.03929079
FLPB                        0.05155559
FLHB                        0.05572510
FLCC                        0.06095059
FLFW                        0.11157567

And FLFW is most different from the others. 

# 21 October 2019

To fill in the results, let's get some stats.

Number of shared Stacks outliers:

```{r}
fw_SNPinfo<-readRDS("fw_SNPinfo.RDS")
shared_stacks<-fw_SNPinfo$ID[fw_SNPinfo$stacks_AL_P < 0.05 & fw_SNPinfo$stacks_LA_P < 0.05 &
                          fw_SNPinfo$stacks_TX_P < 0.05 & fw_SNPinfo$stacks_FL_P < 0.05]
shared_stacks<-shared_stacks[!is.na(shared_stacks)]
fw_SNPinfo[fw_SNPinfo$ID %in% shared_stacks,]
```

Number of shared permutation outliers:
```{r}
length(which(rowSums(fw_SNPinfo[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4))
length(unique(fw_SNPinfo$Chrom[which(rowSums(fw_SNPinfo[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4)]))
```

Are any of those the same as the Stacks ones?

```{r}
permout<-fw_SNPinfo$ID[which(rowSums(fw_SNPinfo[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4)]
permout[permout %in% shared_stacks]
```

Pcapadt: 
```{r}
dim(fw_SNPinfo[fw_SNPinfo$pcadaptQ<0.01 & !is.na(fw_SNPinfo$pcadaptQ),])
pcout<-fw_SNPinfo$ID[fw_SNPinfo$pcadaptQ<0.01 & !is.na(fw_SNPinfo$pcadaptQ)]
pcout[pcout %in% shared_stacks] # overlapping with shared stacks
pcout[pcout %in% permout] # overlapping with permutations
```

Bayenv:

```{r}
xtxout<-fw_SNPinfo$ID[fw_SNPinfo$XtX>=quantile(plot_dat$XtX,0.99)]
xtxout[xtxout %in% pcout]
```

```{r}
salout<-fw_SNPinfo$ID[fw_SNPinfo$logSalBF>=quantile(fw_SNPinfo$logSalBF,0.99)]
salout[salout %in% xtxout]
salout[salout %in% pcout]
salout[salout %in% shared_stacks]
salout[salout %in% permout]
```


To support the treemix analysis, I want to investigate the f3 and f4 analyses for the two best-supported migration edges.

```{r}
threepop<-data.frame(do.call(rbind,strsplit(grep(";",readLines("treemix/fwsw_threepop.txt"),value = TRUE),' ')))
colnames(threepop)<-c("pops","f3_stat","f3_se","f3_z")
threepop$f3_p<-pnorm(-abs(as.numeric(as.character(threepop$f3_z)))) # one sided
```
Significantly negative f3 statistics mean that the first pop in the list (A in A;B,C) is admixed.

```{r}
fourpop<-data.frame(do.call(rbind,strsplit(grep(";",readLines("treemix/fwsw_fourpop_1.txt"),value = TRUE),' ')))
colnames(fourpop)<-c("pops","f4_stat","f4_se","f4_z")
fourpop$f4_p<-2*pnorm(-abs(as.numeric(as.character(fourpop$f4_z))))
```
a significantly non-zero value indicates gene flow in the tree.


Edge 1: FLSI/FLAB -> TXFW/TX

```{r}
threepop[grep("FLSI;.*TXFW",threepop$pops),] # use this to see the order that I want
threepop[threepop$pops=="FLSI;TXFW,FLAB",] 
```
This does not have a negative value so FLSI is not admixed -- but that's not really what's interesting, is it?

```{r}
threepop[grep("TXFW;.*FLSI",threepop$pops),] # use this to see the order that I want
threepop[threepop$pops=="TXFW;TXCC,FLSI",] 
```
But this is also not admixed, so does not support direct migration?


```{r}
fourpop[grep("TXCC,TXFW;.*FLSI.*",fourpop$pops),] # use this to see the order that I want
fourpop[fourpop$pops=="TXCC,TXFW;FLSI,FLAB",] 
as.numeric(as.character(fourpop$f4_stat[fourpop$pops=="TXCC,TXFW;FLSI,FLAB"]))+as.numeric(as.character(fourpop$f4_se[fourpop$pops=="TXCC,TXFW;FLSI,FLAB"]))
```
The statistic is negative but overlaps with zero, so not indicative of gene flow. 

Where are the bootstrap values? I think they're in the treeout as the 'jackknife estimates' - I'll deal with that later, it's for tree topology not migration edges anyway.


Edge 2: branch from west FL to others -> FLAB

```{r}
threepop[grep("FLAB;.*",threepop$pops),] # use this to see the order that I want
threepop[threepop$pops=="FLAB;FLPB,FLLG",]
```
This indicates no admixture, and none of the FLAB values are neggative

```{r}
fourpop[grep("FLAB,FL.*;.*",fourpop$pops),] # use this to see the order that I want
fourpop[fourpop$pops=="FLAB,FLCC;FLPB,FLLG",] 
as.numeric(as.character(fourpop$f4_stat[fourpop$pops=="FLAB,FLCC;FLPB,FLLG"]))+as.numeric(as.character(fourpop$f4_se[fourpop$pops=="FLAB,FLCC;FLPB,FLLG"]))
```

Also not indicative of gene flow. 

```{r}
fourpop$f4_stat<-as.numeric(as.character(fourpop$f4_stat))
fourpop$f4_se<-as.numeric(as.character(fourpop$f4_se))
abs(fourpop$f4_stat[grep("FLAB,FL.*;.*",fourpop$pops)])-fourpop$f4_se[grep("FLAB,FL.*;.*",fourpop$pops)]
```
These are all pretty close to zero...

Things to do:

* pairwise FSTs using the full dataset (make a figure or table) & plot with treemix covariances [check]
* summary statistics for the populations with number of individuals, HE, HO, etc. [check]
* minor allele frequency histograms 
* Add labels to Fig 1 (and maybe bootstrap estimates?)
* TXCC-TXCB, ALST-FLSG, FLPB-FLHB plots

I wrote a loop to calculate mean fsts from the full dataset -- see the reanalysis doc.

What do I want in the table of summary statistics?

Pop | N Pregnant (N in full) | N non-pregnant (N in full) | N females (N in full) | N juveniles (N In full) | Ho in full (variance) | HO in subset (variance) | % polymorphic | p in full (variance) | p in subset (variance)

To do this I need both vcfs

```{r}
pop_map<-read.delim("../fwsw_pops_map.txt",header = FALSE,stringsAsFactors = FALSE)
ful_vcf<-parse.vcf("filter_rad_20191014@1654/14_filtered/radiator_data_20191014@1710.vcf")
colnames(ful_vcf)<-gsub("\\-","_",colnames(ful_vcf))
sub_vcf<-parse.vcf("stacks/populations_subset75/batch_2.pruned.vcf")
```

```{r}
pop_summaries<-do.call(rbind,lapply(pop.list,function(pop,ful,sub){
  ful_dat<-ful[,c(1:9,grep(pop,colnames(ful)))]
  sub_dat<-sub[,c(1:9,grep(pop,colnames(sub)))]
  # calc observed het values
  ful_ho<-apply(ful_vcf,1,calc.het)
  sub_ho<-apply(sub_vcf,1,calc.het)
  # estimate allele freqs
  ful_afs<-do.call(rbind,apply(ful_vcf,1,calc.afs.vcf))
  sub_afs<-do.call(rbind,apply(sub_vcf,1,calc.afs.vcf))
  # save data frame
  dat<-data.frame(pop=pop,
                  preg_full=length(grep(paste0(pop,"P"),colnames(ful))),
                  preg_sub=length(grep(paste0(pop,"P"),colnames(sub))),
                  nonp_full=length(grep(paste0(pop,"NP"),colnames(ful))),
                  nonp_sub=length(grep(paste0(pop,"NP"),colnames(sub))),
                  nfem_full=length(grep(paste0(pop,"F"),colnames(ful))),
                  nfem_sub=length(grep(paste0(pop,"F"),colnames(sub))),
                  njuv_full=length(grep(paste0(pop,"J"),colnames(ful)))+
                    length(grep(paste0(pop,"DB"),colnames(ful))),
                  njuv_sub=length(grep(paste0(pop,"J"),colnames(sub))) + 
                    length(grep(paste0(pop,"DB"),colnames(sub))),
                  ho_full = mean(ful_ho,na.rm = TRUE),
                  hov_full = var(ful_ho,na.rm = TRUE),
                  ho_sub = mean(sub_ho,na.rm = TRUE),
                  hov_sub = var(sub_ho,na.rm = TRUE),
                  poly_ful = nrow(ful_afs[ful_afs$RefFreq<1,])/nrow(ful_afs)*100,
                  poly_sub = nrow(sub_afs[sub_afs$RefFreq<1,])/nrow(sub_afs)*100,
                  p_full = mean(ful_afs$RefFreq,na.rm=TRUE),
                  pv_full = var(ful_afs$RefFreq,na.rm=TRUE),
                  p_sub = mean(sub_afs$RefFreq,na.rm=TRUE),
                  pv_sub = var(sub_afs$RefFreq,na.rm=TRUE))
  return(dat)
},ful=ful_vcf,sub=sub_vcf))
write.csv(pop_summaries,"population_summaries.csv",col.names = TRUE,row.names = FALSE,quote=FALSE)
```

Allele frequency spectra: 
```{r}
png("../figs/afs.png",height=8,width=6,units="in",res=300)
par(mfrow=c(4,4),oma=c(2,2,2,2),mar=c(2,2,2,2))

pop_afs<-do.call(rbind,lapply(pop.labs,function(pop,ful,cols){
  if(pop=="FLFW"){
    ful_dat<-ful[,c(1:9,grep("FLLG",colnames(ful)))]
  } else {
    ful_dat<-ful[,c(1:9,grep(pop,colnames(ful)))]
  }
  # estimate allele freqs
  ful_afs<-do.call(rbind,apply(ful_vcf,1,calc.afs.vcf))
  h<-hist(ful_afs$AltFreq,breaks=seq(0,0.5,0.01),main=pop,col = cols[pop],
          xlab = "Allele Frequency",ylab = "Frequency",freq = TRUE,border = cols[pop])
},ful=ful_vcf,cols=c(TXSP="black",TXCC="black",TXFW="#2166ac",TXCB="black",
                     LAFW="#2166ac",ALST="black",ALFW="#2166ac",FLSG="black",
                     FLKB="black",FLFD="black",FLSI="black",FLAB="black",
                     FLPB="black",FLHB="black",FLCC="black",FLFW="#2166ac")))
dev.off()
```

Ok, now the null SW-SW comparisons...the downside is that the subsetted dataset doesn't have the additional pops. 

```{r stacks_fsts}
swsw.al<-read.delim("stacks/populations_all/batch_2.fst_ALST-FLSG.tsv")
swsw.tx<-read.delim("stacks/populations_all/batch_2.fst_TXCB-TXCC.tsv")
swsw.fl<-read.delim("stacks/populations_all/batch_2.fst_FLCC-FLPB.tsv")



fst_dat<-list(swsw.tx,swsw.al,swsw.fl)
png("../../fsts_null.png",height=6,width=6.5,units="in",res=300)
fsts<-plot_multiple_LGs(list_fsts = fst_dat,fst_name = "Corrected.AMOVA.Fst",bp_name="BP",chr_name="Chr",
                        lgs=lgs,plot_labs=list("TXCB vs TXCC","ALST vs FLSG","FLCC vs FLPB"),
                        pt_cols = list(c(grp.colors[1],grp.colors[2]),c(grp.colors[2],grp.colors[3]),
                                       c(grp.colors[6],grp.colors[5])),
                        ncol=1,addSmooth = FALSE,pch=19,y.lim = c(0,1),pt.cex=1,axis.size = 1)
dev.off()
```

```{r stacks_fsts}
fwsw.al_all<-read.delim("stacks/populations_all/batch_2.fst_ALFW-ALST.tsv")
fwsw.la_all<-read.delim("stacks/populations_all/batch_2.fst_ALST-LAFW.tsv")
fwsw.tx_all<-read.delim("stacks/populations_all/batch_2.fst_TXCC-TXFW.tsv")
fwsw.fl_all<-read.delim("stacks/populations_all/batch_2.fst_FLCC-FLFW.tsv")


fst_dat<-list(fwsw.tx_all,fwsw.la_all,fwsw.al_all,fwsw.fl_all)
png("../../fsts_fw_all.png",height=6,width=6.5,units="in",res=300)
fsts<-plot_multiple_LGs(list_fsts = fst_dat,fst_name = "Corrected.AMOVA.Fst",bp_name="BP",chr_name="Chr",
                        lgs=lgs,plot_labs=list("TXFW vs TXCC","ALST vs LAFW","ALST vs ALFW","FLCC vs FLFW"),
                        pt_cols = list(c(grp.colors[1],grp.colors[2]),c(grp.colors[2],grp.colors[3]),
                                       c(grp.colors[3],grp.colors[2]),c(grp.colors[6],grp.colors[5])),
                        ncol=1,addSmooth = FALSE,pch=19,y.lim = c(0,1),pt.cex=1,axis.size = 1)
dev.off()
```

The final thing to do is adding labels to fig 1. 

Perhaps make heatmaps of covariance and Fsts? YES!

I want to convert the whitelist from radiator into a whitelist for stacks

```{r}
map<-read.delim("stacks/populations_all/batch_2.plink.map",stringsAsFactors = FALSE,
                comment.char = "#",header=FALSE)
map$locus<-gsub("(\\d+)_\\d+","\\1",map$V2)
map$pos<-gsub("(\\d+)_(\\d+)","\\2",map$V2)
map$bp<-as.numeric(as.character(map$V4))+1
whitelist<-read.delim("filter_rad_20191014@1654/14_filtered/whitelist.markers.tsv",header = TRUE)

whitemap<-map[paste(map$V1,map$locus,map$bp,sep="_") %in%
                paste(whitelist$CHROM,whitelist$LOCUS,whitelist$POS,sep="_"),]
write.table(whitemap[,c("locus","pos")],"stacks/populations_all/whitelist.txt",col.names = FALSE,
            row.names = FALSE,sep='\t',quote=FALSE)
```


# 18 October 2019

Now I want to do Fst outlier plots, it should be easy after doing the bayenv plots.


```{r plotOutliersSetup}
library(scales)
fw_SNPinfo<-readRDS("fw_SNPinfo.RDS")
```

First, save and revisit the bayenv analysis:

```{r plotBayenvOutliers}
cols<-c(perm=alpha('#e41a1c',0.75),sal=alpha('#377eb8',0.75),pc=alpha('#a65628',0.75),stacks=alpha('#f781bf',0.75),xtx=alpha('#ff7f00',0.75))
png("../figs/BayenvOutliers.png",height=4,width=8.5,units="in",res=300)
par(mfrow=c(2,1),oma=c(1,1.5,1,1),mar=c(2,2,1,1),xpd=TRUE)
# plot XtX
plot_dat<-fst.plot(fw_SNPinfo,scaffs.to.plot = lgs,fst.name = "XtX",chrom.name = "Chrom",bp.name = "Pos",axis.size = 0,pch=19)
points(plot_dat$plot.pos[plot_dat$XtX>=quantile(plot_dat$XtX,0.99)],
       plot_dat$XtX[plot_dat$XtX>=quantile(plot_dat$XtX,0.99)],
       col=cols["xtx"],cex=0.75,pch=3,lwd=2)
points(plot_dat$plot.pos[plot_dat$logSalBF>=quantile(plot_dat$logSalBF,0.99)],
       plot_dat$XtX[plot_dat$logSalBF>=quantile(plot_dat$logSalBF,0.99)],
       col=cols["sal"],cex=0.85,pch=2)
points(plot_dat$plot.pos[rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       plot_dat$XtX[rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       col=cols["perm"],cex=1,pch=4,lwd=2)
points(plot_dat$plot.pos[plot_dat$stacks_AL_P < 0.05 & plot_dat$stacks_LA_P < 0.05 &
                           plot_dat$stacks_TX_P < 0.05 & plot_dat$stacks_FL_P < 0.05],
       plot_dat$XtX[plot_dat$stacks_AL_P < 0.05 & plot_dat$stacks_LA_P < 0.05 &
                           plot_dat$stacks_TX_P < 0.05 & plot_dat$stacks_FL_P < 0.05],
       col=cols["stacks"],cex=1,pch=5,lwd=2)
points(plot_dat$plot.pos[plot_dat$pcadaptQ<0.01],
       plot_dat$XtX[plot_dat$pcadaptQ<0.01],
       col=cols["pc"],cex=1,pch=0,lwd=2)
axis(2,las=1)
mtext(expression(italic("X")^"T"~italic("X")),2,line=2)

# add the LG labels
midpts<-tapply(plot_dat$plot.pos,plot_dat$Chrom,median)
text(x=midpts[lgs],y=0)

# plot Bayes Factors
plot_dat<-fst.plot(plot_dat,scaffs.to.plot = lgs,fst.name = "logSalBF",chrom.name = "Chrom",bp.name = "Pos",axis.size = 0,pch=19)
points(plot_dat$plot.pos[plot_dat$logSalBF>=quantile(plot_dat$logSalBF,0.99)],
       plot_dat$logSalBF[plot_dat$logSalBF>=quantile(plot_dat$logSalBF,0.99)],
       col=cols["sal"],cex=0.85,pch=2)
points(plot_dat$plot.pos[plot_dat$XtX>=quantile(plot_dat$XtX,0.99)],
       plot_dat$logSalBF[plot_dat$XtX>=quantile(plot_dat$XtX,0.99)],
       col=cols["xtx"],cex=0.75,pch=3,lwd=2)
points(plot_dat$plot.pos[rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       plot_dat$logSalBF[rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       col=cols["perm"],cex=1,pch=4,lwd=2)
points(plot_dat$plot.pos[plot_dat$stacks_AL_P < 0.05 & plot_dat$stacks_LA_P < 0.05 &
                           plot_dat$stacks_TX_P < 0.05 & plot_dat$stacks_FL_P < 0.05],
       plot_dat$logSalBF[plot_dat$stacks_AL_P < 0.05 & plot_dat$stacks_LA_P < 0.05 &
                           plot_dat$stacks_TX_P < 0.05 & plot_dat$stacks_FL_P < 0.05],
       col=cols["stacks"],cex=1,pch=5,lwd=2)
points(plot_dat$plot.pos[plot_dat$pcadaptQ<0.01],
       plot_dat$logSalBF[plot_dat$pcadaptQ<0.01],
       col=cols["pc"],cex=1,pch=0,lwd=2)
axis(2,las=1)
mtext("log(Salinity Bayes Factors)",2,line=2)

# add the LG labels
midpts<-tapply(plot_dat$plot.pos,plot_dat$Chrom,median)
text(x=midpts[lgs],y=-5)

# add outside legend

opar <- par(fig=c(0, 1, 0, 1), oma=c(0, 0, 0, 0),
            mar=c(0, 0, 0, 0), new=TRUE)
on.exit(par(opar))
plot(0, 0, type='n', bty='n', xaxt='n', yaxt='n')
legend("top",c(expression("Permutation"~italic("F")["ST"]),
         expression("Stacks"~italic("F")["ST"]),
         "PCAdapt",expression(italic("X")^T~italic("X")),"Salinity BF"),xjust = 0.5,x.intersp = 0.5,
       col = cols[c("perm","stacks","pc","xtx","sal")],
       pt.bg=cols[c("perm","stacks","pc","xtx","sal")],pch=c(4,5,0,3,2),bty='n',ncol=5)
dev.off()
```

Ok, now I can try the fwsw analysis using a function from the 202_fwsw_reanalysis document


```{r stacks_fsts}
fwsw.al<-read.delim("stacks/populations_subset75/batch_2.fst_ALFW-ALST.tsv")
fwsw.al<-fwsw.al[paste(fwsw.al$Chr,fwsw.al$BP,sep="_") %in% paste(fw_SNPinfo$Chrom,fw_SNPinfo$BP,sep="_"),]
fwsw.la<-read.delim("stacks/populations_subset75/batch_2.fst_ALST-LAFW.tsv")
fwsw.la<-fwsw.la[paste(fwsw.la$Chr,fwsw.la$BP,sep="_") %in% paste(fw_SNPinfo$Chrom,fw_SNPinfo$BP,sep="_"),]
fwsw.tx<-read.delim("stacks/populations_subset75/batch_2.fst_TXCC-TXFW.tsv")
fwsw.tx<-fwsw.tx[paste(fwsw.tx$Chr,fwsw.tx$BP,sep="_") %in% paste(fw_SNPinfo$Chrom,fw_SNPinfo$BP,sep="_"),]
fwsw.fl<-read.delim("stacks/populations_subset75/batch_2.fst_FLCC-FLFW.tsv")
fwsw.fl<-fwsw.fl[paste(fwsw.fl$Chr,fwsw.fl$BP,sep="_") %in% paste(fw_SNPinfo$Chrom,fw_SNPinfo$BP,sep="_"),]
```

```{r plot_stacks_fsts}
fst_dat<-list(fwsw.al,fwsw.la,fwsw.tx,fwsw.fl)
fsts<-plot_multiple_LGs(list_fsts = list_fsts,fst_name = "Corrected.AMOVA.Fst",bp_name="BP",chr_name="Chr",
                        lgs=lgs,plot_labs=list("ALFW vs ALST","ALST vs LAFW","TXFW vs TXCC","FLFW vs FLCC"),
                        pt_cols = list(c(grp.colors[3],grp.colors[2]),c(grp.colors[2],grp.colors[3]),
                                       c(grp.colors[1],grp.colors[2]),c(grp.colors[6],grp.colors[5])),
                        ncol=1,addSmooth = FALSE,pch=19,y.lim = c(0,1),pt.cex=1,axis.size = 1)
```

So I vectorized it above, is there a way to turn points into a list so I could pass that to the function and add those? I'll need to make sure the fw_SNPinfo has both p-values and fst values....but this is actually kind of challenging so I'm just going to do the hacky version at the moment. First, to merge it all. 

```{r}
colnames(fw_SNPinfo)[grep("stacks",colnames(fw_SNPinfo))]<-paste0(colnames(fw_SNPinfo)[grep("stacks",colnames(fw_SNPinfo))],"_P")
fw_SNPinfo<-merge(fw_SNPinfo,fwsw.al[,c("Locus.ID","Corrected.AMOVA.Fst")],by.x="ID",by.y="Locus.ID",all.x = TRUE)
colnames(fw_SNPinfo)[ncol(fw_SNPinfo)]<-"stacks_AL"
fw_SNPinfo<-merge(fw_SNPinfo,fwsw.la[,c("Locus.ID","Corrected.AMOVA.Fst")],by.x="ID",by.y="Locus.ID",all.x = TRUE)
colnames(fw_SNPinfo)[ncol(fw_SNPinfo)]<-"stacks_LA"
fw_SNPinfo<-merge(fw_SNPinfo,fwsw.tx[,c("Locus.ID","Corrected.AMOVA.Fst")],by.x="ID",by.y="Locus.ID",all.x = TRUE)
colnames(fw_SNPinfo)[ncol(fw_SNPinfo)]<-"stacks_TX"
fw_SNPinfo<-merge(fw_SNPinfo,fwsw.fl[,c("Locus.ID","Corrected.AMOVA.Fst")],by.x="ID",by.y="Locus.ID",all.x = TRUE)
colnames(fw_SNPinfo)[ncol(fw_SNPinfo)]<-"stacks_FL"
saveRDS(fw_SNPinfo,"fw_SNPinfo.RDS")
```


```{r}
cols<-c(perm=alpha('#e41a1c',0.75),sal=alpha('#377eb8',0.75),pc=alpha('#a65628',0.75),stacks=alpha('#f781bf',0.75),xtx=alpha('#ff7f00',0.75))
png("../figs/FstOutliers.png",height=5,width=8.5,units="in",res=300,pointsize=14)
par(mfrow=c(4,1),oma=c(1,1,0.5,1),mar=c(2,2,1,1),xpd=TRUE)
# plot TX
plot_dat<-fst.plot(fw_SNPinfo,scaffs.to.plot = lgs,fst.name = "stacks_TX",chrom.name = "Chrom",bp.name = "Pos",axis.size = 0,pch=19,pt.cols = c(grp7colors[1],grp7colors[2]),pt.cex = 1)
points(plot_dat$plot.pos[plot_dat$logSalBF>=quantile(plot_dat$logSalBF,0.99)],
       plot_dat$stacks_TX[plot_dat$logSalBF>=quantile(plot_dat$logSalBF,0.99)],
       col=cols["sal"],cex=1,pch=2)
points(plot_dat$plot.pos[plot_dat$XtX>=quantile(plot_dat$XtX,0.99)],
       plot_dat$stacks_TX[plot_dat$XtX>=quantile(plot_dat$XtX,0.99)],
       col=cols["xtx"],cex=1,pch=3,lwd=2)
points(plot_dat$plot.pos[rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       plot_dat$stacks_TX[rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       col=cols["perm"],cex=1,pch=4,lwd=2)
points(plot_dat$plot.pos[plot_dat$stacks_AL_P < 0.05 & plot_dat$stacks_LA_P < 0.05 &
                           plot_dat$stacks_TX_P < 0.05 & plot_dat$stacks_FL_P < 0.05],
       plot_dat$stacks_TX[plot_dat$stacks_AL_P < 0.05 & plot_dat$stacks_LA_P < 0.05 &
                           plot_dat$stacks_TX_P < 0.05 & plot_dat$stacks_FL_P < 0.05],
       col=cols["stacks"],cex=1,pch=5,lwd=2)
points(plot_dat$plot.pos[plot_dat$pcadaptQ<0.01],
       plot_dat$stacks_TX[plot_dat$pcadaptQ<0.01],
       col=cols["pc"],cex=1,pch=0,lwd=2)
axis(2,las=1,pos=-1500000)
mtext("TXFW vs. TXCC",2,line=1,cex=0.65)
# add the LG labels
midpts<-tapply(plot_dat$plot.pos,plot_dat$Chrom,median)
text(x=midpts[lgs],y=-0.15)

# plot AL
plot_dat<-fst.plot(fw_SNPinfo,scaffs.to.plot = lgs,fst.name = "stacks_AL",chrom.name = "Chrom",bp.name = "Pos",axis.size = 0,pch=19,pt.cols = c(grp7colors[3],"lightgrey"),pt.cex = 1)
points(plot_dat$plot.pos[plot_dat$XtX>=quantile(plot_dat$XtX,0.99)],
       plot_dat$stacks_AL[plot_dat$XtX>=quantile(plot_dat$XtX,0.99)],
       col=cols["xtx"],cex=1,pch=3,lwd=2)
points(plot_dat$plot.pos[plot_dat$logSalBF>=quantile(plot_dat$logSalBF,0.99)],
       plot_dat$stacks_AL[plot_dat$logSalBF>=quantile(plot_dat$logSalBF,0.99)],
       col=cols["sal"],cex=1,pch=2)
points(plot_dat$plot.pos[rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       plot_dat$stacks_AL[rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       col=cols["perm"],cex=1,pch=4,lwd=2)
points(plot_dat$plot.pos[plot_dat$stacks_AL_P < 0.05 & plot_dat$stacks_LA_P < 0.05 &
                           plot_dat$stacks_TX_P < 0.05 & plot_dat$stacks_FL_P < 0.05],
       plot_dat$stacks_AL[plot_dat$stacks_AL_P < 0.05 & plot_dat$stacks_LA_P < 0.05 &
                           plot_dat$stacks_TX_P < 0.05 & plot_dat$stacks_FL_P < 0.05],
       col=cols["stacks"],cex=1,pch=5,lwd=2)
points(plot_dat$plot.pos[plot_dat$pcadaptQ<0.01],
       plot_dat$stacks_AL[plot_dat$pcadaptQ<0.01],
       col=cols["pc"],cex=1,pch=0,lwd=2)
axis(2,las=1,pos=-1500000)
mtext("ALFW vs. ALST",2,line=1,cex=0.65)
# add the LG labels
midpts<-tapply(plot_dat$plot.pos,plot_dat$Chrom,median)
text(x=midpts[lgs],y=-0.15)

# plot LA
plot_dat<-fst.plot(fw_SNPinfo,scaffs.to.plot = lgs,fst.name = "stacks_LA",chrom.name = "Chrom",bp.name = "Pos",axis.size = 0,pch=19,pt.cols = c("lightgrey",grp7colors[3]),pt.cex = 1)
points(plot_dat$plot.pos[plot_dat$logSalBF>=quantile(plot_dat$logSalBF,0.99)],
       plot_dat$stacks_LA[plot_dat$logSalBF>=quantile(plot_dat$logSalBF,0.99)],
       col=cols["sal"],cex=1,pch=2)
points(plot_dat$plot.pos[plot_dat$XtX>=quantile(plot_dat$XtX,0.99)],
       plot_dat$stacks_LA[plot_dat$XtX>=quantile(plot_dat$XtX,0.99)],
       col=cols["xtx"],cex=1,pch=3,lwd=2)
points(plot_dat$plot.pos[rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       plot_dat$stacks_LA[rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       col=cols["perm"],cex=1,pch=4,lwd=2)
points(plot_dat$plot.pos[plot_dat$stacks_AL_P < 0.05 & plot_dat$stacks_LA_P < 0.05 &
                           plot_dat$stacks_TX_P < 0.05 & plot_dat$stacks_FL_P < 0.05],
       plot_dat$stacks_LA[plot_dat$stacks_AL_P < 0.05 & plot_dat$stacks_LA_P < 0.05 &
                           plot_dat$stacks_TX_P < 0.05 & plot_dat$stacks_FL_P < 0.05],
       col=cols["stacks"],cex=1,pch=5,lwd=2)
points(plot_dat$plot.pos[plot_dat$pcadaptQ<0.01],
       plot_dat$stacks_LA[plot_dat$pcadaptQ<0.01],
       col=cols["pc"],cex=1,pch=0,lwd=2)
axis(2,las=1,pos=-1500000)
mtext("LAFW vs. ALST",2,line=1,cex=0.65)
# add the LG labels
midpts<-tapply(plot_dat$plot.pos,plot_dat$Chrom,median)
text(x=midpts[lgs],y=-0.15)


# FL
plot_dat<-fst.plot(fw_SNPinfo,scaffs.to.plot = lgs,fst.name = "stacks_FL",chrom.name = "Chrom",bp.name = "Pos",axis.size = 0,pch=19,pt.cols = c(grp7colors[6],grp7colors[7]),pt.cex = 1)
points(plot_dat$plot.pos[plot_dat$logSalBF>=quantile(plot_dat$logSalBF,0.99)],
       plot_dat$stacks_FL[plot_dat$logSalBF>=quantile(plot_dat$logSalBF,0.99)],
       col=cols["sal"],cex=1,pch=2)
points(plot_dat$plot.pos[plot_dat$XtX>=quantile(plot_dat$XtX,0.99)],
       plot_dat$stacks_FL[plot_dat$XtX>=quantile(plot_dat$XtX,0.99)],
       col=cols["xtx"],cex=1,pch=3,lwd=2)
points(plot_dat$plot.pos[rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       plot_dat$stacks_FL[rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       col=cols["perm"],cex=1,pch=4,lwd=2)
points(plot_dat$plot.pos[plot_dat$stacks_AL_P < 0.05 & plot_dat$stacks_LA_P < 0.05 &
                           plot_dat$stacks_TX_P < 0.05 & plot_dat$stacks_FL_P < 0.05],
       plot_dat$stacks_FL[plot_dat$stacks_AL_P < 0.05 & plot_dat$stacks_LA_P < 0.05 &
                           plot_dat$stacks_TX_P < 0.05 & plot_dat$stacks_FL_P < 0.05],
       col=cols["stacks"],cex=1,pch=5,lwd=2)
points(plot_dat$plot.pos[plot_dat$pcadaptQ<0.01],
       plot_dat$stacks_FL[plot_dat$pcadaptQ<0.01],
       col=cols["pc"],cex=1,pch=0,lwd=2)
axis(2,las=1,pos=-1500000)
mtext("FLFW vs. FLCC",2,line=1,cex=0.65)
# add the LG labels
midpts<-tapply(plot_dat$plot.pos,plot_dat$Chrom,median)
text(x=midpts[lgs],y=-0.15)

# add outside legend

opar <- par(fig=c(0, 1, 0, 1), oma=c(0, 0, 0, 0),
            mar=c(0, 0, 0, 0), new=TRUE)
on.exit(par(opar))
plot(0, 0, type='n', bty='n', xaxt='n', yaxt='n')
legend("top",c(expression("Permutation"~italic("F")["ST"]),
         expression("Stacks"~italic("F")["ST"]),
         "PCAdapt",expression(italic("X")^T~italic("X")),"Salinity BF"),xjust = 0.5,x.intersp = 0.5,
       col = cols[c("perm","stacks","pc","xtx","sal")],
       pt.bg=cols[c("perm","stacks","pc","xtx","sal")],pch=c(4,5,0,3,2),bty='n',ncol=5)
dev.off()
```

Ok, now I feel pretty good about these aspects - I just need to add text to the doc and add some preliminary dadi analysis. Also, I should update 202_fwsw_reanalysis


# 17 October 2019

Ok, returning to making Figure 1 from yesterday.

```{r source}
source("../../gwscaR/R/gwscaR.R")
source("../../gwscaR/R/gwscaR_plot.R")
source("../../gwscaR/R/gwscaR_utility.R")
source("../../gwscaR/R/gwscaR_fsts.R")
source("../../gwscaR/R/gwscaR_popgen.R")
source("../../gwscaR/R/vcf2dadi.R")
source("../R/203_treemix_plotting_funcs.R")#I've modified these functions
library(knitr)
library(scales)
library(RColorBrewer)
```

```{r}
pop.list<-c("TXSP","TXCC","TXFW","TXCB","LAFW","ALST","ALFW","FLSG","FLKB",
	"FLFD","FLSI","FLAB","FLPB","FLHB","FLCC","FLLG")
pop.labs<-c("TXSP","TXCC","TXFW","TXCB","LAFW","ALST","ALFW","FLSG","FLKB",
            "FLFD","FLSI","FLAB","FLPB","FLHB","FLCC","FLFW")
fw.list<-c("TXFW","LAFW","ALFW","FLLG")
sw.list<-c("TXSP","TXCC","TXCB","ALST","FLSG","FLKB",
	"FLFD","FLSI","FLAB","FLPB","FLHB","FLCC")
lgs<-c("LG1","LG2","LG3","LG4","LG5","LG6","LG7","LG8","LG9","LG10","LG11",
	"LG12","LG13","LG14","LG15","LG16","LG17","LG18","LG19","LG20","LG21",
	"LG22")
lgn<-seq(1,22)
all.colors<-c(rep("black",2),"#2166ac","black","#2166ac","black","#2166ac",
        rep("black",8),"#2166ac")
grp.colors<-c('#762a83','#af8dc3','#e7d4e8','#d9f0d3','#7fbf7b','#1b7837')
col_vector<-c(red='#e6194b', green='#3cb44b', blue='#4363d8',yellow='#ffe119', cyan='#46f0f0',orange='#f58231', teal='#008080', purple='#911eb4',  magenta='#f032e6', lime='#bcf60c', pink='#fabebe',  lavendar='#e6beff', brown='#9a6324', olive='#808000', apricot='#ffd8b1',maroon='#800000', mint='#aaffc3', navy='#000075', beige='#fffac8', grey='#808080', white='#ffffff', black='#000000')

col_vector<-c('#762a83','#762a83',"#2166ac",'#762a83',"#2166ac",'#af8dc3',"#2166ac",'#e7d4e8','#e7d4e8','#e7d4e8','#e7d4e8','#7fbf7b','#1b7837','#1b7837','#1b7837',"#2166ac")
#ppi<-data.frame(Pop=pop.labs,cols = all.colors,pch=c(0,1,21,2,24,3,23,4,5,6,7,9,10,11,12,22))
ppi<-data.frame(Pop=pop.labs,cols = col_vector,pch=rep(c(15,16,17,18),4))
```

^ those are the colors from before, but now I've got up to K=7, so I need more colors

```{r}
grp.colors<-c('#762a83','#af8dc3','#e7d4e8','#d9f0d3','#7fbf7b','#1b7837') 
grp7colors<-c('#762a83','#9970ab','#c2a5cf','#d9f0d3','#a6dba0','#5aae61','#1b7837')
grp5colors<-c('#762a83','#c2a5cf','#a6dba0','#5aae61','#1b7837')
```

And I'll need to update the PCAdapt colors as well. 

```{r}
ind_dat<-read.table("filter_rad_20191014@1654/14_filtered/individuals.qc.stats_20191014@1654.tsv",header=T,
                    stringsAsFactors = F)
pops<-ind_dat$STRATA	
grp<-pops
grp[grp=="TXFW" | grp=="LAFW" | grp=="ALFW" | grp=="FLLG"]<-"freshwater"
grp[grp!="freshwater"]<-"saltwater"

ppi<-data.frame(Pop=pop.labs,
                cols = c(grp7colors[1],grp7colors[1],"#2166ac",grp7colors[1],
                         "#2166ac",grp7colors[3],"#2166ac",grp7colors[4],
                         grp7colors[4],grp7colors[4],grp7colors[4],grp7colors[5],
                         grp7colors[6],grp7colors[6],grp7colors[6],"#2166ac"),
                pch=rep(c(15,16,17,18),4))
ppi[ppi$Pop=="ALFW","pch"]<-3
#colors
pap<-data.frame(Pop=pops,cols=pops,pch=pops,grp=grp,stringsAsFactors = F)
pap$Pop[pap$Pop == "FLLG"]<-"FLFW"
for(i in 1:nrow(pap)){
  pap[i,"cols"]<-as.character(ppi[ppi$Pop %in% pap[i,"Pop"],"cols"])
}
for(i in 1:nrow(pap)){
  pap[i,"pch"]<-as.numeric(ppi[ppi$Pop %in% pap[i,"Pop"],"pch"])
}
write.table(pap,"pcadapt_colp.txt",col.names=TRUE)
```


Now time to load the data

```{r}
#admixture 
admixK5<-read.delim("admixture/admixK5.txt",header = FALSE)
admixK7<-read.delim("admixture/admixK7.txt",header = FALSE)
#pcadapt
pa<-readRDS("fwsw_all_pcadapt.RDS")
pa.props<-round((pa$singular.values/sum(pa$singular.values))*100,2)
pap<-read.delim("pcadapt_colp.txt",sep=' ')
# map
library(jpeg)
img<-readJPEG("all_sites_map.jpeg")

# stuff for treemix
source("../R/203_treemix_plotting_funcs.R") #I've modified the functions from treemix
library(lattice); library(grid); library(RColorBrewer)
poporder<-read.delim("treemix/poporder")
colors<-poporder$colors
poporder<-poporder$poporder

```


```{r}
npop<-length(pop.list)
pseq<-1:npop
m<-matrix(c(rep(1,16),rep(2,6),
            3:18,rep(2,6),
            19:34,rep(2,6),
            rep(35,8),rep(36,8),rep(37,6)),
          nrow=4,ncol=npop+6,byrow = T)
jpeg("../figs/NewPopStructure_v1.jpeg",res=300,height=8,width=10,units="in")
#set the layout
layout(mat=m,heights=c(6,1,1,6))
#MAP
#open an empty plot window with coordinates
par(oma=c(1.5,3.5,1,2),mar=c(0,0,0,0),xpd=NA)
plot(1:14,ty="n",axes=FALSE,xlab="",ylab="",xpd=TRUE)
#specify the position of the image through bottom-left and top-right coords
rasterImage(img,1,1,14,14,xpd=TRUE)

#Treemix
par(mar=c(0,0,0,1))
t2<-plot_tree("treemix/fwsw_k100bFLPBrm2",scale=T,mbar=T,cex = 1.5,
              lwd=2,mig_left=FALSE,disp=0.0002,xlab=FALSE,scadj=0.05)
#STRUCTURE
par(mar=c(1,0,0,0))
plotting.structure(admixK5,5,pop.order = poporder$Pop, pop.list, make.file=FALSE, 
                   xlabcol = all.colors,plot.new=FALSE,
                   colors=grp5colors[c(3,5,4,1,2)],xlabel=FALSE,
                   ylabel=expression(atop(italic(K)==5)),lab.cex=0.85)
plotting.structure(admixK7,7,pop.order = poporder$Pop,pop.labs, make.file=FALSE,
                   plot.new=FALSE,colors=grp7colors[c(6,7,1,2,5,3,4)],xlabel=TRUE,
                   xlabcol = all.colors,
                   ylabel=expression(atop(italic(K)==7)),lab.cex=0.85)
#PCADAPT
par(mar=c(2,2,2,2))
plot(pa$scores[,1],pa$scores[,2],col=alpha(pap$cols,0.5),bg=alpha(pap$cols,0.75),
     pch=as.numeric(pap$pch),	cex=3,bty="L",xlab="",ylab="",cex.axis=1.5)

mtext(paste("PC1 (",pa.props[1],"%)",sep=""),1,line = 2.5,cex=1)
mtext(paste("PC2 (",pa.props[2],"%)",sep=""),2,line = 2.5,cex=1)

plot(pa$scores[,3],pa$scores[,4],col=alpha(pap$cols,0.5),bg=alpha(pap$cols,0.75),pch=as.numeric(pap$pch),
     cex=3,	bty="L",xlab="",ylab="",cex.axis=1.5)

mtext(paste("PC3 (",pa.props[3],"%)",sep=""),1,line = 2.5,cex=1)
mtext(paste("PC4 (",pa.props[4],"%)",sep=""),2,line = 2.5,cex=1)

plot(1:10,ty="n",axes=FALSE,xlab="",ylab="",xpd=TRUE)
legend("bottom", legend=ppi$Pop, pch=as.numeric(ppi$pch), pt.cex=3,cex=1.5,
       col=alpha(ppi$cols, 0.5),pt.bg=alpha(ppi$cols,0.25), ncol=2,bty='n')
dev.off()
```

Something is going on with the colors and I don't know what it is...I hacked it above, now I want to fix the treemix bar (move it to the right) and see about increasing text size and add bootstrap values. I was able to adjust those things, but not the bootstrap stuff. 

```{r}
source("../R/203_treemix_plotting_funcs.R") #I've modified the functions from treemix
t2<-plot_tree("treemix/fwsw_k100bFLPBrm2",scale=T,mbar=T,cex = 1.5,
              lwd=2,mig_left=FALSE,disp=0.0002,xlab=FALSE,scadj=0.1)

```

Not sure how to include the bootstrap values or even where the output is located...maybe the *llik files?

Well let's ignore this, just go with what I've got for now and worry about describing bootstrapping in the text or leave that for future me. I should update the 202_fwsw_reanalysis document next.

Next steps:
* Update text and add figures
* create fst outlier plots

# 16 October 2019

I converted the tped files from radiator output into ped using `~/Programs/plink-1.07-x86_64/plink --tfile radiator_data_20191014@1710 --recode --noweb --allow-no-sex --missing-genotype '00' --out fwsw_all_filt` so that I can run admixture.

Running a first test I get a "PLINK Input file error" message from admixture. But if I turn it into a bed file it works instead, using 
```
~/Programs/plink-1.07-x86_64/plink --file fwsw_all_filt --make-bed --noweb --allow-no-sex --missing-genotype '00' --out fwsw_all_filt
~/Programs/admixture_linux-1.3.0/admixture fwsw_all_filt.bed 2
```

Now I'm working on a script that I can run to test multiple values of K.

The manual isn't clear on whether it's good to run multiple instances of the model to get improved estimates, so I'll have to look at some papers that have used it before and/or tutorials online. for now though I'll run their test of Ks. I've got this working and running in the background at the moment.

Admixture has run successfully! The examples online that I've been able to find don't mention running multiple reps (e.g. [this one](https://gaworkshop.readthedocs.io/en/latest/contents/07_admixture/admixture.html))

So I'll analyze the Ks first

```{r}
admixK<-read.delim("admixture/K_CVs.txt",header = FALSE)
admixK$K<-as.numeric(gsub(".*\\(K=(\\d+)\\).*","\\1",admixK$V1))
admixK$CV<-as.numeric(gsub("^.*\\: (\\d+\\.\\d+)$","\\1",admixK$V1))

admixK<-admixK[order(admixK$K),]

plot(admixK$K,admixK$CV,pch=19,type = "b",lty=1,xlab = "K",ylab="CV",las=1,lwd=2)

```

Looks like K=5 or K=7 are the best, let's look at those outputs.

Adapting code from [the GA workshop](https://gaworkshop.readthedocs.io/en/latest/contents/07_admixture/admixture.html):

```{r}
library(RColorBrewer)
qfile<-"admixture/fwsw_all_filt.5.Q"
famfile<-"admixture/fwsw_all_filt.fam"
poporderFile<-"treemix/poplist"
K<-5

# read files in 
qtbl<-read.table(qfile,stringsAsFactors = F)
famTable<- read.table(famfile,
                      col.names = c("Pop","Ind","Father","Mother","Sex","phenotype"),stringsAsFactors = F)[1:2]
poporder<-read.table(poporderFile,col.names = c("Pop"),stringsAsFactors = F)
poporder$orderNum<-1:nrow(poporder)


# create useful tables
mergedAdmixtureTable <- cbind(qtbl, famTable)
mergedAdmixTabOrderNs <- merge(mergedAdmixtureTable,poporder,by="Pop")
ordered <- mergedAdmixTabOrderNs[order(mergedAdmixTabOrderNs$orderNum),]


plotting.structure(ordered[,1:(ncol(ordered)-2)],k = 5,pop.order = poporder$Pop,make.file = FALSE)
admixK5<-ordered[,1:(ncol(ordered)-2)]
write.table(admixK5,"admixture/admixK5.txt",sep = '\t',quote = FALSE,col.names = TRUE,row.names = FALSE)
```

```{r}
qfile<-"admixture/fwsw_all_filt.7.Q"
famfile<-"admixture/fwsw_all_filt.fam"
poporderFile<-"treemix/poplist"
K<-7

# read files in 
qtbl<-read.table(qfile,stringsAsFactors = F)
famTable<- read.table(famfile,
                      col.names = c("Pop","Ind","Father","Mother","Sex","phenotype"),stringsAsFactors = F)[1:2]
poporder<-read.table(poporderFile,col.names = c("Pop"),stringsAsFactors = F)
poporder$orderNum<-1:nrow(poporder)


# create useful tables
mergedAdmixtureTable <- cbind(qtbl, famTable)
mergedAdmixTabOrderNs <- merge(mergedAdmixtureTable,poporder,by="Pop")
ordered <- mergedAdmixTabOrderNs[order(mergedAdmixTabOrderNs$orderNum),]

par(mar=c(1,0,0,0))
plotting.structure(ordered[,1:(ncol(ordered)-2)],k = 7,pop.order = poporder$Pop,make.file = FALSE)
admixK7<-ordered[,1:(ncol(ordered)-2)]
plotting.structure(admixK7,k = 7,pop.order = poporder$Pop,make.file = FALSE)
write.table(admixK7,"admixture/admixK7.txt",sep = '\t',quote = FALSE,col.names = TRUE,row.names = FALSE)
```

So I could use this code which I put in the reanalysis doc, and change poptree to tree mix and run the PCadapt analysis here...I just need to load some things and do a bit of plotting stuff. 

I need to do the PCAdapt analysis


```{r}
library(pcadapt)
```

````{r pcadapt_choose}
filename<-read.pcadapt("filter_rad_20191014@1654/14_filtered/radiator_data_20191014@1710.vcf",type="vcf")
x<-pcadapt(filename, K=20)
plot(x,option="screeplot") #K=7

```

```{r pcadapt_analyze}
pa<-pcadapt(filename,K=7)
saveRDS(pa,"fwsw_all_pcadapt.RDS")
pa.props<-round((pa$singular.values/sum(pa$singular.values))*100,2)
pa.props

ind_dat<-read.table("filter_rad_20191014@1654/14_filtered/individuals.qc.stats_20191014@1654.tsv",header=T,
                    stringsAsFactors = F)
pops<-ind_dat$STRATA	
grp<-pops
grp[grp=="TXFW" | grp=="LAFW" | grp=="ALFW" | grp=="FLLG"]<-"freshwater"
grp[grp!="freshwater"]<-"saltwater"

#colors
pap<-data.frame(Pop=pops,cols=pops,pch=pops,grp=grp,stringsAsFactors = F)
pap$Pop[pap$Pop == "FLLG"]<-"FLFW"
for(i in 1:nrow(pap)){
  pap[i,"cols"]<-as.character(ppi[ppi$Pop %in% pap[i,"Pop"],"cols"])
}
for(i in 1:nrow(pap)){
  pap[i,"pch"]<-as.numeric(ppi[ppi$Pop %in% pap[i,"Pop"],"pch"])
}
write.table(pap,"pcadapt_colp.txt",col.names=TRUE)

```



```{r}
# setup
library(jpeg)
img<-readJPEG("all_sites_map.jpg")

source("../R/203_treemix_plotting_funcs.R") #I've modified the functions from treemix
library(lattice); library(grid); library(RColorBrewer)
poporder<-read.delim("treemix/poporder")
colors<-poporder$colors
poporder<-poporder$poporder

```


```{r}
npop<-length(pop.list)
pseq<-1:npop
m<-matrix(c(rep(1,16),rep(2,6),
            3:18,rep(2,6),
            19:34,rep(2,6),
            rep(35,8),rep(36,8),rep(37,6)),
          nrow=4,ncol=npop+6,byrow = T)

#set the layout
layout(mat=m,heights=c(6,1,1,6))
#MAP
#open an empty plot window with coordinates
par(oma=c(1.5,3.5,1,2),mar=c(0,0,0,0),xpd=NA)
plot(1:14,ty="n",axes=FALSE,xlab="",ylab="",xpd=TRUE)
#specify the position of the image through bottom-left and top-right coords
rasterImage(img,1,1,14,14,xpd=TRUE)

#Treemix
par(mar=c(0,0,0,1))
t2<-plot_tree("treemix/fwsw_k100bFLPBrm2",plus=0.05,scale=TRUE,mbar=TRUE)
#plot.phylo(pt.subtree,tip.color = pt.colors,cex=2,
#           edge.color = clcolr,edge.width = 2,label.offset = 0.0015)

#STRUCTURE
par(mar=c(1,0,0,0))
plotting.structure(admixK5,5,pop.order = poporder$Pop, pop.list, make.file=FALSE, xlabcol = all.colors,plot.new=FALSE,
                   colors=grp.colors[c(1:5)],xlabel=FALSE,
                   ylabel=expression(atop(italic(K)==5)),lab.cex=0.85)
plotting.structure(admixK7,7,pop.order = poporder$Pop,pop.labs, make.file=FALSE,
                   plot.new=FALSE,colors=grp.colors,xlabel=TRUE,
                   xlabcol = all.colors,
                   ylabel=expression(atop(italic(K)==7)),lab.cex=0.85)
#PCADAPT
par(mar=c(2,2,2,2))
plot(pa$scores[,1],pa$scores[,2],col=alpha(pap$cols,0.5),bg=alpha(pap$cols,0.75),
     pch=as.numeric(pap$pch),	cex=3,bty="L",xlab="",ylab="",cex.axis=1.5)

mtext(paste("PC1 (",pa.props[1],"%)",sep=""),1,line = 2.5,cex=1)
mtext(paste("PC2 (",pa.props[2],"%)",sep=""),2,line = 2.5,cex=1)

plot(pa$scores[,3],pa$scores[,4],col=alpha(pap$cols,0.5),bg=alpha(pap$cols,0.75),pch=as.numeric(pap$pch),
     cex=3,	bty="L",xlab="",ylab="",cex.axis=1.5)

mtext(paste("PC3 (",pa.props[3],"%)",sep=""),1,line = 2.5,cex=1)
mtext(paste("PC4 (",pa.props[4],"%)",sep=""),2,line = 2.5,cex=1)

plot(1:10,ty="n",axes=FALSE,xlab="",ylab="",xpd=TRUE)
legend("bottom", legend=ppi$Pop, pch=as.numeric(ppi$pch), pt.cex=3,cex=1.5,
       col=alpha(ppi$cols, 0.5),pt.bg=alpha(ppi$cols,0.25), ncol=2,bty='n')

```



# 15 October 2019

This morning I would like to re-do treemix but with the new file. Let's see if I can make that happen. RStudio was being glitchy, I think maybe due to cache associated with this document. So let's give this another try. I've managed to install treemix on C001KR remotely, woohoo. So now I just need to write a script to convert the files and run it there. Basically I just have to re-run it as I had before, I think, but improve the analysis. I think I can do this from my laptop, and at the moment I should run structure on this computer.

Ok, running structure: it's got one row with locus names, one column with sample IDs and one with putative pop, and each sample is on two lines.

I'm going to use the admixture model, not using sample locations as prior. Running with K=2 to K=16 with 1 iteration for now. 

Now for treemix:

I'm going to write a script that can be called from the command line, in the run_treemix file.

```{r treemix}
#!/usr/bin/env Rscript
require(devtools)
# need gwscaR tools
devtools::install_github("https://github.com/spflanagan/gwscaR.git")
library(gwscaR)
#source("../../gwscaR/R/gwscaR.R")
#source("../../gwscaR/R/gwscaR_plot.R")
#source("../../gwscaR/R/gwscaR_utility.R")
#source("../../gwscaR/R/gwscaR_fsts.R")
#source("../../gwscaR/R/gwscaR_popgen.R")
#source("../../gwscaR/R/vcf2dadi.R")

# get the input
args = commandArgs(trailingOnly = TRUE)
vcf_name<-args[1]
poplist_file<-args[2]
treemix_name<-args[3]

vcf<-parse.vcf(vcf_name)
poplist<-read.delim(args[2])
tm<-treemix.from.vcf(vcf,poplist)
write.table(tm,treemix.name,col.names=TRUE,row.names=FALSE,quote=F,sep=' ')
```

Saved the above as vcf2treemix.R and included calling it in the run_treemix.sh file.

I'm going to save a file to the treemix directory with the order of populations - did this remotely on C001KR too.
```{r}
poplist<-c("TXSP","TXCC","TXFW","TXCB","LAFW","ALST",
            "ALFW","FLSG","FLKB","FLFD","FLSI","FLAB",
            "FLPB","FLHB","FLCC","FLLG")
write.table(poplist,"treemix/poplist",sep='\n',quote=FALSE,col.names = FALSE,row.names = FALSE)
```

Ok, I've had to make a few changes to get it to run properly (and now I'm motivated to try to fix gwscaR once and for all!) but it looks like it's working now. And crap, that ran really quickly!

So now can I analyse it from afar? Best thing might be to just move the files. Now taking things from 202_treemix_analysis.R...this chunk I already did and have the poporder file in my directory

```{r}
poporder<-c("TXSP","TXCC","TXFW","TXCB","LAFW","ALST",
            "ALFW","FLSG","FLKB","FLFD","FLSI","FLAB",
            "FLPB","FLHB","FLCC","FLLG")
colors<-poporder
colors[colors %in% "FLLG"]<-grp.colors[6]
colors[colors %in% c("FLPB","FLHB","FLCC")]<-grp.colors[6]
colors[colors %in% c("FLAB")]<-grp.colors[5]
colors[colors %in% c("FLSI","FLFD","FLKB","FLSG")]<-grp.colors[3]
colors[colors %in% c("ALST","ALFW","LAFW")]<-grp.colors[2]
colors[colors %in% c("TXSP","TXCC","TXFW","TXCB")]<-grp.colors[1]
write.table(cbind(poporder,colors),"poporder",quote=F,sep='\t')
```

```{r}
source("../R/203_treemix_plotting_funcs.R") #I've modified the functions from treemix
library(lattice); library(grid); library(RColorBrewer)
poporder<-read.delim("treemix/poporder")
colors<-poporder$colors
poporder<-poporder$poporder
par(mfrow=c(1,2),oma=c(2,2,2,2),mar=c(2,2,2,2))
tree<-plot_tree("treemix/",plotmig=F,scale=F,mbar=F,plus=0.05)
mtext("Drift parameter",1,line=2)
resid<-plot_resid("fwsw.basic","poporder",wcols="rb")

nr<-treemix.cov.plot("treemix/fwsw_k100b",poporder)
m0<-treemix.cov.plot("treemix/fwsw_k100bFLPBr",poporder,split=c(1,1,3,2),more=TRUE)
m1<-treemix.cov.plot("treemix/fwsw_k100bFLPBrm1",poporder,split=c(2,1,3,2),more=TRUE)
m2<-treemix.cov.plot("treemix/fwsw_k100bFLPBrm2",poporder,split=c(3,1,3,2),more=TRUE)
m3<-treemix.cov.plot("treemix/fwsw_k100bFLPBrm3",poporder,split=c(1,2,3,2),more=TRUE)
m4<-treemix.cov.plot("treemix/fwsw_k100bFLPBrm4",poporder,split=c(2,2,3,2),more=TRUE)
m5<-treemix.cov.plot("treemix/fwsw_k100bFLPBrm5",poporder,split=c(3,2,3,2),more=FALSE)

# visualize residuals
png("treemix/treemix-residuals_FLPB.png",height=8,width=8,units="in",res=300)
par(mfrow=c(3,3))
t0<-plot_resid("treemix/fwsw_k100b",  "treemix/poplist")
r0<-plot_resid("treemix/fwsw_k100bFLPBr",  "treemix/poplist")
r1<-plot_resid("treemix/fwsw_k100bFLPBrm1","treemix/poplist")
r2<-plot_resid("treemix/fwsw_k100bFLPBrm2","treemix/poplist")
r3<-plot_resid("treemix/fwsw_k100bFLPBrm3","treemix/poplist")
r4<-plot_resid("treemix/fwsw_k100bFLPBrm4","treemix/poplist")
r5<-plot_resid("treemix/fwsw_k100bFLPBrm5","treemix/poplist")
dev.off()

# look at the trees
png("treemix/migration_trees_treemix_FLPB.png",height=6,width=11,units="in",res=300)
par(mfrow=c(3,3),mar=c(1,1,1,1),oma=c(1,1,1,1))
r0<-plot_tree("treemix/fwsw_k100b",plus=0.05,plotmig = F,scale=T,mbar=T)
t0<-plot_tree("treemix/fwsw_k100bFLPBr",plotmig = F,plus=0.05,scale=T,mbar=F)
t1<-plot_tree("treemix/fwsw_k100bFLPBrm1",plus=0.05,scale=F,mbar=F)
t2<-plot_tree("treemix/fwsw_k100bFLPBrm2",plus=0.05,scale=F,mbar=F)
t3<-plot_tree("treemix/fwsw_k100bFLPBrm3",plus=0.05,scale=F,mbar=F)
t4<-plot_tree("treemix/fwsw_k100bFLPBrm4",plus=0.05,scale=F,mbar=F)
t5<-plot_tree("treemix/fwsw_k100bFLPBrm5",plus=0.05,scale=F,mbar=F)
dev.off()

# Evaluate migration p-values
nort0<-read.table(gzfile("treemix/fwsw_k100b.treeout.gz"), as.is  = T, comment.char = "", quote = "")
tree0<-read.table(gzfile("treemix/fwsw_k100bFLPBr.treeout.gz"), as.is  = T, comment.char = "", quote = "")
tree1<-read.table(gzfile("treemix/fwsw_k100bFLPBrm1.treeout.gz"), as.is  = T, comment.char = "", quote = "",skip=1)
tree2<-read.table(gzfile("treemix/fwsw_k100bFLPBrm2.treeout.gz"), as.is  = T, comment.char = "", quote = "",skip=1)
tree3<-read.table(gzfile("treemix/fwsw_k100bFLPBrm3.treeout.gz"), as.is  = T, comment.char = "", quote = "",skip=1)
tree4<-read.table(gzfile("treemix/fwsw_k100bFLPBrm4.treeout.gz"), as.is  = T, comment.char = "", quote = "",skip=1)
tree5<-read.table(gzfile("treemix/fwsw_k100bFLPBrm5.treeout.gz"), as.is  = T, comment.char = "", quote = "",skip=1)

d <- read.table("fwsw.k100bFLPBrm3.vertices.gz", as.is  = T, comment.char = "", quote = "")
branch.cols<-rep("black",nrow(d))
branch.cols[d[,2] %in% c("TXFW","ALFW","LAFW","FLLG")]<-"cornflowerblue"

tip.names<-as.vector(d[d[,5] == "TIP",2])
tip.names<-data.frame(Original=tip.names,Replacement=tip.names,stringsAsFactors = FALSE)
tip.names$Replacement[tip.names$Replacement=="FLLG"]<-"FLFW"

png("FWSW_treemix_m3_FLPB.png",height=7,width=7,units="in",res=300)
t3<-plot_tree("fwsw.k100bFLPBrm3","poporder",plus=0.05,scale=F,mbar=F,arrow=0.1,tip.order = tip.names)
ybar<-0.01
mcols = rev( heat.colors(150) )
mcols = mcols[50:length(mcols)]
ymi = ybar+0.15
yma = ybar+0.35
l = 0.2
w = l/100
xma = max(t3$d$x/20)
rect( rep(0.15, 100), ymi+(0:99)*w, rep(0.15+xma, 100), ymi+(1:100)*w, col = mcols, border = mcols)
text(0.15+xma+0.001, ymi, lab = "0", adj = 0, cex = 0.7)
text(0.15+xma+0.001, yma, lab = "0.5", adj = 0, cex =0.7)
text(0.15, yma+0.06, lab = "Migration", adj = 0 , cex = 0.6)
text(0.15, yma+0.03, lab = "weight", adj = 0 , cex = 0.6)
dev.off()

```

Ok, but how do I actually choose which number of migration edges to choose? Well, apparently [there's an R package for that!](https://rdrr.io/cran/OptM/#vignettes)

```{r}
tmOpt<-optM("treemix")
plot_optM(tmOpt)
```

Huh, apparently it's recommended to run more than 2 iterations for each m. I can do that! And I have - it chooses m=2 as the best. Woohoo!


What's next?

A few things on my mind:
* admixture
* plot Fsts (like bayenv)
* analyse dadi that I've got so far
* reorganize the code

I think I'll look into running admixture first - how much file conversion etc does it require?


# 14 October 2019

At the moment I want to try to improve the plotting so I can send something nice to Adam and Emily. The first order of business is to improve the plots from Friday - I want to show both types of Bayenv outliers on both graphs. 


```{r plotOutliersSetup}
library(scales)
fw_SNPinfo<-readRDS("fw_SNPinfo.RDS")
cols<-c(perm=alpha('#e41a1c',0.75),sal=alpha('#377eb8',0.75),pc=alpha('#4daf4a',0.75),xtx=alpha('#984ea3',0.75),stacks=alpha('#ff7f00',0.75))
```
```{r plotOutliers}
par(mfrow=c(2,1),oma=c(1,2,1,1),mar=c(2,2,1,1),xpd=TRUE)
# plot XtX
plot_dat<-fst.plot(fw_SNPinfo,scaffs.to.plot = lgs,fst.name = "XtX",chrom.name = "Chrom",bp.name = "Pos",axis.size = 0,pch=19)
points(plot_dat$plot.pos[plot_dat$XtX>=quantile(plot_dat$XtX,0.99)],
       plot_dat$XtX[plot_dat$XtX>=quantile(plot_dat$XtX,0.99)],
       col=cols["xtx"],cex=0.75,pch=19)
points(plot_dat$plot.pos[plot_dat$logSalBF>=quantile(plot_dat$logSalBF,0.99)],
       plot_dat$XtX[plot_dat$logSalBF>=quantile(plot_dat$logSalBF,0.99)],
       col=cols["sal"],cex=0.85,pch=17)
points(plot_dat$plot.pos[rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       plot_dat$XtX[rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       col=cols["perm"],cex=1,pch=4,lwd=2)
points(plot_dat$plot.pos[plot_dat$stacks_AL < 0.05 & plot_dat$stacks_LA < 0.05 &
                           plot_dat$stacks_TX < 0.05 & plot_dat$stacks_FL < 0.05],
       plot_dat$XtX[plot_dat$stacks_AL < 0.05 & plot_dat$stacks_LA < 0.05 &
                           plot_dat$stacks_TX < 0.05 & plot_dat$stacks_FL < 0.05],
       col=cols["stacks"],cex=1,pch=5,lwd=2)
points(plot_dat$plot.pos[plot_dat$pcadaptQ<0.01],
       plot_dat$XtX[plot_dat$pcadaptQ<0.01],
       col=cols["pc"],cex=1,pch=0,lwd=2)
axis(2,las=1)
mtext(expression(italic("X")^"T"~italic("X")),2,line=2)

# add the LG labels
midpts<-tapply(plot_dat$plot.pos,plot_dat$Chrom,median)
text(x=midpts[lgs],y=0)

# plot Bayes Factors
plot_dat<-fst.plot(plot_dat,scaffs.to.plot = lgs,fst.name = "logSalBF",chrom.name = "Chrom",bp.name = "Pos",axis.size = 0,pch=19)
points(plot_dat$plot.pos[plot_dat$logSalBF>=quantile(plot_dat$logSalBF,0.99)],
       plot_dat$logSalBF[plot_dat$logSalBF>=quantile(plot_dat$logSalBF,0.99)],
       col=cols["sal"],cex=0.85,pch=17)
points(plot_dat$plot.pos[plot_dat$XtX>=quantile(plot_dat$XtX,0.99)],
       plot_dat$logSalBF[plot_dat$XtX>=quantile(plot_dat$XtX,0.99)],
       col=cols["xtx"],cex=0.75,pch=19)
points(plot_dat$plot.pos[rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       plot_dat$logSalBF[rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       col=cols["perm"],cex=1,pch=4,lwd=2)
points(plot_dat$plot.pos[plot_dat$stacks_AL < 0.05 & plot_dat$stacks_LA < 0.05 &
                           plot_dat$stacks_TX < 0.05 & plot_dat$stacks_FL < 0.05],
       plot_dat$logSalBF[plot_dat$stacks_AL < 0.05 & plot_dat$stacks_LA < 0.05 &
                           plot_dat$stacks_TX < 0.05 & plot_dat$stacks_FL < 0.05],
       col=cols["stacks"],cex=1,pch=5,lwd=2)
points(plot_dat$plot.pos[plot_dat$pcadaptQ<0.01],
       plot_dat$logSalBF[plot_dat$pcadaptQ<0.01],
       col=cols["pc"],cex=1,pch=0,lwd=2)
axis(2,las=1)
mtext("log(Salinity Bayes Factors)",2,line=2)

# add the LG labels
midpts<-tapply(plot_dat$plot.pos,plot_dat$Chrom,median)
text(x=midpts[lgs],y=-5)

# add outside legend

opar <- par(fig=c(0, 1, 0, 1), oma=c(0, 0, 0, 0),
            mar=c(0, 0, 0, 0), new=TRUE)
on.exit(par(opar))
plot(0, 0, type='n', bty='n', xaxt='n', yaxt='n')
legend("top",c(expression("Permutation"~italic("F")["ST"]),
         expression("Stacks"~italic("F")["ST"]),
         "PCAdapt",expression(italic("X")^T~italic("X")),"Salinity BF"),xjust = 0.5,x.intersp = 0.5,
       col = cols[c("perm","stacks","pc","xtx","sal")],
       pt.bg=cols[c("perm","stacks","pc","xtx","sal")],pch=c(4,5,0,19,17),bty='n',ncol=3)
```

Ok, that's better. But what does this tell me? the outliers associated with salinity are generally not those associated withfst or pcadapt outliers, but they are sometimes with the xtx statistic from bayenv. This is not incredibly useful information. What do I do with this?

The other thing is that I've re-run populations to require the loci be present in 16 populations and 75% of individuals. These results are in populations_all/

It seems to have 104150 SNPs (using `grep -v "#" batch_2.vcf | wc -l`), but this seems like a lot! I need to prune for HWE anyway, and I need to make sure to do this on a population-by-population level. Last time I did this using plink but I wonder if vcftools or similar would be better. I'm going to look into some R packages 
1. [HardyWeinberg](https://cran.r-project.org/web/packages/HardyWeinberg/vignettes/HardyWeinberg.pdf), but it doesn't seem to play all that nicely with regularly formatted data
2. [snpStats](https://www.bioconductor.org/packages/release/bioc/html/snpStats.html), which seems to be designed for GWAS but might work well
3. [adegenet](http://adegenet.r-forge.r-project.org/files/tutorial-basics.pdf) tests for HWE but I'm not sure if it does so per population. But I could probably make it do so.
4. [radiator](https://rdrr.io/github/thierrygosselin/radiator/man/filter_hwe.html) seems to be focused on RADseq so this could be useful.

I might try radiator

```{r installRadiator}
if (!require("devtools")) install.packages("devtools") # to install
install.packages("tidyverse")
devtools::install_github("thierrygosselin/grur")
devtools::install_github("thierrygosselin/assigner")
```

First I need to create the strata file (stacks map with headers):
```{r}
vcf<-parse.vcf("stacks/populations_all/batch_2.vcf")
strata<-data.frame(INDIVIDUALS=colnames(vcf)[10:ncol(vcf)],
                   STRATA=gsub("sample_(\\w{4}).*","\\1",colnames(vcf)[10:ncol(vcf)]))
write.table(strata,"../fwsw_pops_map.txt",sep='\t',quote = FALSE,row.names = FALSE,col.names = TRUE)
```

It has filter_rad, described as 'ONE FUNCTION TO RULE THEM ALL'. It's interactive and apparently enough?

```{r}
data<-radiator::filter_rad(data="stacks/populations_all/batch_2.vcf",
                           strata="../fwsw_pops_map.txt")
```

I'm getting an error message saying that the function arguments names have changed, but what I'm doing matches the information in the help function...Ah, this was because I didn't have the right packages installed.

According to this, it's going to blacklist individuals based on missingness threshold of 0.0730675, and this removed 141 individuals! It also removed 106 loci with monomorphic markers. choosing MAC threshold of 5, choosing coverage between 35 and 50. ...ok this might be too stringent it's left with only 401 loci. I think I'll do this again but in a better way. It's too bad it doesn't turn it into a single command that I could run multiple times in a non-interactive way. Here's what I did:

```
################################################################################
############################# radiator::filter_rad #############################
################################################################################
The function arguments names have changed: please read documentation

Execution date@time: 20191014@0939
Folder created: filter_rad_20191014@0939
Function call and arguments stored in: radiator_filter_rad_args_20191014@0939.tsv
File written: random.seed (835230)
Filters parameters file generated: filters_parameters_20191014@0939.tsv

Reading a large VCF...you actually have time for coffee or tea!

Data summary: 
    number of samples: 698
    number of markers: 104150
done! timing: 6 sec

Generating individual stats...
Generating markers stats...


Number of chromosome/contig/scaffold: 539
Number of locus: 11155
Number of markers: 104150
Number of populations: 16
Number of individuals: 698

Number of ind/pop:
ALFW = 48
ALST = 47
FLAB = 42
FLCC = 41
FLFD = 40
FLHB = 41
FLKB = 42
FLLG = 47
FLPB = 43
FLSG = 44
FLSI = 45
LAFW = 48
TXCB = 36
TXCC = 41
TXFW = 31
TXSP = 62

Number of duplicate id: 0
radiator Genomic Data Structure (GDS) file: radiator_20191014@0939.gds
################################################################################
########################### radiator::filter_monomorphic #######################
################################################################################
Execution date@time: 20191014@0941
Function call and arguments stored in: radiator_filter_monomorphic_args_20191014@0941.tsv
Filters parameters file: initiated
File written: blacklist.monomorphic.markers_20191014@0941.tsv
Synchronizing markers.meta
File written: whitelist.polymorphic.markers_20191014@0941.tsv
Filters parameters file: updated
################################### RESULTS ####################################

Filter monomorphic markers
Number of individuals / strata / chrom / locus / SNP:
    Before: 698 / 16 / 539 / 11155 / 104150
    Blacklisted: 0 / 0 / 1 / 3 / 10
    After: 698 / 16 / 538 / 11152 / 104140

Computation time, overall: 3 sec
######################## filter_monomorphic completed ##########################
################################################################################
######################## radiator::filter_common_markers #######################
################################################################################
Execution date@time: 20191014@0941
Function call and arguments stored in: radiator_filter_common_markers_args_20191014@0941.tsv
Filters parameters file: initiated
Scanning for common markers...
Generating UpSet plot to visualize markers in common
File written: whitelist.common.markers_20191014@0941.tsv
Filters parameters file: updated
################################### RESULTS ####################################

Filter common markers:
Number of individuals / strata / chrom / locus / SNP:
    Before: 698 / 16 / 538 / 11152 / 104140
    Blacklisted: 0 / 0 / 0 / 0 / 0
    After: 698 / 16 / 538 / 11152 / 104140

Computation time, overall: 11 sec
####################### filter_common_markers completed ########################
################################################################################
######################### radiator::filter_individuals #########################
################################################################################
Execution date@time: 20191014@0941
Function call and arguments stored in: radiator_filter_individuals_args_20191014@0941.tsv
Interactive mode: on

Step 1. Visualization
Step 2. Missingness
Step 3. Heterozygosity
Step 4. Total Coverage (if available)


Filters parameters file: initiated

Step 1. Visualization of samples QC

File written: individuals qc info and stats summary
File written: individuals qc plot

Step 2. Filtering markers based individual missingness/genotyping

Do you want to blacklist samples based on missingness ? (y/n):
y
2 options to blacklist samples:
1. based on the outlier statistics
2. enter your own threshold
1

Removing outliers individuals based on genotyping statistics: 0.0730675
Filters parameters file: updated
################################### RESULTS ####################################

Filter individuals based on missingness: 0.0730675
Number of individuals / strata / chrom / locus / SNP:
    Before: 698 / 16 / 538 / 11152 / 104140
    Blacklisted: 141 / 0 / 0 / 0 / 0
    After: 557 / 16 / 538 / 11152 / 104140

Step 3. Filtering markers based on individual heterozygosity

Do you want to blacklist samples based on heterozygosity ? (y/n):
y
2 options to blacklist samples:
1. based on the outlier statistics
2. enter your own threshold
1

Removing outliers individuals based on heterozygosity statistics: 0.005222 / 0.02875475
    number of individuals blacklisted based on heterozygosity: 14
Filters parameters file: updated
################################### RESULTS ####################################

Filter individuals based on heterozygosity: 0.005222 0.02875475
Number of individuals / strata / chrom / locus / SNP:
    Before: 557 / 16 / 538 / 11152 / 104140
    Blacklisted: 0 / 0 / 0 / 0 / 0
    After: 557 / 16 / 538 / 11152 / 104140

Filter monomorphic markers
Number of individuals / strata / chrom / locus / SNP:
    Blacklisted: 0 / 0 / 6 / 106 / 5428

Computation time, overall: 139 sec
########################### completed filter_individuals #######################
################################################################################
############################## radiator::filter_mac ############################
################################################################################
Execution date@time: 20191014@0944
Function call and arguments stored in: radiator_filter_mac_args_20191014@0944.tsv
Interactive mode: on

Step 1. Visualization and helper table
Step 2. Filtering markers based on MAC


Importing data ...
Filters parameters file: initiated
Calculating GLOBAL MAC
File written: maf.global.tsv

Step 1. MAC visualization and helper table

File written: mac.summary.stats.tsv
MAC range: [1 - 556]
MAF range: [0.0009 - 0.4991]
Generating MAC helper table...
File written: maf.helper.table.tsv

Step 2. Filtering markers based on MAC

Choose the filter.mac threshold: 
5
File written: whitelist.markers.mac.tsv
File written: blacklist.markers.mac.tsv
Filters parameters file: updated
################################### RESULTS ####################################

Filter mac threshold: 5
Number of individuals / strata / chrom / locus / SNP:
    Before: 557 / 16 / 532 / 11046 / 98712
    Blacklisted: 0 / 0 / 140 / 2953 / 75467
    After: 557 / 16 / 392 / 8093 / 23245

Computation time, overall: 111 sec
############################ completed filter_mac ##############################
################################################################################
########################### radiator::filter_coverage ##########################
################################################################################
Execution date@time: 20191014@0946
Function call and arguments stored in: radiator_filter_coverage_args_20191014@0946.tsv
Interactive mode: on

Step 1. Visualization and helper table
Step 2. Filtering markers based on total coverage


Importing data ...
Filters parameters file: initiated

Step 1. Coverage visualization and helper table

Generating coverage statistics
Generating coverage statistics: without outliers
Generating mean coverage helper table...
Files written: helper tables and plots

Step 2. Filtering markers based on mean coverage

Choose the min mean coverage threshold(e.g. 7 or 10): 
35
Choose the max mean coverage threshold (e.g. 100 or 300): 
50
File written: blacklist.markers.coverage_20191014@0946.tsv
File written: whitelist.markers.coverage_20191014@0946.tsv
Filters parameters file: updated
################################### RESULTS ####################################

Filter mean coverage thresholds: 35 / 50
Number of individuals / strata / chrom / locus / SNP:
    Before: 557 / 16 / 392 / 8093 / 23245
    Blacklisted: 0 / 0 / 309 / 7673 / 21758
    After: 557 / 16 / 83 / 420 / 1487

Computation time, overall: 63 sec
########################## completed filter_coverage ###########################
################################################################################
######################### radiator::filter_genotyping ##########################
################################################################################
Execution date@time: 20191014@0947
Function call and arguments stored in: radiator_filter_genotyping_args_20191014@0947.tsv
Interactive mode: on

Step 1. Visualization and helper table
Step 2. Filtering markers based on maximum missing proportion allowed


Importing data ...
Filters parameters file: initiated

Step 1. Missing visualization and helper table

Generating statistics
Generating missingness/genotyping helper table...
File written: markers.pop.missing.helper.table.tsv
Files written: helper tables and plots

Step 2. Filtering markers based on maximum missing proportion

Choose the maximum missing proportion allowed: 
0.1

Removing markers based on genotyping statistic: 0.1
File written: blacklist.markers.genotyping_20191014@0947.tsv
File written: whitelist.markers.genotyping_20191014@0947.tsv
Filters parameters file: updated
################################### RESULTS ####################################

Filter genotyping threshold: 0.1
Number of individuals / strata / chrom / locus / SNP:
    Before: 557 / 16 / 83 / 420 / 1487
    Blacklisted: 0 / 0 / 0 / 0 / 1
    After: 557 / 16 / 83 / 420 / 1486

Computation time, overall: 59 sec
######################## completed filter_genotyping ###########################
################################################################################
######################### radiator::filter_snp_position_read ###################
################################################################################
Execution date@time: 20191014@0948
Function call and arguments stored in: radiator_filter_snp_position_read_args_20191014@0948.tsv
2 steps to visualize and filter the data based on the number of SNP on the read/locus:
Step 1. Visualization (boxplot, distribution
Step 2. Threshold selection
Filters parameters file: initiated
COL info required, returning data

Computation time, overall: 0 sec
##################### completed filter_snp_position_read #######################
################################################################################
############################ radiator::filter_snp_number #######################
################################################################################
Execution date@time: 20191014@0948
Function call and arguments stored in: radiator_filter_snp_number_args_20191014@0948.tsv
Interactive mode: on
2 steps to visualize and filter the data based on the number of SNP on the read/locus:
Step 1. Impact of SNP number per read/locus (on individual genotypes and locus/snp number potentially filtered)
Step 2. Choose the filtering thresholds
Filters parameters file: initiated
Generating statistics
Generating helper table...
Files written: helper tables and plots

Step 2. Filtering markers based on the maximum of SNPs per locus

Do you still want to blacklist markers? (y/n):
y
2 options to blacklist SNPs:
1. based on the outlier statistics
2. enter your own threshold
2
Enter the maximum number of SNP per locus allowed:
10

Removing markers based on the number of SNPs per locus statistic: 10
File written: whitelist.markers.genotyping.tsv
File written: blacklist.markers.genotyping.tsv
Filters parameters file: updated
################################### RESULTS ####################################

Filter SNPs per locus threshold: 10
Number of individuals / strata / chrom / locus / SNP:
    Before: 557 / 16 / 83 / 420 / 1486
    Blacklisted: 0 / 0 / 0 / 3 / 38
    After: 557 / 16 / 83 / 417 / 1448

Computation time, overall: 58 sec
######################### completed filter_snp_number ##########################
################################################################################
############################## radiator::filter_ld #############################
################################################################################
Execution date@time: 20191014@0949
Function call and arguments stored in: radiator_filter_ld_args_20191014@0949.tsv

Interactive mode: on

Step 1. Short distance LD threshold selection
Step 2. Filtering markers based on short distance LD
Step 3. Long distance LD pruning selection
Step 4. Threshold selection
Step 5. Filtering markers based on long distance LD


Filters parameters file: initiated
Minimizing short distance LD...
    The range in the number of SNP/locus is: 1-10

Step 1. Short distance LD threshold selection
the goal is to keep only 1 SNP per read/locus
Choose the filter.short.ld threshold
Options include:
1: mac (Not sure ? use mac...)
2: random
3: first
4: middle
5: last
1

Step 2. Filtering markers based on short distance LD
filter.short.ld = mac
File written: whitelist.short.ld.tsv
File written: blacklist.short.ld.tsv
Filters parameters file: updated
################################### RESULTS ####################################

Filter short ld threshold: mac
Number of individuals / strata / chrom / locus / SNP:
    Before: 557 / 16 / 83 / 417 / 1448
    Blacklisted: 0 / 0 / 0 / 0 / 1031
    After: 557 / 16 / 83 / 417 / 417

Do you want to continue filtering using long distance ld  ? (y/n):
y

Step 3. Long distance LD pruning selection
With a reference genome, pruning is done by chromosome/scaffolds
Pruning method can randomly choose to keep 1 SNP or
select the SNP based on missing data statistics

Do you want to use missing data statistics ? (y/n):
y

Long distance LD pruning with missing data
Computing LD by CHROM/scaffold (n = 83), with several LD thresholds
Chrom: LG1 SNPs number: 32    (1/83)
    LD threshold: 0.1, SNPs blacklisted: 4
    LD threshold: 0.2, SNPs blacklisted: 1
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: LG10 SNPs number: 14    (2/83)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: LG11 SNPs number: 12    (3/83)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: LG12 SNPs number: 15    (4/83)
    LD threshold: 0.1, SNPs blacklisted: 2
    LD threshold: 0.2, SNPs blacklisted: 1
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: LG13 SNPs number: 14    (5/83)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: LG14 SNPs number: 12    (6/83)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: LG15 SNPs number: 11    (7/83)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: LG16 SNPs number: 14    (8/83)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: LG17 SNPs number: 11    (9/83)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: LG18 SNPs number: 11    (10/83)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: LG19 SNPs number: 11    (11/83)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: LG2 SNPs number: 30    (12/83)
    LD threshold: 0.1, SNPs blacklisted: 3
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: LG20 SNPs number: 12    (13/83)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: LG21 SNPs number: 10    (14/83)
    LD threshold: 0.1, SNPs blacklisted: 1
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: LG22 SNPs number: 1    (15/83)
    SNPs blacklisted: 0
Chrom: LG3 SNPs number: 32    (16/83)
    LD threshold: 0.1, SNPs blacklisted: 1
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: LG4 SNPs number: 26    (17/83)
    LD threshold: 0.1, SNPs blacklisted: 1
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: LG5 SNPs number: 16    (18/83)
    LD threshold: 0.1, SNPs blacklisted: 1
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: LG6 SNPs number: 19    (19/83)
    LD threshold: 0.1, SNPs blacklisted: 1
    LD threshold: 0.2, SNPs blacklisted: 1
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: LG7 SNPs number: 16    (20/83)
    LD threshold: 0.1, SNPs blacklisted: 2
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: LG8 SNPs number: 19    (21/83)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: LG9 SNPs number: 10    (22/83)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_1015 SNPs number: 1    (23/83)
    SNPs blacklisted: 0
Chrom: scaffold_1043 SNPs number: 1    (24/83)
    SNPs blacklisted: 0
Chrom: scaffold_1063 SNPs number: 1    (25/83)
    SNPs blacklisted: 0
Chrom: scaffold_1070 SNPs number: 1    (26/83)
    SNPs blacklisted: 0
Chrom: scaffold_1087 SNPs number: 1    (27/83)
    SNPs blacklisted: 0
Chrom: scaffold_1103 SNPs number: 1    (28/83)
    SNPs blacklisted: 0
Chrom: scaffold_1108 SNPs number: 1    (29/83)
    SNPs blacklisted: 0
Chrom: scaffold_1148 SNPs number: 1    (30/83)
    SNPs blacklisted: 0
Chrom: scaffold_1174 SNPs number: 1    (31/83)
    SNPs blacklisted: 0
Chrom: scaffold_1735 SNPs number: 1    (32/83)
    SNPs blacklisted: 0
Chrom: scaffold_174 SNPs number: 1    (33/83)
    SNPs blacklisted: 0
Chrom: scaffold_1760 SNPs number: 1    (34/83)
    SNPs blacklisted: 0
Chrom: scaffold_1877 SNPs number: 1    (35/83)
    SNPs blacklisted: 0
Chrom: scaffold_1899 SNPs number: 1    (36/83)
    SNPs blacklisted: 0
Chrom: scaffold_247 SNPs number: 1    (37/83)
    SNPs blacklisted: 0
Chrom: scaffold_304 SNPs number: 1    (38/83)
    SNPs blacklisted: 0
Chrom: scaffold_332 SNPs number: 1    (39/83)
    SNPs blacklisted: 0
Chrom: scaffold_387 SNPs number: 1    (40/83)
    SNPs blacklisted: 0
Chrom: scaffold_391 SNPs number: 1    (41/83)
    SNPs blacklisted: 0
Chrom: scaffold_395 SNPs number: 1    (42/83)
    SNPs blacklisted: 0
Chrom: scaffold_396 SNPs number: 1    (43/83)
    SNPs blacklisted: 0
Chrom: scaffold_407 SNPs number: 2    (44/83)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_434 SNPs number: 2    (45/83)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_450 SNPs number: 1    (46/83)
    SNPs blacklisted: 0
Chrom: scaffold_468 SNPs number: 2    (47/83)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_473 SNPs number: 2    (48/83)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_477 SNPs number: 1    (49/83)
    SNPs blacklisted: 0
Chrom: scaffold_479 SNPs number: 1    (50/83)
    SNPs blacklisted: 0
Chrom: scaffold_480 SNPs number: 1    (51/83)
    SNPs blacklisted: 0
Chrom: scaffold_484 SNPs number: 1    (52/83)
    SNPs blacklisted: 0
Chrom: scaffold_493 SNPs number: 1    (53/83)
    SNPs blacklisted: 0
Chrom: scaffold_497 SNPs number: 1    (54/83)
    SNPs blacklisted: 0
Chrom: scaffold_514 SNPs number: 1    (55/83)
    SNPs blacklisted: 0
Chrom: scaffold_520 SNPs number: 1    (56/83)
    SNPs blacklisted: 0
Chrom: scaffold_523 SNPs number: 1    (57/83)
    SNPs blacklisted: 0
Chrom: scaffold_546 SNPs number: 1    (58/83)
    SNPs blacklisted: 0
Chrom: scaffold_556 SNPs number: 1    (59/83)
    SNPs blacklisted: 0
Chrom: scaffold_557 SNPs number: 1    (60/83)
    SNPs blacklisted: 0
Chrom: scaffold_585 SNPs number: 1    (61/83)
    SNPs blacklisted: 0
Chrom: scaffold_587 SNPs number: 1    (62/83)
    SNPs blacklisted: 0
Chrom: scaffold_591 SNPs number: 1    (63/83)
    SNPs blacklisted: 0
Chrom: scaffold_604 SNPs number: 1    (64/83)
    SNPs blacklisted: 0
Chrom: scaffold_606 SNPs number: 1    (65/83)
    SNPs blacklisted: 0
Chrom: scaffold_609 SNPs number: 1    (66/83)
    SNPs blacklisted: 0
Chrom: scaffold_612 SNPs number: 2    (67/83)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_654 SNPs number: 1    (68/83)
    SNPs blacklisted: 0
Chrom: scaffold_660 SNPs number: 2    (69/83)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_662 SNPs number: 2    (70/83)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_673 SNPs number: 1    (71/83)
    SNPs blacklisted: 0
Chrom: scaffold_702 SNPs number: 1    (72/83)
    SNPs blacklisted: 0
Chrom: scaffold_720 SNPs number: 1    (73/83)
    SNPs blacklisted: 0
Chrom: scaffold_728 SNPs number: 1    (74/83)
    SNPs blacklisted: 0
Chrom: scaffold_739 SNPs number: 1    (75/83)
    SNPs blacklisted: 0
Chrom: scaffold_828 SNPs number: 1    (76/83)
    SNPs blacklisted: 0
Chrom: scaffold_837 SNPs number: 1    (77/83)
    SNPs blacklisted: 0
Chrom: scaffold_839 SNPs number: 1    (78/83)
    SNPs blacklisted: 0
Chrom: scaffold_849 SNPs number: 2    (79/83)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_850 SNPs number: 1    (80/83)
    SNPs blacklisted: 0
Chrom: scaffold_877 SNPs number: 1    (81/83)
    SNPs blacklisted: 0
Chrom: scaffold_901 SNPs number: 1    (82/83)
    SNPs blacklisted: 0
Chrom: scaffold_915 SNPs number: 1    (83/83)
    SNPs blacklisted: 0
File written: whitelist(s) and blacklist(s)
Generating figures...

Step 4. Threshold selection
Look at the boxplot, a threshold of 0.2 will blacklist more markers than a threshold of 0.8

Enter the long LD threshold (filter.long.ld threshold, double/proportion):
0.2

Step 5. Filtering markers based on long distance LD
Filters parameters file: updated
################################### RESULTS ####################################

Filter long ld threshold: 0.2
Number of individuals / strata / chrom / locus / SNP:
    Before: 557 / 16 / 83 / 417 / 417
    Blacklisted: 0 / 0 / 0 / 0 / 0
    After: 557 / 16 / 83 / 417 / 417

Computation time, overall: 74 sec
############################# completed filter_ld ##############################
################################################################################
######################## radiator::detect_mixed_genomes ########################
################################################################################
Execution date@time: 20191014@0950

detect_mixed_genomes function call arguments:
    data = SeqVarGDSClass
    interactive.filter = TRUE
    detect.mixed.genomes = FALSE
    ind.heterozygosity.threshold = NULL
    verbose = TRUE
    parallel.core = 11

dots-dots-dots ... arguments

Arguments inside "..." assigned in detect_mixed_genomes:
    internal = FALSE
    parameters = list
    path.folder = filter_rad_20191014@0939


File written: radiator_detect_mixed_genomes_args_20191014@0950.tsv
Filters parameters file: initiated
Calculating heterozygosity statistics
Generating plots

The greatest value of a picture is when it forces us
to notice what we never expected to see.

John W. Tukey. Exploratory Data Analysis. 1977.


Inspect plots and tables in folder created...
    Do you want to exclude individuals based on heterozygosity ? (y/n): 
n
Filters parameters file: updated
################################### RESULTS ####################################
Detect mixed genomes: 0 1
Number of individuals / strata / chrom / locus / SNP:
    Before: 557 / 16 / 83 / 417 / 417
    Blacklisted: 0 / 0 / 0 / 0 / 0
    After: 557 / 16 / 83 / 417 / 417

Computation time, overall: 125 sec
######################## completed detect_mixed_genomes ########################

################################################################################
###################### radiator::detect_duplicate_genomes ######################
################################################################################
Execution date@time: 20191014@0952
Function call and arguments stored in a file
File written: radiator_detect_duplicate_genomes_args_20191014@0952.tsv
File written: random.seed (835230)
Filters parameters file: initiated
Calculating manhattan distances between individuals...
Generating summary statistics
Generating plots

Inspect tables and figures to decide if some individual(s) need to be blacklisted
    Do you need to blacklist individual(s) (y/n): 
n
Filters parameters file: updated
################################### RESULTS ####################################
Detect duplicate genomes: 0
Number of individuals / strata / chrom / locus / SNP:
    Before: 557 / 16 / 83 / 417 / 417
    Blacklisted: 0 / 0 / 0 / 0 / 0
    After: 557 / 16 / 83 / 417 / 417

Computation time, overall: 85 sec
###################### completed detect_duplicate_genomes ######################
Registered S3 methods overwritten by 'ggtern':
  method           from   
  +.gg             ggplot2
  grid.draw.ggplot ggplot2
  plot.ggplot      ggplot2
  print.ggplot     ggplot2
################################################################################
############################# radiator::filter_hwe #############################
################################################################################
Execution date@time: 20191014@0953
Interactive mode: on
Function call and arguments stored in: radiator_filter_hwe_args_20191014@0953.tsv
Filters parameters file: initiated
    using tidy data frame of genotypes as input
    skipping all filters
Summarizing data
File written: genotypes.summary.tsv
HWE analysis for pop: ALFW
  |=============================================| 100%, Elapsed 00:00
HWE analysis for pop: ALST
  |=============================================| 100%, Elapsed 00:00
HWE analysis for pop: FLAB
  |=============================================| 100%, Elapsed 00:00
HWE analysis for pop: FLCC
  |=============================================| 100%, Elapsed 00:00
HWE analysis for pop: FLFD
  |=============================================| 100%, Elapsed 00:00
HWE analysis for pop: FLHB
  |=============================================| 100%, Elapsed 00:00
HWE analysis for pop: FLKB
  |=============================================| 100%, Elapsed 00:00
HWE analysis for pop: FLLG
  |=============================================| 100%, Elapsed 00:00
HWE analysis for pop: FLPB
  |=============================================| 100%, Elapsed 00:00
HWE analysis for pop: FLSG
  |=============================================| 100%, Elapsed 00:00
HWE analysis for pop: FLSI
  |=============================================| 100%, Elapsed 00:00
HWE analysis for pop: LAFW
  |=============================================| 100%, Elapsed 00:00
HWE analysis for pop: TXCB
  |=============================================| 100%, Elapsed 00:00
HWE analysis for pop: TXCC
  |=============================================| 100%, Elapsed 00:00
HWE analysis for pop: TXFW
  |=============================================| 100%, Elapsed 00:00
HWE analysis for pop: TXSP
  |=============================================| 100%, Elapsed 00:00
HWE analysis for pop: OVERALL
  |=============================================| 100%, Elapsed 00:00
File written: hw.pop.sum.tsv
Plot written: hwd.plot.blacklist.markers.pdf
Plot written: hwe.ternary.plots.missing.data.pdf
Plot written: hwe.manhattan.plot.pdf

Do you want to continue with the filtering ? (y/n):
y

Based on figures and tables enter the hw.pop.threshold (integer): 
2

Generating blacklists, whitelists and filtered tidy data...
done!

Choosing the final filtered dataset
   select the mid p-value threshold (5 options):
1: 0.05 *
2. 0.01 **
3. 0.001 ***
4. 0.0001 ****
5. 0.00001 *****
1

Final filtered tidy dataset: 
tidy.filtered.hwe.0.05.mid.p.value.2.hw.pop.threshold.rad

Using hw.pop.threshold/midp.threshold: 2/0.05
Filters parameters file: updated
################################### RESULTS ####################################
Filter HWE: 2 / 0.05
Number of individuals / strata / chrom / locus / SNP:
    Before: 557 / 16 / 83 / 417 / 417
    Blacklisted: 0 / 0 / 1 / 16 / 16
    After: 557 / 16 / 82 / 401 / 401

Computation time, overall: 47 sec
############################# completed filter_hwe #############################

Preparing output files...
File written: whitelist.markers.tsv
File written: blacklist.markers.tsv
File written: blacklist.id.tsv
Writing the filtered strata: strata.filtered.tsvstrata.filtered.tsv

Generating statistics after filtering
calculating individual stats...
File written: individuals qc info and stats summary
File written: individuals qc plot
calculating markers stats...

Transferring data to genomic converter...
Synchronizing data and strata...
    Number of strata: 16
    Number of individuals: 557

Writing tidy data set:
radiator_data_20191014@0954.rad
Data summary: 
    number of samples: 557
    number of markers: 401

Computation time, overall: 922 sec
############################# completed filter_rad #############################
```

The good news is that this program outputs a lot of information, so I can go back and look at what was not great and what was good and make different decisions.

```{r}
missingness<-read.delim("filter_rad_20191014@0939/04_filter_individuals/blacklist.individuals.missing_20191014@0941.tsv")
het_black<-read.delim("filter_rad_20191014@0939/04_filter_individuals/blacklist.individuals.heterozygosity_20191014@0941.tsv")
```

I think I'll up the proportion of missingness allowed per individual, up the gneotyping missingness allowed, and reduce the minimum coverage.

```{r}
data<-radiator::filter_rad(data="stacks/populations_all/batch_2.vcf",
                           strata="../fwsw_pops_map.txt",
                           output=c("genepop","vcf","plink","structure"))
```

```
Chrom: scaffold_612 SNPs number: 3    (213/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_620 SNPs number: 2    (214/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_622 SNPs number: 1    (215/345)
    SNPs blacklisted: 0
Chrom: scaffold_625 SNPs number: 1    (216/345)
    SNPs blacklisted: 0
Chrom: scaffold_627 SNPs number: 1    (217/345)
    SNPs blacklisted: 0
Chrom: scaffold_629 SNPs number: 3    (218/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_631 SNPs number: 1    (219/345)
    SNPs blacklisted: 0
Chrom: scaffold_632 SNPs number: 1    (220/345)
    SNPs blacklisted: 0
Chrom: scaffold_638 SNPs number: 4    (221/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_639 SNPs number: 2    (222/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_641 SNPs number: 1    (223/345)
    SNPs blacklisted: 0
Chrom: scaffold_643 SNPs number: 2    (224/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_647 SNPs number: 2    (225/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_650 SNPs number: 3    (226/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_651 SNPs number: 1    (227/345)
    SNPs blacklisted: 0
Chrom: scaffold_654 SNPs number: 1    (228/345)
    SNPs blacklisted: 0
Chrom: scaffold_660 SNPs number: 3    (229/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_662 SNPs number: 3    (230/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_665 SNPs number: 5    (231/345)
    LD threshold: 0.1, SNPs blacklisted: 1
    LD threshold: 0.2, SNPs blacklisted: 1
    LD threshold: 0.3, SNPs blacklisted: 1
    LD threshold: 0.4, SNPs blacklisted: 1
    LD threshold: 0.5, SNPs blacklisted: 1
    LD threshold: 0.6, SNPs blacklisted: 1
    LD threshold: 0.7, SNPs blacklisted: 1
    LD threshold: 0.8, SNPs blacklisted: 1
    LD threshold: 0.9, SNPs blacklisted: 1
Chrom: scaffold_668 SNPs number: 2    (232/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_669 SNPs number: 1    (233/345)
    SNPs blacklisted: 0
Chrom: scaffold_672 SNPs number: 2    (234/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_673 SNPs number: 1    (235/345)
    SNPs blacklisted: 0
Chrom: scaffold_674 SNPs number: 2    (236/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_677 SNPs number: 1    (237/345)
    SNPs blacklisted: 0
Chrom: scaffold_680 SNPs number: 2    (238/345)
    LD threshold: 0.1, SNPs blacklisted: 1
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_681 SNPs number: 1    (239/345)
    SNPs blacklisted: 0
Chrom: scaffold_684 SNPs number: 1    (240/345)
    SNPs blacklisted: 0
Chrom: scaffold_689 SNPs number: 4    (241/345)
    LD threshold: 0.1, SNPs blacklisted: 1
    LD threshold: 0.2, SNPs blacklisted: 1
    LD threshold: 0.3, SNPs blacklisted: 1
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_697 SNPs number: 1    (242/345)
    SNPs blacklisted: 0
Chrom: scaffold_698 SNPs number: 2    (243/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_702 SNPs number: 1    (244/345)
    SNPs blacklisted: 0
Chrom: scaffold_703 SNPs number: 2    (245/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_705 SNPs number: 1    (246/345)
    SNPs blacklisted: 0
Chrom: scaffold_706 SNPs number: 1    (247/345)
    SNPs blacklisted: 0
Chrom: scaffold_708 SNPs number: 1    (248/345)
    SNPs blacklisted: 0
Chrom: scaffold_710 SNPs number: 2    (249/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_712 SNPs number: 1    (250/345)
    SNPs blacklisted: 0
Chrom: scaffold_717 SNPs number: 1    (251/345)
    SNPs blacklisted: 0
Chrom: scaffold_720 SNPs number: 1    (252/345)
    SNPs blacklisted: 0
Chrom: scaffold_721 SNPs number: 1    (253/345)
    SNPs blacklisted: 0
Chrom: scaffold_724 SNPs number: 1    (254/345)
    SNPs blacklisted: 0
Chrom: scaffold_728 SNPs number: 2    (255/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_730 SNPs number: 1    (256/345)
    SNPs blacklisted: 0
Chrom: scaffold_732 SNPs number: 1    (257/345)
    SNPs blacklisted: 0
Chrom: scaffold_734 SNPs number: 1    (258/345)
    SNPs blacklisted: 0
Chrom: scaffold_736 SNPs number: 1    (259/345)
    SNPs blacklisted: 0
Chrom: scaffold_737 SNPs number: 1    (260/345)
    SNPs blacklisted: 0
Chrom: scaffold_738 SNPs number: 2    (261/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_739 SNPs number: 1    (262/345)
    SNPs blacklisted: 0
Chrom: scaffold_744 SNPs number: 1    (263/345)
    SNPs blacklisted: 0
Chrom: scaffold_747 SNPs number: 2    (264/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_748 SNPs number: 1    (265/345)
    SNPs blacklisted: 0
Chrom: scaffold_753 SNPs number: 2    (266/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_756 SNPs number: 2    (267/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_758 SNPs number: 1    (268/345)
    SNPs blacklisted: 0
Chrom: scaffold_763 SNPs number: 1    (269/345)
    SNPs blacklisted: 0
Chrom: scaffold_764 SNPs number: 1    (270/345)
    SNPs blacklisted: 0
Chrom: scaffold_765 SNPs number: 1    (271/345)
    SNPs blacklisted: 0
Chrom: scaffold_767 SNPs number: 1    (272/345)
    SNPs blacklisted: 0
Chrom: scaffold_769 SNPs number: 2    (273/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_775 SNPs number: 1    (274/345)
    SNPs blacklisted: 0
Chrom: scaffold_776 SNPs number: 1    (275/345)
    SNPs blacklisted: 0
Chrom: scaffold_777 SNPs number: 1    (276/345)
    SNPs blacklisted: 0
Chrom: scaffold_780 SNPs number: 2    (277/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_784 SNPs number: 2    (278/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_785 SNPs number: 1    (279/345)
    SNPs blacklisted: 0
Chrom: scaffold_787 SNPs number: 1    (280/345)
    SNPs blacklisted: 0
Chrom: scaffold_788 SNPs number: 1    (281/345)
    SNPs blacklisted: 0
Chrom: scaffold_792 SNPs number: 1    (282/345)
    SNPs blacklisted: 0
Chrom: scaffold_794 SNPs number: 2    (283/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_797 SNPs number: 1    (284/345)
    SNPs blacklisted: 0
Chrom: scaffold_798 SNPs number: 1    (285/345)
    SNPs blacklisted: 0
Chrom: scaffold_799 SNPs number: 2    (286/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_800 SNPs number: 2    (287/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_801 SNPs number: 1    (288/345)
    SNPs blacklisted: 0
Chrom: scaffold_807 SNPs number: 1    (289/345)
    SNPs blacklisted: 0
Chrom: scaffold_813 SNPs number: 1    (290/345)
    SNPs blacklisted: 0
Chrom: scaffold_815 SNPs number: 1    (291/345)
    SNPs blacklisted: 0
Chrom: scaffold_816 SNPs number: 1    (292/345)
    SNPs blacklisted: 0
Chrom: scaffold_826 SNPs number: 2    (293/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_827 SNPs number: 1    (294/345)
    SNPs blacklisted: 0
Chrom: scaffold_828 SNPs number: 1    (295/345)
    SNPs blacklisted: 0
Chrom: scaffold_829 SNPs number: 1    (296/345)
    SNPs blacklisted: 0
Chrom: scaffold_831 SNPs number: 2    (297/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_833 SNPs number: 1    (298/345)
    SNPs blacklisted: 0
Chrom: scaffold_835 SNPs number: 1    (299/345)
    SNPs blacklisted: 0
Chrom: scaffold_837 SNPs number: 1    (300/345)
    SNPs blacklisted: 0
Chrom: scaffold_839 SNPs number: 4    (301/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_840 SNPs number: 2    (302/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_846 SNPs number: 2    (303/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_847 SNPs number: 1    (304/345)
    SNPs blacklisted: 0
Chrom: scaffold_848 SNPs number: 1    (305/345)
    SNPs blacklisted: 0
Chrom: scaffold_849 SNPs number: 2    (306/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_850 SNPs number: 1    (307/345)
    SNPs blacklisted: 0
Chrom: scaffold_851 SNPs number: 1    (308/345)
    SNPs blacklisted: 0
Chrom: scaffold_852 SNPs number: 1    (309/345)
    SNPs blacklisted: 0
Chrom: scaffold_857 SNPs number: 1    (310/345)
    SNPs blacklisted: 0
Chrom: scaffold_862 SNPs number: 1    (311/345)
    SNPs blacklisted: 0
Chrom: scaffold_870 SNPs number: 1    (312/345)
    SNPs blacklisted: 0
Chrom: scaffold_873 SNPs number: 1    (313/345)
    SNPs blacklisted: 0
Chrom: scaffold_874 SNPs number: 2    (314/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_875 SNPs number: 1    (315/345)
    SNPs blacklisted: 0
Chrom: scaffold_876 SNPs number: 3    (316/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_877 SNPs number: 1    (317/345)
    SNPs blacklisted: 0
Chrom: scaffold_878 SNPs number: 1    (318/345)
    SNPs blacklisted: 0
Chrom: scaffold_891 SNPs number: 3    (319/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_895 SNPs number: 2    (320/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_899 SNPs number: 1    (321/345)
    SNPs blacklisted: 0
Chrom: scaffold_900 SNPs number: 1    (322/345)
    SNPs blacklisted: 0
Chrom: scaffold_901 SNPs number: 1    (323/345)
    SNPs blacklisted: 0
Chrom: scaffold_905 SNPs number: 1    (324/345)
    SNPs blacklisted: 0
Chrom: scaffold_909 SNPs number: 1    (325/345)
    SNPs blacklisted: 0
Chrom: scaffold_912 SNPs number: 2    (326/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_914 SNPs number: 1    (327/345)
    SNPs blacklisted: 0
Chrom: scaffold_915 SNPs number: 1    (328/345)
    SNPs blacklisted: 0
Chrom: scaffold_916 SNPs number: 1    (329/345)
    SNPs blacklisted: 0
Chrom: scaffold_918 SNPs number: 1    (330/345)
    SNPs blacklisted: 0
Chrom: scaffold_920 SNPs number: 1    (331/345)
    SNPs blacklisted: 0
Chrom: scaffold_922 SNPs number: 1    (332/345)
    SNPs blacklisted: 0
Chrom: scaffold_923 SNPs number: 1    (333/345)
    SNPs blacklisted: 0
Chrom: scaffold_925 SNPs number: 1    (334/345)
    SNPs blacklisted: 0
Chrom: scaffold_933 SNPs number: 2    (335/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_937 SNPs number: 1    (336/345)
    SNPs blacklisted: 0
Chrom: scaffold_940 SNPs number: 1    (337/345)
    SNPs blacklisted: 0
Chrom: scaffold_942 SNPs number: 3    (338/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_943 SNPs number: 1    (339/345)
    SNPs blacklisted: 0
Chrom: scaffold_948 SNPs number: 1    (340/345)
    SNPs blacklisted: 0
Chrom: scaffold_962 SNPs number: 1    (341/345)
    SNPs blacklisted: 0
Chrom: scaffold_967 SNPs number: 1    (342/345)
    SNPs blacklisted: 0
Chrom: scaffold_969 SNPs number: 2    (343/345)
    LD threshold: 0.1, SNPs blacklisted: 0
    LD threshold: 0.2, SNPs blacklisted: 0
    LD threshold: 0.3, SNPs blacklisted: 0
    LD threshold: 0.4, SNPs blacklisted: 0
    LD threshold: 0.5, SNPs blacklisted: 0
    LD threshold: 0.6, SNPs blacklisted: 0
    LD threshold: 0.7, SNPs blacklisted: 0
    LD threshold: 0.8, SNPs blacklisted: 0
    LD threshold: 0.9, SNPs blacklisted: 0
Chrom: scaffold_978 SNPs number: 1    (344/345)
    SNPs blacklisted: 0
Chrom: scaffold_995 SNPs number: 1    (345/345)
    SNPs blacklisted: 0
File written: whitelist(s) and blacklist(s)
Generating figures...

Step 4. Threshold selection
Look at the boxplot, a threshold of 0.2 will blacklist more markers than a threshold of 0.8

Enter the long LD threshold (filter.long.ld threshold, double/proportion):
0.2

Step 5. Filtering markers based on long distance LD
Filters parameters file: updated
################################### RESULTS ####################################

Filter long ld threshold: 0.2
Number of individuals / strata / chrom / locus / SNP:
    Before: 605 / 16 / 345 / 7670 / 7670
    Blacklisted: 0 / 0 / 0 / 0 / 0
    After: 605 / 16 / 345 / 7670 / 7670

Computation time, overall: 162 sec
############################# completed filter_ld ##############################
################################################################################
######################## radiator::detect_mixed_genomes ########################
################################################################################
Execution date@time: 20191014@1705

detect_mixed_genomes function call arguments:
    data = SeqVarGDSClass
    interactive.filter = TRUE
    detect.mixed.genomes = FALSE
    ind.heterozygosity.threshold = NULL
    verbose = TRUE
    parallel.core = 11

dots-dots-dots ... arguments

Arguments inside "..." assigned in detect_mixed_genomes:
    internal = FALSE
    parameters = list
    path.folder = filter_rad_20191014@1654


File written: radiator_detect_mixed_genomes_args_20191014@1705.tsv
Filters parameters file: initiated
Calculating heterozygosity statistics
Generating plots

The greatest value of a picture is when it forces us
to notice what we never expected to see.

John W. Tukey. Exploratory Data Analysis. 1977.


Inspect plots and tables in folder created...
    Do you want to exclude individuals based on heterozygosity ? (y/n): 
n
Filters parameters file: updated
################################### RESULTS ####################################
Detect mixed genomes: 0 1
Number of individuals / strata / chrom / locus / SNP:
    Before: 605 / 16 / 345 / 7670 / 7670
    Blacklisted: 0 / 0 / 0 / 0 / 0
    After: 605 / 16 / 345 / 7670 / 7670

Computation time, overall: 92 sec
######################## completed detect_mixed_genomes ########################

################################################################################
###################### radiator::detect_duplicate_genomes ######################
################################################################################
Execution date@time: 20191014@1706
Function call and arguments stored in a file
File written: radiator_detect_duplicate_genomes_args_20191014@1706.tsv
File written: random.seed (322915)
Filters parameters file: initiated
Calculating manhattan distances between individuals...
Generating summary statistics
Generating plots

Inspect tables and figures to decide if some individual(s) need to be blacklisted
    Do you need to blacklist individual(s) (y/n): 
n
Filters parameters file: updated
################################### RESULTS ####################################
Detect duplicate genomes: 0
Number of individuals / strata / chrom / locus / SNP:
    Before: 605 / 16 / 345 / 7670 / 7670
    Blacklisted: 0 / 0 / 0 / 0 / 0
    After: 605 / 16 / 345 / 7670 / 7670

Computation time, overall: 83 sec
###################### completed detect_duplicate_genomes ######################
################################################################################
############################# radiator::filter_hwe #############################
################################################################################
Execution date@time: 20191014@1708
Interactive mode: on
Function call and arguments stored in: radiator_filter_hwe_args_20191014@1708.tsv
Filters parameters file: initiated
    using tidy data frame of genotypes as input
    skipping all filters
Summarizing data
File written: genotypes.summary.tsv
HWE analysis for pop: ALFW
  |=============================================| 100%, Elapsed 00:01
HWE analysis for pop: ALST
  |=============================================| 100%, Elapsed 00:01
HWE analysis for pop: FLAB
  |=============================================| 100%, Elapsed 00:01
HWE analysis for pop: FLCC
  |=============================================| 100%, Elapsed 00:01
HWE analysis for pop: FLFD
  |=============================================| 100%, Elapsed 00:01
HWE analysis for pop: FLHB
  |=============================================| 100%, Elapsed 00:01
HWE analysis for pop: FLKB
  |=============================================| 100%, Elapsed 00:01
HWE analysis for pop: FLLG
  |=============================================| 100%, Elapsed 00:01
HWE analysis for pop: FLPB
  |=============================================| 100%, Elapsed 00:01
HWE analysis for pop: FLSG
  |=============================================| 100%, Elapsed 00:01
HWE analysis for pop: FLSI
  |=============================================| 100%, Elapsed 00:01
HWE analysis for pop: LAFW
  |=============================================| 100%, Elapsed 00:01
HWE analysis for pop: TXCB
  |=============================================| 100%, Elapsed 00:01
HWE analysis for pop: TXCC
  |=============================================| 100%, Elapsed 00:01
HWE analysis for pop: TXFW
  |=============================================| 100%, Elapsed 00:01
HWE analysis for pop: TXSP
  |=============================================| 100%, Elapsed 00:01
HWE analysis for pop: OVERALL
  |=============================================| 100%, Elapsed 00:01
File written: hw.pop.sum.tsv
Plot written: hwd.plot.blacklist.markers.pdf
Plot written: hwe.ternary.plots.missing.data.pdf
Plot written: hwe.manhattan.plot.pdf

Do you want to continue with the filtering ? (y/n):
y

Based on figures and tables enter the hw.pop.threshold (integer): 
2

Generating blacklists, whitelists and filtered tidy data...
done!

Choosing the final filtered dataset
   select the mid p-value threshold (5 options):
1: 0.05 *
2. 0.01 **
3. 0.001 ***
4. 0.0001 ****
5. 0.00001 *****
1

Final filtered tidy dataset: 
tidy.filtered.hwe.0.05.mid.p.value.2.hw.pop.threshold.rad

Using hw.pop.threshold/midp.threshold: 2/0.05
Filters parameters file: updated
################################### RESULTS ####################################
Filter HWE: 2 / 0.05
Number of individuals / strata / chrom / locus / SNP:
    Before: 605 / 16 / 345 / 7670 / 7670
    Blacklisted: 0 / 0 / 4 / 237 / 237
    After: 605 / 16 / 341 / 7433 / 7433

Computation time, overall: 97 sec
############################# completed filter_hwe #############################

Preparing output files...
File written: whitelist.markers.tsv
File written: blacklist.markers.tsv
File written: blacklist.id.tsv
Writing the filtered strata: strata.filtered.tsvstrata.filtered.tsv

Generating statistics after filtering
calculating individual stats...
File written: individuals qc info and stats summary
File written: individuals qc plot
calculating markers stats...

Transferring data to genomic converter...
Synchronizing data and strata...
    Number of strata: 16
    Number of individuals: 605

Writing tidy data set:
radiator_data_20191014@1710.rad
Calibrating REF/ALT alleles...
    number of REF/ALT switch = 2
Data summary: 
    number of samples: 605
    number of markers: 7433

Computation time, overall: 1007 sec
############################# completed filter_rad #############################
> filt<-radiator::filter_rad(data="filter_rad_20191014@1654/14_filtered/radiator_data_20191014@1710.vcf",
+                            strata="filter_rad_20191014@1654/14_filtered/strata.filtered.tsv",
+                            output=c("genepop","vcf","plink","structure"))
################################################################################
############################# radiator::filter_rad #############################
################################################################################
The function arguments names have changed: please read documentation

Execution date@time: 20191014@1713
Folder created: filter_rad_20191014@1713
Function call and arguments stored in: radiator_filter_rad_args_20191014@1713.tsv
File written: random.seed (422581)
Filters parameters file generated: filters_parameters_20191014@1713.tsv

Reading VCF
Data summary: 
    number of samples: 605
    number of markers: 7433
done! timing: 3 sec

Generating individual stats...
Generating markers stats...


Number of chromosome/contig/scaffold: 341
Number of locus: 7433
Number of markers: 7433
Number of populations: 16
Number of individuals: 605

Number of ind/pop:
ALFW = 37
ALST = 43
FLAB = 34
FLCC = 31
FLFD = 35
FLHB = 41
FLKB = 40
FLLG = 42
FLPB = 42
FLSG = 43
FLSI = 40
LAFW = 39
TXCB = 30
TXCC = 36
TXFW = 27
TXSP = 45

Number of duplicate id: 0
radiator Genomic Data Structure (GDS) file: radiator_20191014@1713.gds
################################################################################
########################### radiator::filter_monomorphic #######################
################################################################################
Execution date@time: 20191014@1714
Function call and arguments stored in: radiator_filter_monomorphic_args_20191014@1714.tsv
Filters parameters file: initiated


Computation time, overall: 1 sec
######################## filter_monomorphic completed ##########################

Computation time, overall: 11 sec
############################# completed filter_rad #############################

```

Obviously I lost some of this history but here's some of it. I recorded all of my choices on a piece of paper.

Ok, this retained a better number of loci. But there's a weird band in the detect_duplicate_genomes step, so I might try running that one again.

```{r}
filt<-radiator::detect_duplicate_genomes(data=data$output)
```

This resulted in keeping 353 individuals and 7411 loci

```
> filt<-radiator::detect_duplicate_genomes(data=data$gds)

################################################################################
###################### radiator::detect_duplicate_genomes ######################
################################################################################
Execution date@time: 20191014@1717
Folder created: -7_detect_duplicate_genomes_20191014@1717
Function call and arguments stored in a file
File written: radiator_detect_duplicate_genomes_args_20191014@1717.tsv
File written: random.seed (979520)
Filters parameters file generated: filters_parameters_20191014@1717.tsv
Filters parameters file: initiated
Calculating manhattan distances between individuals...
Generating summary statistics
Generating plots

Inspect tables and figures to decide if some individual(s) need to be blacklisted
    Do you need to blacklist individual(s) (y/n): 
y

2 options to remove duplicates:
    1. threshold: using the figure you choose a threshold. It's more powerful to fully remove duplicates
    2. manually: the function generate a blacklist that you have to complete
    Note: not sure ? Use option 1, it's more powerful to fully remove duplicates
    Enter the option to remove duplicates (1/2): 
1

Enter the threshold to remove duplicates: (between 0 and 1)
0.25

2 options to remove duplicates involved in pairs from different strata/group:
    (the black points on the figure, above your threshold)
    1: blacklist both samples in the pair
    2: blacklist only 1 sample, based on missingness
    Enter 1/2: 
2
With threshold selected, 70 individual(s) blacklisted
Written in the directory: blacklist.id.similar.tsv
Blacklisted individuals: 70 ind.
    Filtering with blacklist of individuals
Filters parameters file: updated
################################### RESULTS ####################################
Detect duplicate genomes: 0.25
Number of individuals / strata / chrom / locus / SNP:
    Before: 605 / 16 / 341 / 7433 / 7433
    Blacklisted: 70 / 0 / 0 / 0 / 0
    After: 535 / 16 / 341 / 7433 / 7433

Filter monomorphic markers
Number of individuals / strata / chrom / locus / SNP:
    Blacklisted: 0 / 0 / 1 / 22 / 22

Computation time, overall: 71 sec
###################### completed detect_duplicate_genomes ######################
```

This results in fewer individuals than in my first analysis. My goal here was to get a list of which individuals might be problematic

```{r}
similar_ids<-read.delim("-7_detect_duplicate_genomes_20191014@1717/blacklist.id.similar.tsv")
```

As I suspected, these are the FLFW individuals plus primarily individuals from the other FW populations. I think I'll leave them in the analysis for now (so I'll disregard this folder).

I'm saving these folders to my external drive so I can analyse them some more while I'm away.


# 11 October 2019

Trying to get to the bottom of the weirdness with the locus names...

```{r}
get_bayenv_results<-function(dir,env_vars){
  # process the variable names
  var_names<-unlist(lapply(env_vars,function(var){
    nms<-c(paste0(var,"_BF"),paste0(var,"_rho"),paste0(var,"_rs"))
    return(nms)
  }))
  # list all the files
  bf.files<-list.files(pattern="bf",path = dir,full.names = TRUE)
  xtx.files<-list.files(pattern="xtx",path=dir,full.names = TRUE)
  # get the bf files
  bf.dat<-do.call(rbind,lapply(bf.files,function(filename){
    bf<-read.table(filename,header = FALSE)
  }))
  colnames(bf.dat)<-c("locus", var_names)
  
  # xtx files
  xtx.files<-list.files(pattern="xtx",path=dir,full.names = TRUE)
  xtx.dat<-do.call(rbind,lapply(xtx.files,function(filename){
    xtx<-read.table(filename,header = FALSE,stringsAsFactors = FALSE)
  }))
  colnames(xtx.dat)<-c("locus","XtX")
  
  # combine the two
  bayenv.dat<-merge(xtx.dat,bf.dat,by="locus")
  return(bayenv.dat)
}
bayenv_dat<-get_bayenv_results(dir="bayenv/SNPFILES",env_vars=c("temp","salinity","seagrass"))

freq<-read.table("bayenv/bayenv.frq.strat",header=T, stringsAsFactors=F)
#want to get $MAC for every snp at every pop 
#and NCHROBS-MAC for every stnp at every pop
freq<-cbind(freq,freq$NCHROBS-freq$MAC)
colnames(freq)[ncol(freq)]<-"NAC"
pop.order<-levels(as.factor(freq$CLST))
snp.names<-split(freq$SNP,freq$CLST)[[1]]
snp.names<-gsub("(\\d+)_\\d+","\\1",snp.names)

snp_dat<-data.frame(ID=snp.names,loc=1:length(snp.names))

loc<-as.numeric(gsub("SNPFILES\\/(\\d+)","\\1",bayenv_dat$locus))
```

Ah, I think I see the problem -- these are actually the SNP IDs, not row numbers like I though. Oops! if you look closely at the snp.names definition, it's taking the SNP ID and using that.

OK, so let's see if we can match these things up. 


```{r}
pmap<-read.delim("stacks/populations_subset75/batch_2.pruned.map",header = FALSE)
pmap$locus<-gsub("(\\d+)_\\d+","\\1",pmap[,2])

bayenv_dat$locus<-as.numeric(gsub("SNPFILES\\/(\\d+)","\\1",bayenv_dat$locus))


dim(pmap[pmap$V2 %in% freq$SNP,])
dim(pmap[pmap$locus %in% snp.names,])
dim(pmap[pmap$locus %in% bayenv_dat$locus,])
dim(pmap[pmap$locus %in% loc,])
```

Ok, so there's something weird going on with the bayenv_dat SNP names - they don't match up properly with the locus names but snp.names do match up. So, I'm thinking that something gets lost in one conversion or another - could some of them have 1s added on the end? No, it doesn't look like it. 

Ok, what are the rownames of the actual snps file?

```{r}
snpsfile<-read.delim("bayenv/SNPSFILE")
```

Ok, let's take some steps back. When creating the SNPSFILE, I used the rownames properly but then didn't write them to the file. Then when making the SNP files, I used rownames of the first row per locus to name the files, so I should have names 1:12103*2 by 2s. 

```{r}
summary(seq(1,12103*2,2))
summary(as.numeric(bayenv_dat$locus))
```

Ok, and that is what I've got. Ok, so now I can do a better conversion.

```{r}
snp_dat<-data.frame(ID=snp.names,loc=seq(1,length(snp.names)*2,2))
loc<-snp_dat[order(snp_dat$loc %in% bayenv_dat$locus),]
```
This doesn't work! ugh. 

```{r}
head(snp_dat[sort(as.character(snp_dat$loc)),])
head(bayenv_dat[sort(bayenv_dat$locus),])
```

Ok, let's try another tactic

```{r}
bayenv_dat$locus<-as.numeric(bayenv_dat$locus)
bayenv_dat<-bayenv_dat[order(bayenv_dat$locus),]
bayenv_dat<-merge(snp_dat,bayenv_dat,by.x="loc",by.y="locus")
colnames(bayenv_dat)[1:2]<-c("index","SNPID")
```

Whew ok that works! Now we can add on the chromosome info

```{r}
colnames(pmap)<-c("Chr","SNP","X","BP","locus")
test<-merge(pmap[,c(1,4,5)],bayenv_dat,by.x="locus",by.y="SNPID")
```

Woohoo this works!

```{r}
bayenv_dat<-merge(pmap[,c(1,4,5)],bayenv_dat,by.x="locus",by.y="SNPID")
write.table(bayenv_dat,"bayenv/bayenv_output.txt",sep="\t",col.names = TRUE,row.names = FALSE,quote = FALSE)
```


I've put the working bits into the 202_fwsw_reanalysis.Rmd document.

Now onto plotting the results! I should be able to use functions I've written previously and are probably in gwscaR?

```{r}
bayenv_dat<-read.delim("bayenv/bayenv_output.txt",header = TRUE)
bayenv_dat$logSalBF<-log(bayenv_dat$salinity_BF)
xp<-fst.plot(bayenv_dat,scaffs.to.plot = lgs,fst.name = "logSalBF",chrom.name = "Chr",bp.name = "BP")

```

This plot doesn't look so nice. 

```{r}
bounds<-tapply(as.numeric(as.character(bayenv_dat$BP)), bayenv_dat$Chr,max)
bounds<-data.frame(Chrom=dimnames(bounds)[[1]],End=bounds,stringsAsFactors = FALSE)
plot_dat<-assign.plotpos(bayenv_dat,plot.scaffs = lgs,bounds = bounds, df.chrom = "Chr")
```

Not sure why this is so annoying. 

```{r}
par(mfrow=c(2,1))
plot(bayenv_dat$BP[bayenv_dat$Chr=="LG1"],bayenv_dat$XtX[bayenv_dat$Chr=="LG1"])
plot(xp$plot.pos[xp$Chr=="LG1"],xp$XtX[xp$Chr=="LG1"])
```

these match....

```{r}
par(mfrow=c(2,1))
plot(bayenv_dat$BP[bayenv_dat$Chr=="LG2"],bayenv_dat$XtX[bayenv_dat$Chr=="LG2"])
plot(xp$plot.pos[xp$Chr=="LG2"],xp$XtX[xp$Chr=="LG2"])
```

Those are also ok, but the max of LG1's plot pos, `r max(xp$plot.pos[xp$Chr=="LG1"])` is much smaller than the minimum of LG2's plot pos `r min(xp$plot.pos[xp$Chr=="LG2"])` - this is causing the weirdness.

```{r}
xp<-fst.plot(bayenv_dat,scaffs.to.plot = lgs,fst.name = "logSalBF",chrom.name = "Chr",bp.name = "locus",axis.size = 0,pch=19)
```

Aha, if I use the locus it looks a lot beter! But locus doesn't have anything to do with BP necessarily.

```{r}
bf.co<-apply(bayenv_dat[,grep("BF",colnames(bayenv_dat))],2,quantile,0.99) #focus on Bayes Factors, because of Lotterhos & Whitlock (2015)
temp.bf.sig<-bayenv_dat[bayenv_dat$temp_BF>bf.co["temp_BF"],]
sal.bf.sig<-bayenv_dat[bayenv_dat$salinity_BF>bf.co["salinity_BF"],]
grass.bf.sig<-bayenv_dat[bayenv_dat$seagrass_BF>bf.co["seagrass_BF"],]
xtx.sig<-bayenv_dat[bayenv_dat$XtX > quantile(bayenv_dat$XtX,0.99),]
```


```{r}
par(mfrow=c(2,1),mar=c(4,4,2,2))
xp<-fst.plot(bayenv_dat,scaffs.to.plot = lgs,fst.name = "XtX",chrom.name = "Chr",bp.name = "index",axis.size = 0,pch=19)
points(xp$plot.pos[xp$locus %in% xtx.sig$locus])
sp<-fst.plot(bayenv_dat,scaffs.to.plot = lgs,fst.name = "logSalBF",chrom.name = "Chr",bp.name = "index",axis.size = 0,pch=19)
```

This is annoying...maybe I should just combine all my outlier info at the moment - do I need to actually show the results on a graph?

```{r}
bayenv_dat$logTemBF<-log(bayenv_dat$temp_BF)
bayenv_dat$logSegBF<-log(bayenv_dat$seagrass_BF)
fw_SNPinfo<-readRDS("fw_SNPinfo.RDS")
fw_SNPinfo<-merge(fw_SNPinfo,bayenv_dat[,c("locus","XtX","logSalBF","logTemBF","logSegBF")],by.x="ID",by.y="locus")
saveRDS(fw_SNPinfo,"fw_SNPinfo.RDS")
```

Ok, now what? I want to see if the ones that are outliers from bayenv are outliers in other things...

```{r}
summary(fw_SNPinfo[fw_SNPinfo$XtX>=quantile(fw_SNPinfo$XtX,0.99),])
```

What do I want to know? are certain chromosomes enriched?

```{r}
summary(factor(fw_SNPinfo[fw_SNPinfo$XtX>=quantile(fw_SNPinfo$XtX,0.99),"Chrom"]))
summary(factor(fw_SNPinfo[fw_SNPinfo$logSalBF>=quantile(fw_SNPinfo$logSalBF,0.99),"Chrom"]))
```

It doesn't really seem like it. 

Ok, what if I alter the plotting thing?

```{r}
pd<-do.call(rbind,lapply(lgs,function(lg,dat){
  d<-dat[dat$Chrom %in% lg,] # grab loci on this chromosome
  dsort<-d[order(d$Pos),]
  dsort$plotpos<-seq(1:nrow(dsort))
  return(dsort)
},dat=fw_SNPinfo))
bounds<-tapply(as.numeric(as.character(pd$plotpos)), pd$Chrom,max)
bounds<-data.frame(Chrom=dimnames(bounds)[[1]],End=bounds,stringsAsFactors = FALSE)

plot_dat<-assign.plotpos(pd,lgs,bounds,df.chrom = "Chrom",df.bp="plotpos")
```

```{r plotOutliers}
library(scales)
cols<-c(alpha('#e41a1c',0.75),alpha('#377eb8',0.75),alpha('#4daf4a',0.75),alpha('#984ea3',0.75))
par(mfrow=c(2,1),oma=c(1,2,1,1),mar=c(2,2,1,1),xpd=TRUE)
# plot XtX
plot_dat<-fst.plot(plot_dat,scaffs.to.plot = lgs,fst.name = "XtX",chrom.name = "Chrom",bp.name = "Pos",axis.size = 0,pch=19)
points(plot_dat$plot.pos[plot_dat$XtX>=quantile(plot_dat$XtX,0.99)],
       plot_dat$XtX[plot_dat$XtX>=quantile(plot_dat$XtX,0.99)],
       col=cols[4],cex=0.75,pch=19)
points(plot_dat$plot.pos[rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       plot_dat$XtX[rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       col=cols[1],cex=1,pch=4,lwd=2)
points(plot_dat$plot.pos[plot_dat$stacks_AL < 0.05 & plot_dat$stacks_LA < 0.05 &
                           plot_dat$stacks_TX < 0.05 & plot_dat$stacks_FL < 0.05],
       plot_dat$XtX[plot_dat$stacks_AL < 0.05 & plot_dat$stacks_LA < 0.05 &
                           plot_dat$stacks_TX < 0.05 & plot_dat$stacks_FL < 0.05],
       col=cols[2],cex=1,pch=5,lwd=2)
points(plot_dat$plot.pos[plot_dat$pcadaptQ<0.01],
       plot_dat$XtX[plot_dat$pcadaptQ<0.01],
       col=cols[3],cex=1,pch=0,lwd=2)
axis(2,las=1)
mtext(expression(italic("X")^"T"~italic("X")),2,line=2)

# add the LG labels
midpts<-tapply(plot_dat$plot.pos,plot_dat$Chrom,median)
text(x=midpts[lgs],y=0)

# plot Bayes Factors
plot_dat<-fst.plot(plot_dat,scaffs.to.plot = lgs,fst.name = "logSalBF",chrom.name = "Chrom",bp.name = "Pos",axis.size = 0,pch=19)
points(plot_dat$plot.pos[plot_dat$logSalBF>=quantile(plot_dat$logSalBF,0.99)],
       plot_dat$logSalBF[plot_dat$logSalBF>=quantile(plot_dat$logSalBF,0.99)],
       col=cols[4],cex=0.75,pch=19)
points(plot_dat$plot.pos[rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       plot_dat$logSalBF[rowSums(plot_dat[,c("perm_TX","perm_FL","perm_AL","perm_LA")])==4],
       col=cols[1],cex=1,pch=4,lwd=2)
points(plot_dat$plot.pos[plot_dat$stacks_AL < 0.05 & plot_dat$stacks_LA < 0.05 &
                           plot_dat$stacks_TX < 0.05 & plot_dat$stacks_FL < 0.05],
       plot_dat$logSalBF[plot_dat$stacks_AL < 0.05 & plot_dat$stacks_LA < 0.05 &
                           plot_dat$stacks_TX < 0.05 & plot_dat$stacks_FL < 0.05],
       col=cols[2],cex=1,pch=5,lwd=2)
points(plot_dat$plot.pos[plot_dat$pcadaptQ<0.01],
       plot_dat$logSalBF[plot_dat$pcadaptQ<0.01],
       col=cols[3],cex=1,pch=0,lwd=2)
axis(2,las=1)
mtext("log(Salinity Bayes Factors)",2,line=2)

# add the LG labels
midpts<-tapply(plot_dat$plot.pos,plot_dat$Chrom,median)
text(x=midpts[lgs],y=-5)

# add outside legend

opar <- par(fig=c(0, 1, 0, 1), oma=c(0, 0, 0, 0),
            mar=c(0, 0, 0, 0), new=TRUE)
on.exit(par(opar))
plot(0, 0, type='n', bty='n', xaxt='n', yaxt='n')
legend("top",c(expression("Permutation"~italic("F")["ST"]),
         expression("Stacks"~italic("F")["ST"]),
         "PCAdapt","BayEnv2"),xjust = 0.5,x.intersp = 0.5,
       col = cols,pt.bg=cols,pch=c(4,5,0,19),bty='n',ncol=2)
```



# 10 October 2019

Bayenv is done, now let's see what the results are.

```{r}

get_bayenv_results<-function(dir,env_vars){
  # process the variable names
  var_names<-unlist(lapply(env_vars,function(var){
    nms<-c(paste0(var,"_BF"),paste0(var,"_rho"),paste0(var,"_rs"))
    return(nms)
  }))
  # list all the files
  bf.files<-list.files(pattern="bf",path = dir,full.names = TRUE)
  xtx.files<-list.files(pattern="xtx",path=dir,full.names = TRUE)
  # get the bf files
  bf.dat<-do.call(rbind,lapply(bf.files,function(filename){
    bf<-read.table(filename,header = FALSE)
  }))
  colnames(bf.dat)<-c("locus", var_names)
  
  # xtx files
  xtx.files<-list.files(pattern="xtx",path=dir,full.names = TRUE)
  xtx.dat<-do.call(rbind,lapply(xtx.files,function(filename){
    xtx<-read.table(filename,header = FALSE,stringsAsFactors = FALSE)
  }))
  colnames(xtx.dat)<-c("locus","XtX")
  
  # combine the two
  bayenv.dat<-merge(xtx.dat,bf.dat,by="locus")
  return(bayenv.dat)
}
bayenv_dat<-get_bayenv_results(dir="bayenv/SNPFILES",env_vars=c("temp","salinity","seagrass"))


```

The SNP names are uninformative, just the row number the SNP was in. We can make these better using the freq info

```{r}
freq<-read.table("bayenv/bayenv.frq.strat",header=T, stringsAsFactors=F)
#want to get $MAC for every snp at every pop 
#and NCHROBS-MAC for every stnp at every pop
freq<-cbind(freq,freq$NCHROBS-freq$MAC)
colnames(freq)[ncol(freq)]<-"NAC"
pop.order<-levels(as.factor(freq$CLST))
snp.names<-split(freq$SNP,freq$CLST)[[1]]
snp.names<-gsub("(\\d+)_\\d+","\\1",snp.names)

loc<-as.numeric(gsub("SNPFILES/(\\d+)","\\1",bayenv_dat$locus))

bayenv_dat$locus<-snp.names[loc]
write.table(bayenv.dat,"bayenv/bayenv_output.txt",sep="\t",col.names = TRUE,row.names = FALSE,quote = FALSE)
```

Ok, I've added this to the 200_fwsw_reanalysis.Rmd document. Next step will be to plot it, which will require chromosome and bp info -- I could get this from the map file I suppose, or the vcf. Easiest is probably from the pruned map.

```{r}
pmap<-read.delim("stacks/populations_subset75/batch_2.pruned.map",header = FALSE)
pmap$locus<-gsub("(\\d+)_\\d+","\\1",pmap[,2])

bayenv_dat<-read.delim("bayenv/bayenv_output.txt",header = TRUE,stringsAsFactors = FALSE)
test<-merge(pmap[,c(1,4,5)],bayenv.dat,by="locus")
```

Hmm how are there locus names that are NA?? this is strange. Going back to the SNP name conversion above...I'll come back to this later.


# 9 October 2019

I started a populations run at home requiring loci to be in all populations, we'll see if that runs or not.

It looks like the initial runs of the FLAL, FLTX, and ALTX combinations ran without any problems, so I'll run another set, especially since the simulations are still running. I wonder if I should be doing all the pairwise comparisons. I should at least do LA compared to the others -- I've written that but will hold off running them until the simulations are done and I can re-start my computer.

Now I'm going to focus back on bayenv analysis - I've successfully run bayenv, it seems, and I've got xtx and bf files in the SNPFILES/ directory. Now I need to aggregate them. Looking at code from the popgen paper, I can see that yes I've done this before. Now I'll just write a couple functions to do this. 

```{r}
dir="bayenv/SNPFILES"
env_vars<-c("temp","salinity","seagrass")
var_names<-unlist(lapply(env_vars,function(var){
  nms<-c(paste0(var,"_BF"),paste0(var,"_rho"),paste0(var,"_BF"))
  return(nms)
}))
bf.files<-list.files(pattern="bf",path = dir,full.names = TRUE)
xtx.files<-list.files(pattern="xtx",path=dir,full.names = TRUE)

bf.dat<-do.call(rbind,lapply(bf.files,function(filename){
  bf<-read.table(filename,header = FALSE)
}))

colnames(bf.dat)<-c("locus", var_names)
```

Ok, I'm running into an interesting issue, which is that some of the files only have one number instead of three for each variable. The only problematic one seems to be 1776.freq.bf, as well as its neightbor 1776.freq.bf.freqs 

```{r}
bf.dat<-lapply(bf.files,function(filename){
   bf<-read.table(filename,header = FALSE)
  # if(ncol(bf)<10){ browser() }
 })
ncols<-lapply(bf.dat,ncol)
which(ncols<10)

bf.dat[which(ncols<10)]
bf.files[which(ncols<10)]
```


this gives me an indication that possibly bayenv ran on 1776.freq.bf somehow and now has weird stuff going on. I think I need to re-run bayenv on it and delete the other files. 

I re-ran that analysis using `~/Programs/bayenv/bayenv2 -i 1776 -m ../matrix -e ../env_data_sub75.txt -p 7 -k 100000 -n 3 -t -c -f -X -r 6842483 -o 1776.freq` and got this output

```
===== BAYENV2.0 =====

input file is set
matrix is set
environment file is set
number of populations is set
number of iterations is set
number of environmental variables is set
TEST is set
correlation output is set
frequency output is set
Calculating XtX
seed is set
output file is set
TEST = 1 . So running test at a SNP
number of environmental variables 3

MCMC VER 0.71 (THREADED)
ITERATIONS = 100000
INPUT FILE = 1776
MATRIX FILE = ../matrix
SEED = -6842483

ENVIRON FILE = ../env_data_sub75.txt
reading environ
num_alleles = 2.000000
number of loci = 1
```

So now let's try the code above again...if it works, I can continue working on it. 

```{r}
dir="bayenv/SNPFILES"
env_vars<-c("temp","salinity","seagrass")
var_names<-unlist(lapply(env_vars,function(var){
  nms<-c(paste0(var,"_BF"),paste0(var,"_rho"),paste0(var,"_BF"))
  return(nms)
}))

bf.files<-list.files(pattern="bf",path = dir,full.names = TRUE)
bf.dat<-do.call(rbind,lapply(bf.files,function(filename){
  bf<-read.table(filename,header = FALSE,stringsAsFactors = FALSE)
}))

colnames(bf.dat)<-c("locus", var_names)

xtx.files<-list.files(pattern="xtx",path=dir,full.names = TRUE)
xtx.dat<-do.call(rbind,lapply(xtx.files,function(filename){
  xtx<-read.table(filename,header = FALSE,stringsAsFactors = FALSE)
}))
colnames(xtx.dat)<-c("locus","XtX")

bayenv.dat<-merge(xtx.dat,bf.dat,by="locus")


```

Let's get the SNP names to put in the bayenv dataframe...

```{r}
freq<-read.table("bayenv/bayenv.frq.strat",header=T, stringsAsFactors=F)
#want to get $MAC for every snp at every pop 
#and NCHROBS-MAC for every stnp at every pop
freq<-cbind(freq,freq$NCHROBS-freq$MAC)
colnames(freq)[ncol(freq)]<-"NAC"
pop.order<-levels(as.factor(freq$CLST))
snp.names<-split(freq$SNP,freq$CLST)[[1]]
snp.names<-gsub("(\\d+)_\\d+","\\1",snp.names)

bayenv.dat$locus<-snp.names
```

Huh, this highlights an interesting issue, that I somehow have 24205 bf files but should only have 12103 loci. I wonder if perhaps my bayenv thing wasn't set up properly...So the bayenv file should have two rows per locus. 

I think the issue is how I created the SNPFILES -- I will need to re-do this. I think I've fixed it, so now it is 
```{r}
for(i in seq(1,(nrow(snpsfile)-1),2)){
  write.table(snpsfile[i:(i+1),],paste0(directory,"/locus",rownames(snpsfile)[i]),
              quote=F,col.names=F,row.names=F,sep='\t')
}
```

Before running this I'm going to delete the old SNPSfiles and bayenv stuff. Ok, this works! `../../scripts/run_bayenv2_matrix_general.sh SNPFILES SNPSFILE SNPFILES `.

Now to re-run bayenv...
```{bash}
nohup ../../scripts/run_bayenv2_matrix_general.sh BAYENV ~/Programs/bayenv/ matrix env_data_sub75.txt 7 3 SNPFILES > bayenv.log &
```

Ok, it's running! 

# 7 October 2019

The dadi TX simulations are almost done, but it turns out I haven't run the analyses with heterogeneous genomic migration rates. I also haven't run all of the other comparisons - maybe that's what I should run next. So I started the FLFW vs TXFW, FLFW vs ALFW, and ALFW vs TXFW. So now I've got 7 dadi runs going at once, and I'll start more eventually. 

When I get back, these are the priorities:
* Re-run populations to include all 16 populations but require more populations to be present.
* Re-run structure and treemix
* Re-run adegenet, PCAdapt, etc.


# 30 September 2019

On Saturday I wrote an R script (`plot_bayenv_matrices.R`) to plot the final matrix from each bayenv run. Now I'm going to update that script to randomly choose one and write it to `matrix` for the next bayenv step.

Ok, I've created the SNPFILEs but something is up with the environmental file, it looks like. I need to reformat it!

```{r}
env_dat<-read.csv("bayenv/env_data_raw.csv",row.names = 1)
std_dat<-t(apply(env_dat,1,function(x){
  stands<-(x-mean(x))/sd(x)
  return(stands)
}))
# make sure it's in the same order as the plinkfile
freq<-read.table("bayenv/bayenv.frq.strat",header=T, stringsAsFactors=F)
freq<-cbind(freq,freq$NCHROBS-freq$MAC)
colnames(freq)[ncol(freq)]<-"NAC"
pop.order<-levels(as.factor(freq$CLST))
snp.names<-split(freq$SNP,freq$CLST)[[1]]


write.table(std_dat[,pop.order],
            "bayenv/env_data_sub75.txt",sep='\t',col.names = FALSE,row.names = FALSE)
```


# 27 September 2019

`plink --file data --extract mysnps.txt`

SNP names are different, though, in the map than in the vcf, so I've gotta convert them. 

```{r}
map<-read.table("stacks/populations_subset75/batch_2.plink.map",header=F)	
vcf<-parse.vcf("stacks/populations_subset75/batch_2.pruned.vcf")
map$id<-gsub("(\\d+)_\\d+","\\1",map$V2)
map$pos<-map$V4+1

loci<-map[which(map$id %in% vcf$ID & map$pos %in% vcf$POS),]
```

This has too many rows, which means that some of them are duplicated. Let's dig into this...

```{r}
dups<-loci[loci$id %in% loci$id[duplicated(loci$id)],]
head(dups)
vcf[vcf$ID==18109,1:3]
```

What this shows me is that the double %in% doesn't work right. 

Ok, let's do this instead

```{r}
loci<-map[paste(map$id,map$pos,sep="_") %in% paste(vcf$ID,vcf$POS,sep="_"),]
```

That works! Now we need to write the list of snps to a file.

```{r}
write.table(loci$V2,"keptSNPs_plink.txt",quote=FALSE,col.names = FALSE,row.names = FALSE)
```

so then I ran ` ~/Programs/plink-1.07-x86_64/plink --file stacks/populations_subset75/batch_2.plink --extract keptSNPs_plink.txt --noweb --recode --out stacks/populations_subset75/batch_2.pruned`

And it seems to have worked...

```{r}
ped<-read.delim("stacks/populations_subset75/batch_2.pruned.ped",sep=' ',header = FALSE)
map<-read.delim("stacks/populations_subset75/batch_2.pruned.map",header = FALSE)
```

Except it seems to have removed the LG info from the map file. I can probably reconstruct this, though...

```{r}
map$V1<-vcf$`#CHROM`[paste(vcf$ID,vcf$POS,sep="_") %in% paste(gsub("(\\d+)_\\d+","\\1",map$V2),map$V4+1,sep="_")]
write.table(map,"stacks/populations_subset75/batch_2.pruned.map",col.names = FALSE,row.names = FALSE,quote=FALSE,sep='\t')
```

Ok, awesome, now I can run bayenv.

WAIT! these are runs with only the fw-sw pairs...do I want to use the whole populations set? If so, then maybe I don't have to run this again, but the loci probably won't match up. 

If I do want to run it again, what do I need to do to specify populations? Put the Pop ID in the family line? Ah, no, with a cluster file (i.e., a pop map)

```{r}
clust<-ped[,1:2]
clust$clust<-gsub("sample_(\\w{4}).*","\\1",clust$V2)
write.table(clust,"bayenv/sub75.pruned.clust",col.names = FALSE,row.names = FALSE,quote=FALSE)
```

Ok, I ran 
```
../scripts/run_bayenv2_matrix_general.sh bayenv/sub75.pruned.clust stacks/populations_subset75/batch_2.pruned.ped stacks/populations_subset75/batch_2.pruned.map bayenv ~/Programs/bayenv/
```
But this doesn't quite work, it says 
```
===== BAYENV2.0 =====

input file is set
number of populations is set
number of iterations is set
seed is set

!!!Missing or wrong options for chosen configuration.
```

This has to do with the script I'm using and the fact that it's not quite right and kind of janky.

Also, the plink command in the script is not creating the SNPSFILE required by bayenv...Looking back at my notes from the popgen paper, I converted the plink output into bayenv SNPSFILE in R.

I found the code and created a new script that I can run, SNPSFILEfromPLINKfrq.R, and that seems to work. 

So now I'm generating the matrices. 

What else? I really should figure out some way to plot the outliers but I'm feeling really lazy. 

# 26 September 2019

So I'm a bit concerned that I've been using the wrong vcf file to generate the dadi analyses and to do these outlier analyses. This is not a HUGE deal for the outliers, since I can fairly easily re-run them, but for dadi this is a bit concerning. I *think* I should be using `populations_subset75/batch_2.pruned.vcf`, but it looks like I used `populations_subset75/batch_2.vcf` instead. Of course, I didn't do a good job recording WHAT I pruned it for. 

Let's compare them.

```{r}
vcf<-parse.vcf("stacks/populations_subset75/batch_2.vcf")
pruned_vcf<-parse.vcf("stacks/populations_subset75/batch_2.pruned.vcf")
```

batch_2.vcf has 62497 loci, and pruned_vcf has 12103. Ok, looking more carefully at my dadi code, I see that I did subset them - whew. It was in making the dadi stuff that I created the pruned vcf. Yay former me! 

Ok, let's work on subsetting the ped and map files then. Have I solved this problem before, and would the code be in gwscaR? It doesn't look like it. But plink probably does this? Yes, it does, but I have to figure out how again. 

`plink --file data --extract mysnps.txt`



# 25 September 2019

Returning to my goal of having a 'master' data frame summarising my SNPs, I need to figure out the conversion between the stacks fst BP output and the vcf POS output. Why can't they all just be the same?!?!

```{r stacks_fsts}
fw_SNPinfo<-readRDS("fw_SNPinfo.RDS")
fwsw.al<-read.delim("stacks/populations_subset75/batch_2.fst_ALFW-ALST.tsv")
fwsw.la<-read.delim("stacks/populations_subset75/batch_2.fst_ALST-LAFW.tsv")
fwsw.tx<-read.delim("stacks/populations_subset75/batch_2.fst_TXCC-TXFW.tsv")
fwsw.fl<-read.delim("stacks/populations_subset75/batch_2.fst_FLCC-FLFW.tsv")
```

And we need to match these to the Stacks Fsts, which have multiple SNPs per locus. And of course the BP and Position don't match up between the two -- I **thought** it was BP = POS+1, but that doesn't seem to work in all cases. And of course the stacks manual is useless. The google groups says that "Stacks starts counting at 0" [unlike SAM files apparently] but this doesn't clarify the vcf vs fst output.  

```{r}
test<-merge(fw_SNPinfo,fwsw.al,by.x=c("Chrom","BP"),by.y=c("Chr","BP"),all = FALSE) 
```

This test only has 6918 rows and it should have 12103. If we keep all of the fw_SNPinfo ones:

```{r}
test<-merge(fw_SNPinfo,fwsw.al,by.x=c("Chrom","BP"),by.y=c("Chr","BP"),all.x=TRUE,all.y = FALSE) 
head(test)
```

We can see that this is super inconsistent and confusing. Let's look at the first NA one.

```{r}
fwsw.al[which(fwsw.al$Locus.ID == fw_SNPinfo$ID[3]),]
fw_SNPinfo[3,]
```

The locus is found in both but the BP is not! I wonder if some SNPs were removed from the Fst comparisons due to coverage issues or something. 

```{r}
testa<-merge(fw_SNPinfo,fwsw.al,by.x=c("Chrom","BP"),by.y=c("Chr","BP"),all = FALSE) 
testl<-merge(fw_SNPinfo,fwsw.la,by.x=c("Chrom","BP"),by.y=c("Chr","BP"),all = FALSE) 
testt<-merge(fw_SNPinfo,fwsw.tx,by.x=c("Chrom","BP"),by.y=c("Chr","BP"),all = FALSE) 
testf<-merge(fw_SNPinfo,fwsw.fl,by.x=c("Chrom","BP"),by.y=c("Chr","BP"),all = FALSE) 
```

They've all got different numbers of rows - AL has 6918, LA has 7042, TX has 3687, and FL has 2049. UGH how annoying. Ok, well we'll just move forward with this, I can't waste my life trying to make sense of this weirdness. I *could* re-run populations, but I'd need to do that at home, so I'll consider that later.

```{r}
fw_SNPinfo<-readRDS("fw_SNPinfo.RDS")
fw_SNPinfo<-merge(fw_SNPinfo,fwsw.al,by.x=c("Chrom","BP"),by.y=c("Chr","BP"),all.x=TRUE,all.y = FALSE)[,c(colnames(fw_SNPinfo),"Fisher.s.P")] 
colnames(fw_SNPinfo)[ncol(fw_SNPinfo)]<-"stacks_AL"
fw_SNPinfo<-merge(fw_SNPinfo,fwsw.la,by.x=c("Chrom","BP"),by.y=c("Chr","BP"),all.x=TRUE,all.y = FALSE)[,c(colnames(fw_SNPinfo),"Fisher.s.P")] 
colnames(fw_SNPinfo)[ncol(fw_SNPinfo)]<-"stacks_LA"
fw_SNPinfo<-merge(fw_SNPinfo,fwsw.tx,by.x=c("Chrom","BP"),by.y=c("Chr","BP"),all.x=TRUE,all.y = FALSE)[,c(colnames(fw_SNPinfo),"Fisher.s.P")] 
colnames(fw_SNPinfo)[ncol(fw_SNPinfo)]<-"stacks_TX"
fw_SNPinfo<-merge(fw_SNPinfo,fwsw.fl,by.x=c("Chrom","BP"),by.y=c("Chr","BP"),all.x=TRUE,all.y = FALSE)[,c(colnames(fw_SNPinfo),"Fisher.s.P")] 
colnames(fw_SNPinfo)[ncol(fw_SNPinfo)]<-"stacks_FL"
saveRDS(fw_SNPinfo,"fw_SNPinfo.RDS")
```

Ok, I've added that to the main analysis document (which, by the way, I think I probably need to split into sections because it's so long!). Anyway, now let's add on PCAdapt and Bayenv outliers. I'm going to use the existing code in the doc to walk through PCAdapt.


I should note that for some of these PCAdapt gives "NA" -- not sure what causes this behaviour but there it is. It's true for the residuals and everything else. It looks to be due to low allele frequencies -- though stacks should have been run with a minimum allele frequency cutoff, so this is perplexing.

### Bayenv?

Let's see what I did previously.

```{r compareEnvVar}
env.data<-read.csv("bayenv/env_data_raw.csv",row.names = 1)
env.data<-rbind(env.data,pop=c(rep("SW",12),rep("FW",4)))
env.data<-as.data.frame(t(env.data))
wilcox.test(as.numeric(env.data$temp)~env.data$pop) #ties, but p=0.539
wilcox.test(as.numeric(env.data$seagrass)~env.data$pop) #ties, but p=0.897
```


```{r bayenv}
#taken directly from fwsw_analysis.R
bf<-read.delim("bayenv/p4.bf.txt",header=T)
bf$SNP<-paste(bf$scaffold,as.numeric(as.character(bf$BP))+1,sep=".")
bf.co<-apply(bf[,5:7],2,quantile,0.99) #focus on Bayes Factors, because of Lotterhos & Whitlock (2015)
temp.bf.sig<-bf[bf$Temp_BF>bf.co["Temp_BF"],c(1,2,4,8,5,9)]
sal.bf.sig<-bf[bf$Salinity_BF>bf.co["Salinity_BF"],c(1,2,4,8,6,9)]
grass.bf.sig<-bf[bf$seagrass_BF>bf.co["seagrass_BF"],c(1,2,4,8,7,9)]
#get the log transformed Bayes Factors
bf$logSal<-log(bf$Salinity_BF)
bf$logTemp<-log(bf$Temp_BF)
bf$logSeagrass<-log(bf$seagrass_BF)

```

There are `r nrow(temp.bf.sig[temp.bf.sig$locus %in% sal.bf.sig$locus & temp.bf.sig$locus %in% grass.bf.sig,])` overlapping outliers between temperature-, salinity-, and seagrass-associated loci.

But if we only care about salinity ones, there are `r nrow(temp.bf.sig)` outliers.

This used a different dataset, so let's see if ANY of the loci are the same 

```{r}
fw_SNPinfo<-readRDS("fw_SNPinfo.RDS")
compare<-merge(fw_SNPinfo,bf,by.x = c("Chrom","BP"),by.y=c("scaffold","BP"))
```
... and `r nrow(compare)` are the same :cryface: 

So I think I need to re-run Bayenv. It looks like I already tried to do this, as I've got a fw_sub75.clust file. The run_bayenv2_matrix_general seems to be the one I want. 

It also looks like I need re-subset the ped and map files based on my vcf that I'm using.....and looking back at stuff, I think I'm currently using my dadi file, which maybe wasn't subsetted FML why is past me the worst???? Do I need to re-run dadi with a different dataset?!?!?!?!? goiajefpoiuh;oiaejoijevaoiejfoai 

# 20 September 2019

Apparently my computer restarted last night so I re-started the TX 2D simultaions. 

# 19 September 2019

1000 permutations took a while - finished ~20hrs later.

Now I'm going take a look at those that are never found in permuted range.

```{r}
perm_out<-lapply(permuted_fsts,function(x){
  outs<-x[x$act_in_perm==1,]
  return(outs)
})
names(perm_out)<-list("TXFW vs TXCC","FLFW vs FLCC","ALFW vs ALST","ALST vs LAFW")
```

```{r}
pf1a<-fst.plot(permuted_fsts[[1]],fst.name = "Fst",bp.name="Pos",pt.cex = 1,axis.size = 1,pch=19,y.lim = c(0,1))
points(pf1a$plot.pos[pf1a$act_in_perm==1],pf1a$Fst[pf1a$act_in_perm==1],col="red")
```

Hmm, the points are all over, even small values. Let's look at all four comparison.

```{r}
par(mfrow=c(4,1),mar=c(2,2,2,2))
lapply(permuted_fsts,function(perm_fst){
  pf1a<-fst.plot(perm_fst,fst.name = "Fst",bp.name="Pos",pt.cex = 1,axis.size = 1,pch=19,y.lim = c(0,1))
  points(pf1a$plot.pos[pf1a$act_in_perm==1],pf1a$Fst[pf1a$act_in_perm==1],col="red")
})
```

The nice thing is that most of the extreme outliers are captured in this analysis. The next thing to do would be to compare all of the outliers. I also should start some dadi runs.

I also started more TX simulations (4 sets of 20 sims). Hopefully none of them take 20 days! It would be really great if I could start a bunch of runs on the supercomputer or with Felipe or something. 

Before I leave for the day, I'm going to start my 'master' list of SNPs and their outlier status info. The locus IDs are in the vcf, not in the permuted_fsts dataframes, so I'll start with that.

```{r}
vcf<-parse.vcf("stacks/populations_subset75/batch_2.pruned.vcf")
fw_SNPinfo<-data.frame(ID=vcf$ID,Chrom=vcf$`#CHROM`,Pos=vcf$POS,
                       REF=vcf$REF,ALT=vcf$ALT,BP=vcf$POS-1,
                       perm_TX=permuted_fsts[[1]]$act_in_perm,
                       perm_FL=permuted_fsts[[2]]$act_in_perm,
                       perm_AL=permuted_fsts[[3]]$act_in_perm,
                       perm_LA=permuted_fsts[[4]]$act_in_perm,
                       stringsAsFactors = FALSE)
saveRDS(fw_SNPinfo,"fw_SNPinfo.RDS")
```


```{r stacks_fsts}
fwsw.al<-read.delim("stacks/populations_subset75/batch_2.fst_ALFW-ALST.tsv")
fwsw.la<-read.delim("stacks/populations_subset75/batch_2.fst_ALST-LAFW.tsv")
fwsw.tx<-read.delim("stacks/populations_subset75/batch_2.fst_TXCC-TXFW.tsv")
fwsw.fl<-read.delim("stacks/populations_subset75/batch_2.fst_FLCC-FLFW.tsv")
```

And we need to match these to the Stacks Fsts, which have multiple SNPs per locus. And of course the BP and Position don't match up between the two -- I **thought** it was BP = POS+1, but that doesn't seem to work in all cases. Ugh how frustrating. I really don't get it. 
```{r}
for(i in 1:nrow(fw_SNPinfo)){
  browser()
  fwsw.al$Fisher.s.P[which(fwsw.al$BP[which(fwsw.al$Locus.ID == fw_SNPinfo$ID[i])] == fw_SNPinfo$Pos[i]-1)]
}
test<-merge(fw_SNPinfo,fwsw.al,by.x=c("Chrom","BP"),by.y=c("Locus.ID","Chr","BP"),all.y = FALSE)
```

Hmm ok this is confusing and frustrating, I think I'm going to leave it at this and go home. 


# 18 September 2019

My goals for today are as follows:

1. Make overlapping histograms of Fst distributions for permuted and actual values. 
2. Use permutations to identify outliers (probability of actual value within permuted range?)
3. Spawn more dadi runs - possibly in parallel?
4. Create dataframe which contains for each locus:
* its information
* its stacks p-value
* its permutation probabilities
* its PCAdapt q-vale
* its XTX outlier designation
5. Make PCAdapt and Bayenv outlier plots 

So for #1 I'll start with the existing permutation distributions, just to write the code. 

```{r}
permuted_fsts<-readRDS("permuted_fsts.RDS")

```

```{r}
pop.list<-c("TXSP","TXCC","TXFW","TXCB","LAFW","ALST","ALFW","FLSG","FLKB",
	"FLFD","FLSI","FLAB","FLPB","FLHB","FLCC","FLLG")
pop.labs<-c("TXSP","TXCC","TXFW","TXCB","LAFW","ALST","ALFW","FLSG","FLKB",
            "FLFD","FLSI","FLAB","FLPB","FLHB","FLCC","FLFW")
fw.list<-c("TXFW","LAFW","ALFW","FLLG")
sw.list<-c("TXSP","TXCC","TXCB","ALST","FLSG","FLKB",
	"FLFD","FLSI","FLAB","FLPB","FLHB","FLCC")
all.colors<-c(rep("black",2),"#2166ac","black","#2166ac","black","#2166ac",
        rep("black",8),"#2166ac")
#grp.colors<-c('#e41a1c','#377eb8','#4daf4a','#984ea3','#ffff33','#f781bf')
grp.colors<-c('#762a83','#af8dc3','#e7d4e8','#d9f0d3','#7fbf7b','#1b7837')

# used this order for permutations
#pwise_maps<-list(popmap[popmap$pops %in% c("TXFW","TXCC"),],
#                 popmap[popmap$pops %in% c("FLLG","FLCC"),],
#                 popmap[popmap$pops %in% c("ALFW","ALST"),],
#                 popmap[popmap$pops %in% c("LAFW","ALST"),])

plot_labs<-list("TXFW vs TXCC","FLFW vs FLCC","ALFW vs ALST","ALST vs LAFW")
pt_cols<-list(TXTX=grp.colors[1],FLFL=grp.colors[6],
              ALAL=grp.colors[3],ALLA=grp.colors[2])
```

```{r}


plot_fst_hists<-function(perms,plot_lab=NULL,cols=NULL,permlab="mean_perm",reallab="Fst",baseplot=TRUE,inset=NULL){
  require(scales)
  if(is.null(plot_lab)){
    plot_lab<-""
  }
  if(is.null(cols)){
    cols<-c("grey","black")
  } else if(length(cols)==1){
    cols<-c("dark grey",cols)
  }
  #inset<-par()$fig
  #browser()
  if(isTRUE(baseplot)){
    hist(perms[,permlab],col=alpha(cols[1],0.5),border = alpha(cols[1],0.5),
         xlim=c(0,1),breaks = seq(0,1,0.01),main = plot_lab,xlab=expression(italic(F)[ST]),
         ylab="Number of SNPs")
    hist(perms[,reallab],col=alpha(cols[2],0.5),border = alpha(cols[2],0.5),
         xlim=c(0,1),breaks = seq(0,1,0.01),main = "",xlab=expression(italic(F)[ST]),
         ylab="Number of SNPs",add=TRUE)
  }
  if(!is.null(inset)){ # add an inset
    # adjust the fig coordinates
    ifig<-c(inset[1]+0.25*(inset[2]-inset[1]),inset[2], 
            inset[3]+0.25*(inset[4]-inset[3]), inset[4])
    par(fig = ifig,new=TRUE) # start x, end x, start y, end y (percent plotting space)
    hist(perms[,permlab][perms[,reallab]>0],col=alpha(cols[1],0.5),border = alpha(cols[1],0.5),
         xlim=c(0,1),breaks = seq(0,1,0.01),main = "",xlab="",
         ylab="")
    box() #give it a box
    hist(perms[,reallab,][perms[,reallab]>0],col=alpha(cols[2],0.5),border = alpha(cols[2],0.5),
         xlim=c(0,1),breaks = seq(0,1,0.01),main = "",xlab="",
         ylab="",add=TRUE)
  }
  invisible(par()$fig)
}

```
```{r}
png("../figs/permuted_fsts.png",pointsize = 16,height=7,width=8,units="in",res=300)
par(mfrow=c(2,2),new=FALSE,mar=c(4,4,3,1))
#plot the base
pars<-mapply(plot_fst_hists,perms=permuted_fsts,plot_lab=plot_labs,cols=pt_cols,SIMPLIFY = FALSE)
# add the insets
ipars<-mapply(plot_fst_hists,perms=permuted_fsts,plot_lab=plot_labs,cols=pt_cols,
              inset=pars,
              MoreArgs = list(baseplot=FALSE))
dev.off()
```

Ok, this works!


I need to change the output a bit and somehow evaluate the likelihood that the actual value is within the range of permuted values.
```{r}
permute.gwsca<-function(vcf,map1,nperms,z=1.96, maf.cutoff = 0.05,cov.thresh=0.2){
  # calculate the actuals
  actual_fsts<-gwsca(vcf,colnames(vcf)[1:9],
                     map1[map1[,2] %in% unique(map1[,2])[1],1],
                     map1[map1[,2] %in% unique(map1[,2])[2],1],
                     maf.cutoff=maf.cutoff,prop.ind.thresh=cov.thresh)
  # do the permutations
  perm_fsts<-lapply(1:nperms,function(i,vcf,map1){
    perm_map<-map1
    perm_map[,2]<-perm_map[,2][permute::shuffle(perm_map[,2])]
    perm_dat<-gwsca(vcf,colnames(vcf)[1:9],
                     perm_map[perm_map[,2] %in% unique(perm_map[,2])[1],1],
                     perm_map[perm_map[,2] %in% unique(perm_map[,2])[2],1],
                     maf.cutoff,cov.thresh)
   
    return(perm_dat)
  },vcf=vcf,map1=map1)
  
  # calculate stats
  fsts<-t(do.call(rbind,lapply(perm_fsts,'[[',"Fst"))) #extract permuted fsts
  perm_fst_mu<-rowMeans(fsts)
  perm_fst_in<-NULL
  for(i in 1:nrow(actual_fsts)){
    pmax<-max(fsts[i,] )
    pmin<-min(fsts[i,] )
    if(actual_fsts[i,"Fst"] > pmax | actual_fsts[i,"Fst"] < pmin ){
      perm_fst_in[i]<-1
    }else{
      perm_fst_in[i]<-0
    }
  }
  
  fst_dat<-data.frame(cbind(actual_fsts,
                            n_perms=nperms,
                            mean_perm=perm_fst_mu,
                            act_in_perm=perm_fst_in))
  return(fst_dat)
}
```
```{r}
vcf<-parse.vcf("stacks/populations_subset75/batch_2.pruned.vcf")
popmap<-data.frame(inds=colnames(vcf)[10:ncol(vcf)],
                   pops=gsub("sample_(\\w{4}).*","\\1",colnames(vcf)[10:ncol(vcf)]),
                   stringsAsFactors = FALSE)
pwise_maps<-list(popmap[popmap$pops %in% c("TXFW","TXCC"),],
                 popmap[popmap$pops %in% c("FLLG","FLCC"),],
                 popmap[popmap$pops %in% c("ALFW","ALST"),],
                 popmap[popmap$pops %in% c("LAFW","ALST"),])

TXmap<-popmap[popmap$pops %in% c("TXFW","TXCC"),]
perm_test<-permute.gwsca(vcf,TXmap,10,maf.cutoff=0,cov.thresh = 0)
```

Ok, this seems to have worked (it's a crude measure but let's go with it). Let's re-run this and generate many more permutations, then re-make the plots. 

```{r}
permuted_fsts<-lapply(pwise_maps,permute.gwsca,vcf=vcf,nperms=1000, maf.cutoff=0)
saveRDS(permuted_fsts,"permuted_fsts.RDS")
```
```{r}
png("../figs/permuted_fsts.png",pointsize = 16,height=7,width=8,units="in",res=300)
par(mfrow=c(2,2),new=FALSE,mar=c(4,4,3,1))
#plot the base
pars<-mapply(plot_fst_hists,perms=permuted_fsts,plot_lab=plot_labs,cols=pt_cols,SIMPLIFY = FALSE)
# add the insets
ipars<-mapply(plot_fst_hists,perms=permuted_fsts,plot_lab=plot_labs,cols=pt_cols,
              inset=pars,
              MoreArgs = list(baseplot=FALSE))
dev.off()
```



# 17 September 2019

My computer crashed -- 3DAL had been running for over 1600 hr and didn't even get through one replicate of one model. This is absolutely ridiculous. Luckily 254_2DoptNsim_TX_1 finished yesterday. Ah except it's not that it finished, it ran out of space! Crap. But it has finished 20 simulations so far. What's crazy to me is the variation in analysis times for the simulations -- from 5hr 49 min to 17 days! Once I restart my computer I'll run some more dadi combinations. maybe I can just do a bunch of 2D analyses and skip the 3D, unless Felipe sorts me out with something through MS Azure.

In the meantime, I'm going to work on an aspect of these analyses that is more within my control -- the Fst permutations.

```{r}
permuted_fsts<-readRDS("permuted_fsts.RDS")
```

So one of the issues with the permutations is that many of the loci are only polymorphic in one population, causing Fst to be 0, based on my calculations (because average Hs is the same as Ht). I could try another Fst calculation method but I'm not sure that will really help. But this should come out in the permutations? Are the permutations not permuting the map reliably? I think it should be. 

Looking at the variation in the Num1s after 10 permutations, it would seem that the permutations are working. What seems to be happening is that at some loci there is only one heterozygote so even if that individual gets switched it doesn't change things. 

I suppose the question is whether these perhaps-problematic loci are also problematic in the fst comparisons. The Fst output from permute.gwsca is the ACTUAL fst so I could plot those with CIs.

```{r gwscaPlot}
pf1<-fst.plot(permuted_fsts[[1]],bp.name="Pos",pt.cex = 1,axis.size = 1,pch=19)
# add lines
pos_fsts<-pf1[pf1$Fst>0,]
arrows(x0=pos_fsts$plot.pos,x1=pos_fsts$plot.pos,
       y0=pos_fsts$low_ci, y1=pos_fsts$upp_ci,
       col=c("darkgrey","lightgrey")[as.factor(pos_fsts$Chrom)],length=0)
```

Ok, so I calculated the confidence intervals around the permuted means, not the actual Fst values. 

So, how do I present these results? possibly not CIs. A difference between actual and permuted?

```{r}
par(mfrow=c(2,1))
pf1a<-fst.plot(permuted_fsts[[1]],fst.name = "Fst",bp.name="Pos",pt.cex = 1,axis.size = 1,pch=19,y.lim = c(0,1))
pf1p<-fst.plot(permuted_fsts[[1]],fst.name = "mean_perm",bp.name="Pos",pt.cex = 1,axis.size = 1,pch=19,y.lim = c(0,1))
arrows(x0=pf1p$plot.pos,x1=pf1p$plot.pos,
       y0=pf1p$low_ci, y1=pf1p$upp_ci,
       col=c("darkgrey","lightgrey")[as.numeric(pf1p$Chrom)%%2],length=0)
```

So they definitely are different. Maybe I can do a chi-squared test or something.


```{r}
fwsw.al<-read.delim("stacks/populations_subset75/batch_2.fst_ALFW-ALST.tsv")
fwsw.la<-read.delim("stacks/populations_subset75/batch_2.fst_ALST-LAFW.tsv")
fwsw.tx<-read.delim("stacks/populations_subset75/batch_2.fst_TXCC-TXFW.tsv")
fwsw.fl<-read.delim("stacks/populations_subset75/batch_2.fst_FLCC-FLFW.tsv")
```



# 9 September 2019

Ok, so that permuted Fsts thing works for permutations, but I think something odd is going on with the Fst calculations.

```{r}
permute.gwsca<-function(vcf,map1,nperms,z=1.96, maf.cutoff = 0.05,cov.thresh=0.2){
  # calculate the actuals
  actual_fsts<-gwsca(vcf,colnames(vcf)[1:9],
                     map1[map1[,2] %in% unique(map1[,2])[1],1],
                     map1[map1[,2] %in% unique(map1[,2])[2],1],
                     maf.cutoff=maf.cutoff,prop.ind.thresh=cov.thresh)
  # do the permutations
  perm_fsts<-lapply(1:nperms,function(i,vcf,map1){
    perm_map<-map1
    perm_map[,2]<-perm_map[,2][permute::shuffle(perm_map[,2])]
    perm_dat<-gwsca(vcf,colnames(vcf)[1:9],
                     perm_map[perm_map[,2] %in% unique(perm_map[,2])[1],1],
                     perm_map[perm_map[,2] %in% unique(perm_map[,2])[2],1],
                     maf.cutoff,cov.thresh)
   
    return(perm_dat)
  },vcf=vcf,map1=map1)
  
  # calculate stats
  fsts<-t(do.call(rbind,lapply(perm_fsts,'[[',"Fst"))) #extract permuted fsts
  perm_fst_mu<-rowMeans(fsts)
  perm_fst_sd<-apply(fsts,1,sd)
  perm_fst_ci<-z*perm_fst_sd/sqrt(nperms)
  fst_dat<-data.frame(cbind(actual_fsts,
                            n_perms=nperms,
                            mean_perm=perm_fst_mu,
                            low_ci=perm_fst_mu-perm_fst_ci,
                            upp_ci=perm_fst_mu+perm_fst_ci))
  return(fst_dat)
}
```
```{r}
source("../../gwscaR/R/gwscaR.R")
source("../../gwscaR/R/gwscaR_plot.R")
source("../../gwscaR/R/gwscaR_utility.R")
source("../../gwscaR/R/gwscaR_fsts.R")
source("../../gwscaR/R/gwscaR_popgen.R")
source("../../gwscaR/R/vcf2dadi.R")
```
```{r}

permuted_fsts<-readRDS("permuted_fsts.RDS")
vcf<-parse.vcf("stacks/populations_subset75/batch_2.pruned.vcf")
popmap<-data.frame(inds=colnames(vcf)[10:ncol(vcf)],
                   pops=gsub("sample_(\\w{4}).*","\\1",colnames(vcf)[10:ncol(vcf)]),
                   stringsAsFactors = FALSE)
pwise_maps<-list(popmap[popmap$pops %in% c("TXFW","TXCC"),],
                 popmap[popmap$pops %in% c("FLLG","FLCC"),],
                 popmap[popmap$pops %in% c("ALFW","ALST"),],
                 popmap[popmap$pops %in% c("LAFW","ALST"),])

TXmap<-popmap[popmap$pops %in% c("TXFW","TXCC"),]
perm_test<-permute.gwsca(vcf,TXmap,10,maf.cutoff=0,cov.thresh = 0)
```

Ok, now let's dive into this analysis. Using browser(), I deduced that this was a minimum allele frequency issue. Because the loci in this analysis have passed a global minor allele frequency threshold, I'm going to run with a maf=0. The other reason is that some of them are polymorphic only in one population, and the function currently only deals with loci that are polymoprhic in both populations. This is unfortunately most of them in the TX dataset so I might change the function. 

Now it seems to be working correctly so I'll apply it to the larger dataset.

```{r}
permuted_fsts<-lapply(pwise_maps,permute.gwsca,vcf=vcf,nperms=100, maf.cutoff=0)
saveRDS(permuted_fsts,"permuted_fsts.RDS")
```


# 5 September 2019

Returning to the idea of permutations...

I'll want to permute the labels in each pairwise comparison.

```{r}
vcf<-parse.vcf("stacks/populations_subset75/batch_2.pruned.vcf")

```

In some ways this might be easier to run in populations, but I want to try it here.

My gwscaR code isn't quite right for this because the population lists must be found in the individual IDs. So I need to re-make this using a population map framework. So here's the population map:

```{r}
popmap<-data.frame(inds=colnames(vcf)[10:ncol(vcf)],
                   pops=gsub("sample_(\\w{4}).*","\\1",colnames(vcf)[10:ncol(vcf)]),
                   stringsAsFactors = FALSE)
```

Now I want to do pairwise comparisons and permute those. 

```{r}
pwise_maps<-list(popmap[popmap$pops %in% c("TXFW","TXCC"),],
                 popmap[popmap$pops %in% c("FLLG","FLCC"),],
                 popmap[popmap$pops %in% c("ALFW","ALST"),],
                 popmap[popmap$pops %in% c("LAFW","ALST"),])
```

`gwscaR::fst.one.vcf` actually will work well -- as will `gwscaR::gwsca`. What I need to do for permutations is for each of these pairwise maps, I need to run a permutation. 

```{r}
permute.gwsca<-function(vcf,map1,nperms,z=1.96, maf.cutoff = 0.05,cov.thresh=0.2){
  # calculate the actuals
  actual_fsts<-gwsca(vcf,colnames(vcf)[1:9],
                     map1[map1[,2] %in% unique(map1[,2])[1],1],
                     map1[map1[,2] %in% unique(map1[,2])[2],1],
                     maf.cutoff,cov.thresh)
  # do the permutations
  perm_fsts<-lapply(1:nperms,function(i,vcf,map1){
    perm_map<-map1
    perm_map[,2]<-perm_map[,2][permute::shuffle(perm_map[,2])]
    return(gwsca(vcf,colnames(vcf)[1:9],
                     perm_map[perm_map[,2] %in% unique(perm_map[,2])[1],1],
                     perm_map[perm_map[,2] %in% unique(perm_map[,2])[2],1],
                     maf.cutoff,cov.thresh))
  },vcf=vcf,map1=map1)
  # calculate stats
  fsts<-t(do.call(rbind,lapply(perm_fsts,'[[',"Fst"))) #extract permuted fsts
  perm_fst_mu<-rowMeans(fsts)
  perm_fst_sd<-apply(fsts,1,sd)
  perm_fst_ci<-z*perm_fst_sd/sqrt(nperms)
  fst_dat<-data.frame(cbind(actual_fsts,
                            n_perms=nperms,
                            mean_perm=perm_fst_mu,
                            low_ci=perm_fst_mu-perm_fst_ci,
                            upp_ci=perm_fst_mu+perm_fst_ci))
  return(fst_dat)
}
```

```{r}
TXmap<-popmap[popmap$pops %in% c("TXFW","TXCC"),]
perm_test<-permute.gwsca(vcf,TXmap,10)

```

This seems like it will work, I think!

Let's try it on a larger scale:

```{r}
permuted_fsts<-lapply(pwise_maps,permute.gwsca,vcf=vcf,nperms=100)
saveRDS(permuted_fsts,"permuted_fsts.RDS")
```
Ok, I want to do permutations but I can't think about how to implement it right now. Looking at this, though there seems to be an issue, since Hs1 and Hs2 are non-zero but Hs, Ht, and Fst are 0 for some of these. I'll need to dig into this tomorrow.

# 28 August 2019

loading the file with diveRsity is pretty slow so I'm going to try subsetting it first. I'm gonna give the R package `genepopedit` a try.

```{r, eval=FALSE}
devtools::install_github("rystanley/genepopedit") #https://github.com/rystanley/genepopedit
```

```{r}
library(genepopedit)
source("../../gwscaR/R/gwscaR.R")
source("../../gwscaR/R/gwscaR_plot.R")
source("../../gwscaR/R/gwscaR_utility.R")
source("../../gwscaR/R/gwscaR_fsts.R")
source("../../gwscaR/R/gwscaR_popgen.R")
source("../../gwscaR/R/vcf2dadi.R")
library(fsthet)
source("../R/203_treemix_plotting_funcs.R")#I've modified these functions
library(knitr)
library(scales)

```
```{r}
gpop75<-my.read.genepop("stacks/populations_subset75/batch_2.genepop")
vcf<-parse.vcf("stacks/populations_subset75/batch_2.pruned.vcf")
```

It's not clear to me how to match up the genepop locus names and the IDs in the vcf file. I'm guessing that the genepop ones are ID_BP but I'm not sure. 

```{r}
gpop_ids<-as.numeric(gsub("X(\\d+)_\\d+","\\1",colnames(gpop75)[3:ncol(gpop75)]))
```
 Yes I think that's the case. `r length(gpop_ids %in% vcf$ID)` of the `r length(gpop_ids)` IDs are in the vcf file. and `r length(vcf$ID %in% gpop_ids)` of the `r length(vcf$ID)` vcf IDs are in the genepop file. The issue is that I don't know which ones I chose! Because it was done randomly and the POS is not the same as the basepair tacked onto the genepop IDs -- POS indicates the position on the chromosome, whereas the number in the genepop names is the location on the 95-bp locus.
 
The map file might be able to help me convert them

```{r}
map<-read.delim("stacks/populations_subset75/batch_2.plink.map",comment.char = "#",header=FALSE)
colnames(map)<-c("CHROM","ID_BP","X","POS")
map$ID<-as.numeric(gsub("(\\d+)_(\\d+)","\\1",map$ID_BP))
map$BP<-as.numeric(gsub("(\\d+)_(\\d+)","\\2",map$ID_BP))
# Map positions start from 1, vcf from 0
map_pruned<-map[paste(map$POS+1,map$ID,sep="_") %in% paste(vcf$POS, vcf$ID,sep="_"),]
gpop75_pruned<-gpop75[,c(colnames(gpop75)[1:2],colnames(gpop75)[colnames(gpop75) %in% paste0("X",map_pruned$ID_BP)])]
```

Woohoo, this seems to have worked!

Now I need to turn this back into genepop file format to work with diveRsity...

```{r}
library(genepopedit)
genepop_unflatten(gpop75_pruned,"stacks/populations_subset75/batch_2.pruned.genepop")

```

Ok, this seems to work. 

```{r}
library(diveRsity)
source("../R/readGenepop_modified.R") # need to load this after divRsity to mask the package fx
pop75_div<-fastDivPart(infile=gpop75_pruned,gp = 2) #readGenepop(infile="stacks/populations_subset75/batch_2.pruned.genepop",gp = 2)
```

This is not working! I ended up re-writing some of the code that parses the genepop files because diveRsity wasn't correctly parsing my genepop file for some reason (something to do with the POP specifications, as far as I can tell -- which came from genepopedit and before that from Stacks).

However, this does not get past the issues, as far as I can tell. So perhaps I should retire the idea of using this package and/or post an issue on the github. I think I should maybe abandon this and perform permutations/bootstraps on my own. 

So if I'm going to do permutations or bootstraps I might have to write it myself.

```{r}
popmap<-data.frame(pop=gsub("sample_([A-Z]{4}).*","\\1",colnames(vcf)[10:ncol(vcf)]),
                   sample=colnames(vcf)[10:ncol(vcf)],stringsAsFactors = FALSE)

```



### Pcadapt

I managed to run pcadapt again but I need a better overall plan before doing anything with the outliers.



# 27 August 2019

I'm going to try the diveRsity package.

```{r}
library(diveRsity)
pop75<-readGenepop("stacks/populations_subset75/batch_2.genepop")
vcf<-parse.vcf("stacks/populations_subset75/batch_2.pruned.vcf")

divstats<-bigDivPart(gpop75)
```

This is taking far too long. I should try this at work tomorrow.


# 19 August 2019

I'm running the heterogeneous migration models for FL on my local machine and today requested that dadi be installed on abacus. I've also prepared scripts to run FLFW vs ALFW, FLFW vs TXFW, and TXFW vs ALFW. I may need to modify those scripts further if I'm going to run them on abacus, but for now they're a start.


# 14 August 2019

I've been putting off returning to this because I don't really know what to do. With regards to dadi, I think there are a few things I need to do:

1. Incorporate admixture into models. 
2. Run models between freshwater populations, specifically TX vs FL, TX vs AL/LA, and FL vs AL/LA. I'm worried about a 3D model taking forever, so maybe run AL vs LA? Ugh this will take FOREVER. Maybe I can figure out how to run these on the server?

Ok, I'm going to read that Rougeux paper and consider using his models. Rougeux et al used 4 basic models with 13 extensions. They used strict isolation (SI), isolation with migration (IM) ancient migration (AM) and secondary contact (SC). The extensions capture effect of selection inducing reduced gene flow around loci associated with adaptive divergence. 

The way this is written makes me think that they fit the basic models and then incorporated heterogeneous gene flow plus background selection (considering local variation in Ne). So, I'm going to try to use their code to add variation in migration and Ne across the genome into the asym_mig code. I think I've done this successfully! So now to run it for FL...I've updated the 252_2DFL.py script and now will try running it on my computer. 

# 9 August 2019

Gutenkunst wrote back, saying "The suitability of dadi for this depends on what assumptions youre willing to make. Are you assuming your RADseq loci are independent? If not, youll need a much more complex simulation scheme to capture that dependence anyways. If yes, then you dont need to use coalescent simulations." I guess he doesn't want to just answer my questions. 

But I guess it brings me back to the question of what I'm even doing, in a way. Maybe I should focus on running the models with heterogeneous selection first. Do I even need to identify outliers? probably not to this extent. Blargh. I should probably run some additional models. 

I am looking at Rougeux's code: https://github.com/crougeux/Dadi_v1.6.3_modif/blob/master/Dadi_studied_model/00_inference/modeledemo_mis_new_models.py

for inspiration about the heterogeneous effective population sizes.

```{python}
def SI2N(params, (n1,n2), pts):
    nu1, nu2, Ts, nr, bf, O = params
    """
    Model with split and complete isolation, heterogenous effective population size
        (2 classes, shared by the two populations = background selection)
    nu1: Size of population 1 after split.
    nu2: Size of population 2 after split.
    Ts: The scaled time of the split
    n1,n2: Size of fs to generate.
    nr: Proportion of non/low-recombining regions
    bf : Background factor (to which extent the effective population size is reduced in the non-recombining regions)
    O: The proportion of accurate orientation
    pts: Number of points to use in grid for evaluation.
    """
    # Define the grid we'll use
    xx = dadi.Numerics.default_grid(pts)

    # Spectrum of non-recombining regions
    # phi for the equilibrium ancestral population
    phinr = dadi.PhiManip.phi_1D(xx)
    # Now do the divergence event
    phinr = dadi.PhiManip.phi_1D_to_2D(xx, phinr)
    # We set the population sizes after the split to nu1 and nu2	
    phinr = dadi.Integration.two_pops(phinr, xx, Ts, nu1*bf, nu2*bf, m12=0, m21=0)
    # Finally, calculate the spectrum.
    # oriented
    fsnrO = dadi.Spectrum.from_phi(phinr, (n1,n2), (xx,xx))
    # mis-oriented
    fsnrM = dadi.Numerics.reverse_array(fsnrO)
    
    
	# Spectrum of recombining regions
    # phi for the equilibrium ancestral population
    phir = dadi.PhiManip.phi_1D(xx)
    # Now do the divergence event
    phir = dadi.PhiManip.phi_1D_to_2D(xx, phir)
    # We set the population sizes after the split to nu1 and nu2
    phir = dadi.Integration.two_pops(phir, xx, Ts, nu1, nu2, m12=0, m21=0)
    # Finally, calculate the spectrum.
    # oriented
    fsrO = dadi.Spectrum.from_phi(phir, (n1,n2), (xx,xx))
    # mis-oriented
    fsrM = dadi.Numerics.reverse_array(fsrO)

    ### Sum the two spectra in proportion O
    fs= O*(nr*fsnrO + (1-nr)*fsrO) + (1-O) *(nr*fsnrM + (1-nr)*fsrM)

    return fs

```

I should be able to adapt this in my code, but honestly 4:30pm on a Friday is not the time to be doing this. I will work on this on Monday, I think.

Remember to be inspired by this paper: https://onlinelibrary.wiley.com/doi/full/10.1111/jeb.13482

# 8 August 2019

I'm using the code in 257_debug_ms.py to make the comparison plots.

Other things I can do: 
1. re-evaluate calculation of theta by scouring the dadi user webpage
2. run many mas sims and average the results (or increase iter?)

regarding theta, on this group (https://groups.google.com/forum/#!searchin/dadi-user/dadi$20to$20ms|sort:date/dadi-user/DYrpTHCcC_I/nl3f2eGSAQAJ) Ryan says to use  `L = 3e6 * 56,343/123,797` for someone with 3 million sites (RAD loci), a total of 123797 SNPs, of which 56343 were used. That L should then get plugged into `4*Ne*mu*L`, and dadi's theta is `4*Ne*mu*L`. So to get the ms theta, which is `4*Ne*mu*L`, we divide dadi's theta by L. So what I need to do is get L. Let's write out the variables. `L = (num loci)*(num SNPs in analysis)*(total num SNPs)` - which is different from what I did (`dadi-theta*Llocus/Ltotal` [`227.83*95/(12103*251339*95/1370051)=0.1026112`]), and does not include the length of the loci.

However, this post (https://groups.google.com/forum/#!searchin/dadi-user/dadi$20to$20ms|sort:date/dadi-user/1Chc8kXrWE0/NuB4d4X2BwAJ) uses the length of the SNPs. They did `dadi-theta*(length of sequence)/(total length of sequences used) `

I've increased the iter substantially and it is very slow, but when it is done I will test out averaging spectra (just try doing mean() with two spectra objects I guess?). Using mean does not work! Nor does dadi.Spectrum.mean(fs1,fs2)

So I posted this on the forum:

```

Thank you for your response! I have a few follow-up questions:

  1.  To calculate theta I was following what the original post had done, which was: (dadi's theta estimate)*(individual rad locus length)/(total estimated length (L)), where L = (length of RAD loci)*(total number of RAD loci)*(number of SNPs in the analysis)/(total number of SNPs). Your response prompted me to scour the dadi-user group more thoroughly and I see that this estimate differs slightly from others that have been suggested. For instance, in this post, the conversion to ms theta is (daid-theta)*(length of sequence)/(total length of sequence used), and in this post, the conversion appears to be (dadi-theta)/L, where L = (total number of rad loci)*(number of SNPs in the analysis)*(total number of SNPs). What would you say is the best way to convert dadi's estimated theta to the input theta for ms for RAD-seq data?
  2.  I think I am a bit confused about specifying the number of loci in ms. I thought the number of iterations is equivalent to the number of SNPs simulated by ms (and I had used the number of SNPs in my dataset) -- is there a different way to specify the number of SNPs, and the number of SNPs per locus, in ms?
   3. How do you recommend that I average the spectra produced by multiple ms runs to compare the models?

Thank you so much for your help and the time you put into answering all of the questions here on the forum!

```

And now I just need to wait for Gutenkunst to answer.

He responded already! He said:

```
Maybe its time to back up here. Why are you running ms again? Typically we would only do coalescent simulations if we wanted to test how linkage affects our data. But if youre simulating RAD seq loci independently and only taking one SNP per locus, then youre generating data with no linkage anyways. In this case, the only difference between dadi and ms would be if you made an error in converting model specifications.

If youre assuming youre loci are unlinked, then the likelihood dadi calculates is correct, and you can do model selection with likelihood ratio tests, etc.
```

So I responded:

```
I would like to compare the distribution of Fsts in the observed data to a null distribution, so I'm trying to simulate data using the best-inferred model for my dataset. I was under the impression that dadi does not simulate data that can be used for this purpose, so I'm trying to use ms to generate simulated data. Do you have a suggestion for a better way to do this?
```

Now it's the waiting game again

# 1 August 2019

This is the response from Ryan Gutenkunst:
```
Hi Sarah,

Your demographic parameter conversion looks fine to me. But I dont follow the theta conversion formula youre using. You want your bootstrap data sets to have the same total theta as your original data data set. Are you downsampling the ms simulations to get to one SNP per locus?

Its hard to tell whether your ms and dadi simulations agree, because the ms simulation is so sparse. Run many ms simulations then average the results to compare with the dadi model (and look at the residuals to see if there is systematic difference).

Best,
Ryan
```

And I find that response to be rather confusing. So....??? A few things to unpack:
1. Check that I've calculated theta correctly and re-write the equation.
2. How many SNPs per locus am I specifying in ms??
3. Run more ms sims and average the results 
4. How do I look at residuals? 
    Using dadi.Plotting.plot_2d_comp_multinomial between the data (fl_optimized) and models looks like it should work. I was struggling at first because I'd used different projection #s but I think it's better now?
    
I'm finding this VERY frustrating so I'm going to move onto something else for right now.


# 31 July 2019

I got ms to work within dadi by adding the msdir to the $PATH (duh). The issue was that python couldn't find the ms program.
Ok, so now troubleshooting the odd looking spectrum. I need to compare model with different cases, both the ms model and the dadi model. 
After trying a number of different models and still not finding a particularly good fit, I found that the most effective approach is to increase theta -- which implies that my estimates are not very good.

If I remove the -ej part of the ms code (but keep migration and ns) it works better. So I should probably check that -ej is the appropriate way to specify these models in the ms manual. I feel fairly confident that this is specified correctly...perhaps I should post my issue on the google group and get some feedback. 

I posted this on the dadi forum, in response to the thread from 2018 that inspired me:

```
Were you able to resolve this issue? I am running into a similar issue. In my case, I have ddRADseq data and I generated 251339 RAD loci (each 95bp long) with a total of 1370051 SNPs. I filtered and down-sampled to a dataset with 12103 unpolarized SNPs, each from a different RAD locus. I compared a number of models using Daniel Portik's dadi-pipeline and a model with ongoing asymmetric migration since a population split had the best fit.

The following forward-in-time dadi parameters were estimated from the best-fitting model:

Size of population 1 after split (nu1) = 0.1317
Size of population 2 after split (nu2) = 8.4225
Time in the past of split in units of 2*Na generations (T) = 0.1441
Migration from pop 2 to pop 1 (m12) = 0.7777
Migration from pop 1 to pop 2 (m21) = 0.0561
theta = 227.83

Based on what I've seen on this forum, I converted these parameters to ms arguments as follows:
-m 1 2 1.5554 [m12*2]
-m 2 1 0.1122 [m21*2]
-n 1 0.1317
-n 2 0.84225
-ej 0.07205 2 1 [T/2]

For theta, I converted it using the previously-recommended formula of (dadiTheta * locusLength) / ( (numSNPused * numLoci * locusLength) / totalNumSNPs ), which was:
-t = (227.83  * 95) / ( (12103 * 251339 * 95) / 1370051 )  = 0.1026112

like this:
core="-m 1 2 1.5554 -m 2 1 0.1122 -n 1 0.1317 -n 2 8.4225 -ej 0.07205 2 1"
command=dadi.Misc.ms_command(theta=0.1026112, ns=(60,70), core=core, iter=12103)
ms_fs=dadi.Spectrum.from_ms_file(os.popen(command))
folded_sfs=dadi.Spectrum.fold(ms_fs)
dadi.Plotting.plot_single_2d_sfs(folded_sfs,vmin=0.000001)


The sfs of asym_mig with these parameters looks like this:

FL_asym_mig_folded.png

But the output of the ms run above looks like this:

FL_ms_asym_mig_folded.png


Following the suggestions in this post, I tested it with equal migration between the two populations, no migration, and without the -ej term (the attached script has all of the code for these exploratory analysis). I found that removing the -ej term improved the ms-simulated sfs:

FL_ms_asym_mig_folded_noEj.png
However I'm not convinced that this ms model is the appropriate one for my dadi model.

Is anyone able to spot an issue in my implementation of the ms code? Has anyone successfully solved this type of issue?

Thank you in advance for your help!

Sarah

Attached: 257_debug_ms.py
```


Here are some of the things I tried:

```{python}
def no_divergence(notused, ns, pts):
    """
    Standard neutral model, populations never diverge.
    """
    
    xx = Numerics.default_grid(pts)
    
    phi = PhiManip.phi_1D(xx)
    phi = PhiManip.phi_1D_to_2D(xx, phi)
    
    fs = Spectrum.from_phi(phi, ns, (xx,xx))
    return fs


def no_mig(params, ns, pts):
    """
    Split into two populations, no migration.

    nu1: Size of population 1 after split.
    nu2: Size of population 2 after split.
    T: Time in the past of split (in units of 2*Na generations) 
    """
    nu1, nu2, T = params

    xx = Numerics.default_grid(pts)

    phi = PhiManip.phi_1D(xx)
    phi = PhiManip.phi_1D_to_2D(xx, phi)

    phi = Integration.two_pops(phi, xx, T, nu1, nu2, m12=0, m21=0)

    fs = Spectrum.from_phi(phi, ns, (xx,xx))
    return fs


def sym_mig(params, ns, pts):
    """
    Split into two populations, with symmetric migration.

    nu1: Size of population 1 after split.
    nu2: Size of population 2 after split.
    T: Time in the past of split (in units of 2*Na generations) 
    m: Migration rate between populations (2*Na*m)
    """
    nu1, nu2, m, T = params

    xx = Numerics.default_grid(pts)

    phi = PhiManip.phi_1D(xx)
    phi = PhiManip.phi_1D_to_2D(xx, phi)

    phi = Integration.two_pops(phi, xx, T, nu1, nu2, m12=m, m21=m)

    fs = Spectrum.from_phi(phi, ns, (xx,xx))
    return fs

# Let's try it without the asymmetric migration
m = mean([m12,m21]) #0.4169
sym_mig_fs = sym_mig(params=(nu1,nu2,m,T),ns=ns,pts=pts)
sym_mig_folded = dadi.Spectrum.fold(sym_mig_fs)
dadi.Plotting.plot_single_2d_sfs(sym_mig_folded,vmin=0.000001)

core="-m 1 2 0.8338 -m 2 1 0.8338 -n 1 0.1317 -n 2 8.4225 -ej 0.07205 2 1"
command=dadi.Misc.ms_command(theta=0.1026112, ns=(60,70), core=core, iter=12103)
ms_fs=dadi.Spectrum.from_ms_file(os.popen(command))
folded_sfs=dadi.Spectrum.fold(ms_fs)
dadi.Plotting.plot_single_2d_sfs(folded_sfs,vmin=0.000001) # this is still not great.


# no migration

no_mig_fs = no_mig(params=(nu1,nu2,T),ns=ns,pts=pts)
no_mig_folded = dadi.Spectrum.fold(no_mig_fs)
dadi.Plotting.plot_single_2d_sfs(no_mig_folded,vmin=0.000001)

core="-n 1 0.1317 -n 2 8.4225 -ej 0.07205 2 1"
command=dadi.Misc.ms_command(theta=0.1026112, ns=(60,70), core=core, iter=12103)
ms_fs=dadi.Spectrum.from_ms_file(os.popen(command))
folded_sfs=dadi.Spectrum.fold(ms_fs)
dadi.Plotting.plot_single_2d_sfs(folded_sfs,vmin=0.000001) # this is still not great.

# no divergence -- ms can't converge
no_div_fs = no_divergence([nu1,nu2],ns=ns,pts=pts)
no_div_folded = dadi.Spectrum.fold(no_div_fs)
dadi.Plotting.plot_single_2d_sfs(no_div_folded,vmin=0.000001)

core="-n 1 0.1317 -n 2 8.4225"
command=dadi.Misc.ms_command(theta=0.1026112, ns=(60,70), core=core, iter=12103)
ms_fs=dadi.Spectrum.from_ms_file(os.popen(command))
folded_sfs=dadi.Spectrum.fold(ms_fs)
dadi.Plotting.plot_single_2d_sfs(folded_sfs,vmin=0.000001) # this is still not great.

# what about a different theta?
core="-m 1 2 0.8338 -m 2 1 0.8338 -n 1 0.1317 -n 2 8.4225 -ej 0.07205 2 1"
command=dadi.Misc.ms_command(theta=.05, ns=(60,70), core=core, iter=12103)
ms_fs=dadi.Spectrum.from_ms_file(os.popen(command))
folded_sfs=dadi.Spectrum.fold(ms_fs)
dadi.Plotting.plot_single_2d_sfs(folded_sfs,vmin=0.000001) # this is still not great.

# a different time + no migration? ms t = dadi T/2
asym_mig_fs = asym_mig(params=(nu1,nu2,0,0,1),ns=ns,pts=pts)
asym_mig_folded = dadi.Spectrum.fold(asym_mig_fs)
dadi.Plotting.plot_single_2d_sfs(asym_mig_folded,vmin=0.000001)

core="-m 1 2 0 -m 2 1 0 -n 1 0.1317 -n 2 8.4225 -ej 0.5 2 1"
command=dadi.Misc.ms_command(theta=0.1026112, ns=(60,70), core=core, iter=12103)
ms_fs=dadi.Spectrum.from_ms_file(os.popen(command))
folded_sfs=dadi.Spectrum.fold(ms_fs)
dadi.Plotting.plot_single_2d_sfs(folded_sfs,vmin=0.000001)

# a different time + sym migration? ms t = dadi T/2
asym_mig_fs = asym_mig(params=(nu1,nu2,m12,m12,1),ns=ns,pts=pts)
asym_mig_folded = dadi.Spectrum.fold(asym_mig_fs)
dadi.Plotting.plot_single_2d_sfs(asym_mig_folded,vmin=0.000001)

core="-m 1 2 1.5554 -m 2 1 1.5554 -n 1 0.1317 -n 2 8.4225 -ej 0.5 2 1"
command=dadi.Misc.ms_command(theta=0.1026112, ns=(60,70), core=core, iter=12103)
ms_fs=dadi.Spectrum.from_ms_file(os.popen(command))
folded_sfs=dadi.Spectrum.fold(ms_fs)
dadi.Plotting.plot_single_2d_sfs(folded_sfs,vmin=0.000001)
# Increasing theta seems to help -- perhaps my theta estimate is not appropriate?


os.chdir("~/Research/popgen/fwsw_results/dadi_analysis")
dd = dadi.Misc.make_data_dict ( "fwsw75.dadi.snps" )
fl = dadi.Spectrum.from_data_dict(dd , pop_ids =[ 'FLLG','FLCC' ],projections =[70,61] ,polarized = False )  #polarized = False creates folded spectrum

os.chdir(fl_dir)

pts = [ 220,240 ]

#Provide best optimized parameter set for empirical data.
#These will come from previous analyses you have already completed (above)
emp_params = [0.1317,8.4225,0.7777,0.0561,0.1441]

#Indicate whether your frequency spectrum object is folded (True) or unfolded (False)
fs_folded = True

#Fit the model using these parameters and return the folded model SFS (scaled by theta).
#Here, you will want to change the "sym_mig" and sym_mig arguments to match your model function,
#but everything else can stay as it is. See above for argument explanations.
scaled_fl = Optimize_Empirical(fl, pts, "Empirical", "asym_mig", asym_mig, emp_params, fs_folded=fs_folded)




```

Also worth keeping, for inspiration/guidance, is this github site that converts ms into fst type data:
https://github.com/molpopgen/msstats

# 30 July 2019

I'm moving forward thinking about how to use the dadi simulations to analyze my Fst results (with the FL population as my first pass).
The dadi simulations only give me a sense of whether my parameters are 'good' or not, and I think they are (given the chi-squared distributions etc). I should maybe also look at the parameters as well. Once I'm confident in my parameter estimates, I'll use them to run ms. 

So looking at histograms of the simulated values, the parameters I used definitely fall within the distributions. The m21 parameter seems a bit low comopared to many of the estimates, since the median estimate is 0.3838, the variance is 0.03662088, and my initial parameter was 0.0561. I'll run with it for now, but I should maybe test different runs of ms just to be sure.

To run ms I need to estimate theta (which comes from the time parameter??) and 4N0m. Also, the population sizes need to be relative to N0. In the dadi manual, it states:
```
So to convert from a time in ai to a time in ms, divide by 2.
Migration rates are given in units of M ij = 2N ref m ij . Again, this differs from ms, where
the scaling factor is 4N ref generations. So to get equivalent migration (m ij ) in ms for a given
rate in ai, multiply by 2
```

Therefore, for Florida, I need to use time = `0.1441/2`, m12 = `0.7777*2`, m21 = `0.0561*2`.  

On the dadi forum was a question posed using this model (https://groups.google.com/forum/#!searchin/dadi-user/ms%7Csort:date/dadi-user/N623Qe75iDs/neuuqEyUAwAJ):

```

Forward in time dadi parameters:
theta = 5911.67
pop 1 relative pop size post divergence = .1009
pop 2 relative pop size post divergence = .5933
T1, time from divergence until gene flow ceases = 5.3655
T2, time from cessation of gene flow until present = 0.0269
m12 = migration from pop 2 into 1 = 1.1616
m21 = migration from pop 1 into 2 = 0.4132
pop 1 relative pop size after size change = 29.9198
pop 2 relative pop size after size change = 8.7145

To simulate unlinked RAD loci, I generate a single-locus ms command by adjusting theta to be locus specific: 5911.67 * 94/3451628, i.e. multiply theta x individual rad locus length/total estimated length (L).


MS SIM SETUP
Basically, I simulate the set of unlinked rad loci and sum their respective sfs:

ms_fs = dadi.Spectrum.from_ms_file(popen('ms 306 56055 -t 0.160995617141 -I 2 91 215 -n 1 29.9198 -n 2 8.7145 -en 0.01345 1 0.1009 -en 0.01345 2 0.5933 -em 0.01345 1 2 0.8264 -em 0.01345 2 1 2.3232 -ej 2.6962 1 2),average=False)
folded_sfs=dadi.Spectrum.fold(ms_fs)
fig = pylab.figure(1)
fig.clear()
dadi.Plotting.plot_single_2d_sfs(folded_sfs,vmin=0.005)

note that the vmin setting was the same used for the plotting of the data and dadi inferred sfs.

MS ARGS IN DETAIL
-n 1 29.9198 : relative pop size of pop 1 (post expansion) at present
-n 2 8.7145 : relative pop size of pop 2 (post expansion) at present
-en 0.01345 1 0.1009: going backward in time, pop 1 size changes, in ms units, at 0.0269/2 = 0.01345 to .1009
-en 0.01345 2 0.5933 : similarly, pop 2 size changes at same time as pop 1 to .5933 

### time parameter conversions ###
dadi parameters are forward in time, while ms is backwards. m12-dadi, the fraction of pop 1 comprised of migrants from pop 2, is equivalent in coalescent terms to m21 for ms. thus, given that dadi rates are multiplied by 2 to get equivalent ms rates:

 -em 0.1345 1 2 0.8264  : M12, the # of individuals from pop 1 comprised of backward in time migrants from pop 2
 -em 0.1345 2 1 2.3232 : M21 the # of individuals from pop 2 comprised of backward in time migrants from pop 1
 -ej 2.6962 1 2 : the full length of the genealogy in ms units is (T1+T2)/2 = (5.3655 + 0.0269)/2 = 2.6962, at which time all lineages from population 1 are moved to population 2
 
```

So what this tells me is that I can run ms from within dadi!
And The conversions I need to make are not exactly what I had thought. Information I need: number of total RAD loci and length of RAD loci. 

Then, I'll have the following parameters:

nsam = n1 + n2 [82 + 94]
nreps = NUMSNPS [12103]
-t = `dadi-theta*Llocus/Ltotal` [`227.83*95/(12103*251339*95/1370051)=0.1026112`]
-m 1 2 = `2*m12` [`2*0.7777`=1.5554]
-m 2 1 = `2*m21` [`2*0.0561`=0.1122]
-n 1 nu1 [0.1317] (size of pop 1 after split at time T)
-n 2 nu2 [2 8.4225] (size of pop 2 after split at time T)
-ej T/2 2 1 [`0.1441/2`=0.07205 2 1] (combine the populations at time T)

According to the last version of the manuscript, I had 194294 RAD loci, which are 95 bp long, and I have 12103 SNPs in the analysis. 
But according to the sstacks log, I have 251339 loci in the catalog, and there are 1370051 SNPs in batch_2.catalog.snps.tsv. So, I now have:

ms 176 12103 -t 0.1026112 -I 2 82 94 -m 1 2 1.5554 -m 2 1 0.1122 -en 0.07205 1 0.1317 -en 0.07205 2 8.4225

Ok, this is actually wrong -- the ns are the current population sizes, which formed at time T, so I need to use -ej. 
This should be the code:
ms 176 12103 -t 0.1026112 -I 2 82 94 -m 1 2 1.5554 -m 2 1 0.1122 -n 1 0.1317 -n 2 8.4225 -ej 0.07205 2 1

Now the question is whether I use command-line ms, the ms built into dadi, or msprime (which was recommended by Gutenkunst on another forum post). 

```{python}
import os
import dadi
ms_fs=dadi.Spectrum.from_ms_file(os.popen('ms 176 12103 -t 0.1026112 -I 2 82 94 -m 1 2 1.5554 -m 2 1 0.1122 -n 1 0.1317 -n 2 8.4225 -ej 0.07205 2 1'))
```
Running the above does not work. But the same commands run in ms, and I was able to read them into dadi - but the spectrum looks off. I probably need to troubleshoot like the OP of the above information did, but I'm going to come back to that.

I got this to work:


```{python}
import os
import dadi
command=dadi.Misc.ms_command(theta=0.1026112, ns=(82,94), core=core, iter=12103)
```

but I still get an error when trying to run ms in dadi. Tomorrow I will try to install msprime and give that a try.

I also found some models for heterogeneous migration across the genome:  https://github.com/crougeux/Dadi_v1.6.3_modif/blob/master/Dadi_studied_model/00_inference/modeledemo_mis_new_models.py

# 29 July 2019

Gutenkunst wrote back:

```
Hello Sarah,

Attached is the script I used look at your spectra more. Youll see that the negative values in each of the integrated spectra and the final spectrum itself are very small. If we look at the plot, the only values < 1e-12 (and thus all the negative values) are in the lower right-hand corner. If not much of your data lies in that corner, then you have nothing to worry about.

Best,
Ryan
```

with this script attached:

```{python}
from asym_mig_test import *

print('Minimum value in fs200: {0}'.format(fs200.min()))
print('Minimum value in fs250: {0}'.format(fs250.min()))
print('Minimum value in fs300: {0}'.format(fs300.min()))

spectra = [fs200,fs250,fs300]
xs = [_.extrap_x for _ in spectra]
fs_extrap = dadi.Numerics.quadratic_extrap(spectra, xs)

print('Minimum value in extrapolated spectrum: {0}'.format(fs_extrap.min()))

dadi.Plotting.plot_single_2d_sfs(fs_extrap, vmin=1e-12)

```

![2D asym_mig spectrum]("asym_mig_test.png")

Just to double check that my data aren't in that lower right-hand corner, I re-plotted my TX data with vmin=1e-12 and got this:

![2D data spectrum]("dadi_analysis/TX2D/TX_2d_sfs_smallvmin.png")

And that plot also has empty space in the bottom right-hand corner, so I think it's ok. Which means that I can ignore the warnings and move forward with my analyses of the TX runs. How many have I run, and do I need to run more? I don't think so, I have a lot of runs in the TX2D folder.

Analyzing those, I find that sym_mig_size is the best model, with optimal parameters 5.6521,4.4595,1.0109,19.9392,0.4646,1.3392,0.4042 (nu1a,nu2a,nu1b,nu2b,m,T1,T2). So I've now started the simulation code (254_2DoptNsim.py) with the TX dataset. The next big question to answer (other than how can I speed up the 3D analysis?) is how to simulate data in a way that will help me interpret my Fst values. I'm not sure that I can easily do that with dadi, I might need to use ms.


# 22 July 2019

I submitted this script to the dadi webpage for Ryan Gutenkunst to help me analyze the spectra:

```{python 255_asym_mig}
'''
Running asym_mig to compare frequency spectra
'''

import os
import numpy
import dadi
import pylab
from datetime import datetime
from dadi import Numerics, PhiManip, Integration
from dadi.Spectrum_mod import Spectrum



def asym_mig(params, ns, pts):
    """
    Split into two populations, with different migration rates.

    nu1: Size of population 1 after split.
    nu2: Size of population 2 after split.
    T: Time in the past of split (in units of 2*Na generations) 
    m12: Migration from pop 2 to pop 1 (2*Na*m12)
    m21: Migration from pop 1 to pop 2
	"""
    nu1, nu2, m12, m21, T = params
    xx = Numerics.default_grid(pts)
    
    phi = PhiManip.phi_1D(xx)
    phi = PhiManip.phi_1D_to_2D(xx, phi)
    
    phi = Integration.two_pops(phi, xx, T, nu1, nu2, m12=m12, m21=m21)
    fs = Spectrum.from_phi(phi, ns, (xx,xx))
    
    return fs    


# Set the parameters (from a run that resulted in lots of warnings)
nu1 = 1.01
nu2 = 15.4299
m12 = 0.9824
m21 = 1.1719
T = 3.6611
ns = [46,60]

# First set of points
pts = 200
xx = Numerics.default_grid(pts)
phi = PhiManip.phi_1D(xx)
phi = PhiManip.phi_1D_to_2D(xx, phi)
phi = Integration.two_pops(phi, xx, T, nu1, nu2, m12=m12, m21=m21)
fs200 = Spectrum.from_phi(phi, ns, (xx,xx))

# Second set of points
pts = 250
xx = Numerics.default_grid(pts)
phi = PhiManip.phi_1D(xx)
phi = PhiManip.phi_1D_to_2D(xx, phi)
phi = Integration.two_pops(phi, xx, T, nu1, nu2, m12=m12, m21=m21)
fs250 = Spectrum.from_phi(phi, ns, (xx,xx))

# Third set of points
pts = 300
xx = Numerics.default_grid(pts)
phi = PhiManip.phi_1D(xx)
phi = PhiManip.phi_1D_to_2D(xx, phi)
phi = Integration.two_pops(phi, xx, T, nu1, nu2, m12=m12, m21=m21)
fs300 = Spectrum.from_phi(phi, ns, (xx,xx))


```

This is in response to his email:

```
Hello Sarah,

You'll need to compare the numerical values in the spectra, using numpy functions. If you're not comfortable doing that, I can help if you send a self-contained script that generates your model and spectra.

Best,
Ryan
```

# 19 July 2019

Ok, returning to how to actually run this stuff. I want to run something like:

```{python asym_mig_goal}
asym_mig(params=[1.01,15.4299,0.9824,1.1719,3.6611], ns=[46,60] , pts=[200]) #ns are sample sizes
```

but this throws an error, "TypeError: int() argument must be a string or a number, not 'list'"

I'm not sure where this is going wrong, but it seems to be in the creation of the pts. Maybe I should run asym_mig step by step? This is asym_mig:

```{python asym_migfxn}
def asym_mig(params, ns, pts):
    """
    Split into two populations, with different migration rates.

    nu1: Size of population 1 after split.
    nu2: Size of population 2 after split.
    T: Time in the past of split (in units of 2*Na generations) 
    m12: Migration from pop 2 to pop 1 (2*Na*m12)
    m21: Migration from pop 1 to pop 2
	"""
    nu1, nu2, m12, m21, T = params
    xx = Numerics.default_grid(pts)
    
    phi = PhiManip.phi_1D(xx)
    phi = PhiManip.phi_1D_to_2D(xx, phi)
    
    phi = Integration.two_pops(phi, xx, T, nu1, nu2, m12=m12, m21=m21)
    fs = Spectrum.from_phi(phi, ns, (xx,xx))
    
    return fs    
```

```{python python_setup}
import os
import numpy
import dadi
import pylab
from datetime import datetime

#use dportik's functions
#get the optimize functions
execfile("../../programs/dadi_pipeline-master/Two_Population_Pipeline/Optimize_Functions.py")
execfile( "../../programs/dadi_pipeline-master/Two_Population_Pipeline/Models_2D.py")
execfile("../../scripts/250_custom_dadi_models.py")


# Load the data
dd = dadi.Misc.make_data_dict ( "fwsw75.dadi.snps" )
#projections is sample size of alleles
#need to use MINIMUM projections

#pops = ['FLLG', 'FLCC', 'ALFW','ALST','LAFW','TXFW','TXCC']
#projs = [70,      61,     72,     70,    72,    46,     61]

tx = dadi.Spectrum.from_data_dict(dd , pop_ids =[ 'TXFW','TXCC' ],projections =[46,60] ,polarized = False )  #polarized = False creates folded spectrum

```

So I'll try, step by step in ipython (after loading python_setup):


```{python asym_migfxn}
nu1 = 1.01
nu2 = 15.4299
m12 = 0.9824
m21 = 1.1719
T = 3.6611
ns = [46,60]

# First set of points
pts = 200
xx = Numerics.default_grid(pts)
phi = PhiManip.phi_1D(xx)
phi = PhiManip.phi_1D_to_2D(xx, phi)
phi = Integration.two_pops(phi, xx, T, nu1, nu2, m12=m12, m21=m21)
fs200 = Spectrum.from_phi(phi, ns, (xx,xx))
    
```

Incredibly, this seemed to work, so now I'll run the other points settings (250,300) and plot the resulting spectra.

```{python pts}
# Second set of points
pts = 250
xx = Numerics.default_grid(pts)
phi = PhiManip.phi_1D(xx)
phi = PhiManip.phi_1D_to_2D(xx, phi)
phi = Integration.two_pops(phi, xx, T, nu1, nu2, m12=m12, m21=m21)
fs250 = Spectrum.from_phi(phi, ns, (xx,xx))

# Third set of points
pts = 300
xx = Numerics.default_grid(pts)
phi = PhiManip.phi_1D(xx)
phi = PhiManip.phi_1D_to_2D(xx, phi)
phi = Integration.two_pops(phi, xx, T, nu1, nu2, m12=m12, m21=m21)
fs300 = Spectrum.from_phi(phi, ns, (xx,xx))
```


```{python plot_pts_sfs}
dadi.Plotting.plot_single_2d_sfs(fs200,vmin=0.01)
dadi.Plotting.plot_single_2d_sfs(fs250,vmin=0.01)
dadi.Plotting.plot_single_2d_sfs(fs300,vmin=0.01)
```

![SFS with 200 points]("dadi_analysis/TX2D/asym_mig_200ptsTest.png")
![SFS with 250 points]("dadi_analysis/TX2D/asym_mig_250ptsTest.png")
![SFS with 300 points]("dadi_analysis/TX2D/asym_mig_300ptsTest.png")

I have no idea how to interpret these. They all look basically the same. I think maybe it's time to respond to Gutenkunst's suggestion.

First, actually, I'll try the same set of code but with parameters that didn't give warnings (`r opt_warns[sample(which(opt_warns$Model=="asym_mig" & opt_warns$Warning=="FALSE"),1),]`).

```{python asym_migGoodParams}
nu1 = 1.0101
nu2 = 8.5997
m12 = 0.3722
m21 = 0.8104
T = 0.7221
ns = [46,60]

# First set of points
pts = 200
xx = Numerics.default_grid(pts)
phi = PhiManip.phi_1D(xx)
phi = PhiManip.phi_1D_to_2D(xx, phi)
phi = Integration.two_pops(phi, xx, T, nu1, nu2, m12=m12, m21=m21)
fs200 = Spectrum.from_phi(phi, ns, (xx,xx))
    
# Second set of points
pts = 250
xx = Numerics.default_grid(pts)
phi = PhiManip.phi_1D(xx)
phi = PhiManip.phi_1D_to_2D(xx, phi)
phi = Integration.two_pops(phi, xx, T, nu1, nu2, m12=m12, m21=m21)
fs250 = Spectrum.from_phi(phi, ns, (xx,xx))

# Third set of points
pts = 300
xx = Numerics.default_grid(pts)
phi = PhiManip.phi_1D(xx)
phi = PhiManip.phi_1D_to_2D(xx, phi)
phi = Integration.two_pops(phi, xx, T, nu1, nu2, m12=m12, m21=m21)
fs300 = Spectrum.from_phi(phi, ns, (xx,xx))

# Plot
dadi.Plotting.plot_single_2d_sfs(fs200,vmin=0.01)
dadi.Plotting.plot_single_2d_sfs(fs250,vmin=0.01)
dadi.Plotting.plot_single_2d_sfs(fs300,vmin=0.01)
```

![Good Params SFS with 200 points]("dadi_analysis/TX2D/asym_mig_200ptsGoodParams.png")
![Good Params SFS with 250 points]("dadi_analysis/TX2D/asym_mig_250ptsGoodParams.png")
![Good Params SFS with 300 points]("dadi_analysis/TX2D/asym_mig_300ptsGoodParams.png")

I posted these results on the dadi forum because I really have no idea what to make of them. https://groups.google.com/forum/#!topic/dadi-user/7DHNai6wDb4

# 18 July 2019

I received a response back from Gutenkunst:

```
Hello Sarah,

Sorry to hear youre running into this. The one standout from your script is that your passing in a list of 4 grid points for extrapolation, rather than the typical 3. So youre doing a cubic rather than a quadratic extrapolation. Its possible that that is less well-behaved. It certainly hasnt been tested.

If you want to dig deeper, take one of the problematic parameter sets, evaluate the sfs for each individual grid point setting, and compare them with each other and with the eventual extrapolation. (For example, if youre using pts=[20,30,40], youd calculate with pts=[20], pts=[30], pts=[40] to get three spectra, then compare among them.) That will at least give you a more specific idea of where in the spectrum the problem is and whats actually happening.

Best,
Ryan
```

So, now I have to figure out how to implement this. Some action items:

1. Obviously, I'll remove the extra pts setting -- though that shouldn't be an issue, since I added it hoping it would fix the warnings problem. [I did this, removed the 350]
2. Extract a problematic parameter set
3. Run dadi on each individual grid point setting for those parameters and compare the spectra. This step should probably be run in the interactive python environment?

From the 250_fwsw_dadi.Rmd: 

```{r dadiSetup}
knitr::opts_chunk$set(echo = TRUE,out.extra='',fig.pos="H")
knitr::opts_knit$set(root.dir='./fwsw_results/')
source("../../gwscaR/R/gwscaR.R")
source("../../gwscaR/R/gwscaR_plot.R")
source("../../gwscaR/R/gwscaR_utility.R")
source("../../gwscaR/R/gwscaR_fsts.R")
source("../../gwscaR/R/gwscaR_popgen.R")
source("../../gwscaR/R/vcf2dadi.R")
source("../R/250_dadi_analysis.R")
library(knitr)
pop.list<-c("ALFW","ALST","FLCC","FLLG","LAFW","TXCC","TXFW")
```
```{r getWarnings}
all_warnings<-lapply(list.files(pattern="251",path = "dadi_analysis",full.names = TRUE),dadi_warnings)
names(all_warnings)<-list.files(pattern="251",path = "dadi_analysis",full.names = FALSE)

#for now, focus on V1s
all_warnings<-all_warnings[c("251_2DTX_V1_1.log","251_2DTX_V1_2.log","251_2DTX_V1_3.log")] 
all_warnings<-lapply(all_warnings,function(dat) { 
  dat$Warning<-TRUE
  return(dat)
})
```

Now let's get the parameters
```{r getParams}
opt_files<-list.files(path = "dadi_analysis/TX2D",pattern="V.*optimized.*",full.names = TRUE)
opt_files<-opt_files[grep("V1",opt_files)] #focus on V1s
tx_opts<-do.call(rbind,lapply(opt_files,function(file){
  dat<-parse_dadi_opt(file)
  dat$file<-file
  return(dat)
}))
```

```{r MatchWarnings2params}
opt_warns<-do.call(rbind,mapply(function(warnings,name,opts){
  key<-gsub("251_2DTX_(V\\d)_(\\d).log","\\1_Number_\\2",name)
  dat<-merge(opts[grep(key,opts$file),],warnings,by=c("Model","Replicate"),all = TRUE)
  dat$Warning[is.na(dat$Warning)]<-FALSE
  return(dat)
},all_warnings,names(all_warnings),MoreArgs = list(opts=tx_opts),SIMPLIFY = FALSE))
```

Ok, so now I've got all the parameter combinations, let's choose a random set taht didn't work.

```{r chooseRandWarn}
opt_warns[sample(which(opt_warns$Warning==TRUE),size = 1),]
```

Ok, so looking at the manual, to run this chosen set of parameters:
                         Model            Replicate log.likelihood     AIC  chi.squared  theta                  optimized_params             params
251_2DTX_V1_2.log.243 asym_mig Round_3_Replicate_20       -1180.06 2370.12 -15550366.57 113.78 1.01,15.4299,0.9824,1.1719,3.6611 nu1,nu2,m12,m21,T.
                                                                       file Warning
251_2DTX_V1_2.log.243 dadi_analysis/TX2D/V1_Number_2.asym_mig.optimized.txt    TRUE

I need to specify the model like this:

```{python}
asym_mig([1.01,15.4299,0.9824,1.1719,3.6611], ns=[46,60] , pts=[200]) #ns are sample sizes
```


# 15 July 2019

I decided to post on the dadi forum regarding my 2D TX populations. Here is what I wrote:

```
Hi dadi community,

I'm trying to compare the fit of several models for an analysis between two populations and I'm consistently getting warnings that say
WARNING:Numerics:Extrapolation may have failed. Check resulting frequency spectrum for unexpected results.
WARNING:Inference:Model is masked in some entries where data is not.
These warnings do not go away as the model runs; they are just as likely in early runs as in later runs. Following answers to similar questions on this user group, I've tried increasing the number of points, narrowing the parameter bounds so that the model doesn't wander into difficult-to-escape parameter spaces, and using the make_extrap_func() instead of make_extrap_log_func(). However, I'm still getting these warnings pretty consistently, and not for any particular region of parameter space. I've attached a violin plot of the parameters for runs that produce warnings (left, red) and ones that don't produce warnings (right, grey) -- apologies for not making it a super pretty graph, but it conveys the idea that the parameter distributions are generally similar for the ones with warnings and the ones without. I'm getting these errors for both simple models (no migration) and complex models (ancient asymmetrical migration with population size changes). I chose the models after running 1D models for both populations, with the best fit for one population (TXCC) being growth or bottlegrowth and the best fit for the other population (TXFW) being either two_epoch or growth. The 2D frequency spectrum is attached as well.

I'm using a modified version of Daniel Portik's dadi_pipeline (https://github.com/dportik/dadi_pipeline) using the attached script. The in_params settings are ones taken from previous runs that did not produce warnings, but I get warnings whether I include those or not.

Can anyone help me understand why I'm getting these warnings and how to run the models successfully?

Thank you in advance!
```

I attached this script:
```{python, eval=FALSE}
'''
Running 2D model for TX pops
Run this from outside the dadi directory
'''

#start with ipython -pylab from ~/Research/popgen/fwsw_results/dadi_analysis/TX2D

# Numpy is the numerical library dadi is built upon
import sys
import os
import numpy
import dadi
import pylab
from datetime import datetime

#use dportik's functions
#get the optimize functions
execfile("../../programs/dadi_pipeline-master/Two_Population_Pipeline/Optimize_Functions.py")
execfile( "../../programs/dadi_pipeline-master/Two_Population_Pipeline/Models_2D.py")
execfile("../../scripts/250_custom_dadi_models.py")


# Load the data
dd = dadi.Misc.make_data_dict ( "fwsw75.dadi.snps" )
#projections is sample size of alleles
#need to use MINIMUM projections

#pops = ['FLLG', 'FLCC', 'ALFW','ALST','LAFW','TXFW','TXCC']
#projs = [70,      61,     72,     70,    72,    46,     61]

tx = dadi.Spectrum.from_data_dict(dd , pop_ids =[ 'TXFW','TXCC' ],projections =[46,60] ,polarized = False )  #polarized = False creates folded spectrum

os.chdir("TX2D")
#=================================================================================================#
#										PLOT SPECTRA	 										  #
#=================================================================================================#
dadi.Plotting.plot_single_2d_sfs(tx,vmin=0.01)


#=================================================================================================#
#										LOOP TO OPTIMIZE 										  #
#=================================================================================================#
pts = [ 200,250,300,350 ]
rounds=4
#define the lists for optional arguments
#you can change these to alter the settings of the optimization routine
reps = [10,20,30,40]
maxiters = [3,5,10,20]
folds = [3,2,2,1]
fs_folded = True
prefix = "tx"

for i in range(3,4):
	prefix = "V1_Number_{}".format(i)
	# Split into two populations, no migration.
	Optimize_Routine_Extrap(tx, pts, prefix, "no_mig", no_mig, rounds, 3, fs_folded=fs_folded, reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, T",in_params=[1.01,9.73,0.25],in_upper=[20,20,10],in_lower=[1,1,0.01])

	# Split into two populations, with continuous symmetric migration.
	Optimize_Routine_Extrap(tx, pts, prefix, "sym_mig", sym_mig, rounds, 4, fs_folded=fs_folded, reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, m, T",in_params=[1.01,9.77,0.60,1.09],in_upper=[20,20,10,10],in_lower=[1,1,0.01,0.01])

	# Split into two populations, with continuous asymmetric migration.
	Optimize_Routine_Extrap(tx, pts, prefix, "asym_mig", asym_mig, rounds, 5, fs_folded=fs_folded, reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1, nu2, m12, m21, T",in_params=[1.01,10.98,0.68,0.48,1.32],in_upper=[20,20,10,10,10],in_lower=[1,1,0.01,0.01,0.01])

	# Split with no migration, then instantaneous size change with no migration.
	Optimize_Routine_Extrap(tx, pts, prefix, "no_mig_size", no_mig_size, rounds, 6, fs_folded=fs_folded, reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1a, nu2a, nu1b, nu2b, T1, T2",in_params=[6.88,14.20,1.01,9.69,0.02,0.24],in_upper=[20,20,20,20,10,10],in_lower=[1,1,1,1,0.01,0.01])

	# Split with symmetric migration, then instantaneous size change with continuous symmetric migration.
	Optimize_Routine_Extrap(tx, pts, prefix, "sym_mig_size", sym_mig_size, rounds, 7, fs_folded=fs_folded, reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1a, nu2a, nu1b, nu2b, m, T1, T2",in_params=[14.75,2.53,1.01,14.93,0.50,0.98,0.60],in_upper=[20,20,20,20,10,10,10],in_lower=[1,1,1,1,0.01,0.01,0.01])

	# Split with different migration rates, then instantaneous size change with continuous asymmetric migration.
	Optimize_Routine_Extrap(tx, pts, prefix, "asym_mig_size", asym_mig_size, rounds, 8, fs_folded=fs_folded, reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1a, nu2a, nu1b, nu2b, m12, m21, T1, T2",in_params=[1.01,9,1.01,9.92,0.63,0.51,0.16,1.15],in_upper=[20,20,20,20,10,10,10,10],in_lower=[1,1,1,1,0.01,0.01,0.01,0.01])

	# Split with continuous symmetrical gene flow, followed by instantaneous size change with no migration.
	Optimize_Routine_Extrap(tx, pts, prefix, "anc_sym_mig_size", anc_sym_mig_size, rounds, 7, fs_folded=fs_folded, reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1a, nu2a, nu1b, nu2b, m, T1, T2",in_params=[1.88,10.50,1.01,15,6.95,1.77,0.24],in_upper=[20,20,20,20,10,10,10],in_lower=[1,1,1,1,0.01,0.01,0.01])

	# Split with continuous asymmetrical gene flow, followed by instantaneous size change with no migration.
	Optimize_Routine_Extrap(tx, pts, prefix, "anc_asym_mig_size", anc_asym_mig_size, rounds, 8, fs_folded=fs_folded, reps=reps, maxiters=maxiters, folds=folds, param_labels = "nu1a, nu2a, nu1b, nu2b, m12, m21, T1, T2",in_params=[1.34,7.49,1.01,15,9.76,7.66,1.34,0.25],in_upper=[20,20,20,20,10,10,10,10],in_lower=[1,1,1,1,0.01,0.01,0.01,0.01])


```

# 12 July 2019

So yesterday I did not get super far with the simulations, but today I'm going to focus first on the Texas population and dive into what parameter combinations are causing warnings. Meanwhile the 3D runs are going VERY slowly in the background.

I used existing functions (form previous analyses of FL2D runs) to visualize the parameters for each model in runs with warnings and ones without warnings. However, there are no obvious patterns arising. A bunch of them are different according to a wilcoxon rank test:
[1] "m21 is different in anc_asym_mig_size"
[1] "nu1b is different in anc_asym_mig_size"
[1] "nu2b is different in anc_asym_mig_size"
[1] "T1 is different in anc_asym_mig_size"
[1] "T2 is different in anc_asym_mig_size"
[1] "m is different in anc_sym_mig_size"
[1] "nu1b is different in anc_sym_mig_size"
[1] "nu2a is different in anc_sym_mig_size"
[1] "T2 is different in anc_sym_mig_size"
[1] "m12 is different in asym_mig"
[1] "m21 is different in asym_mig"
[1] "nu1 is different in asym_mig"
[1] "m21 is different in asym_mig_size"
[1] "nu1b is different in asym_mig_size"
[1] "nu2a is different in asym_mig_size"
[1] "T1 is different in asym_mig_size"
[1] "nu2a is different in no_mig_size"
[1] "T1 is different in no_mig_size"
[1] "m is different in sym_mig"
[1] "nu2 is different in sym_mig"
[1] "m is different in sym_mig_size"
[1] "nu1a is different in sym_mig_size"
[1] "nu2a is different in sym_mig_size"
[1] "nu2b is different in sym_mig_size"

but it's unclear to me how these issues can be fixed. All of these parameters seem to be ones that tend to be near the minimum or maximum values in parameter space.

I could try using other models -- that's what Gutenkunst suggests in one post: https://groups.google.com/forum/#!searchin/dadi-user/warning$20numerics$20extrapolation%7Csort:date/dadi-user/esRqfOQ7Amc/LfxsS0eog0IJ

# 11 July 2019

I'm not sure if this is the best way to go about doing this lab notebook thing, but I'm gonna give it a go. Today I'm trying to figure out how to analyze the $\delta_A\delta_I$ simulation results for the Florida populations. 

Portik used the simulated data to simply evaluate whether the empirical log-likelihoods and $\chi^2$ values are in the simulated distributions -- which I've done using the dadi-pipeline GOF R functions.

**How to implement heterogeneous migration, like in Tine et al. 2014 and Rougeux et al. 2017? $\delta_A\delta_I$??**
* The $\delta_A\delta_I$ user group has this response from Gutenkunst: "In your function, run through two sfs calculations, to create sfs1 and sfs2, then return `p*sfs1 + (1-p)*sfs2`."

**How to use simulations to analyze outlier data?**

**Updates on other $\delta_A\delta_I$ analyses:**
* Alabama & Louisiana analysis stopped after ~2.4 rounds of the first model results (possibly it's just slow, otherwise it could be an issue with the computer stalling)
* TX has lots of warnings - I want to delve into what's causing those by looking at the model output for the warning rounds.
